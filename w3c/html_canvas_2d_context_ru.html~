<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <title>HTML Canvas 2D Context — W3C</title>
    <style type="text/css">

     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     .details-example img { vertical-align: top; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

    </style>
    <style type="text/css">
       pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: block; content: 'Заметка:'; font-weight: bold;padding-bottom: 1em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; }

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Заметка: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Пример кода: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

       .translator { border: solid 2px black; background-color: #EEE9E9; padding: 5px; font-size: 15px; }

  </style>
  <link href="https://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css">
   </head>

 <body>
  <!-- Yandex.Metrika counter --> <script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter36816840 = new Ya.Metrika({ id:36816840, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/36816840" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->

<p class="translator">
Этот документ является неофициальным переводом исходной английской версии <a href="https://www.w3.org/TR/2dcontext/" target="_blank" rel="nofollow">HTML Canvas 2D Context</a>. Обратите внимание на то, что оригинальная версия документа существует <ins>только</ins> на английском языке. Данный перевод может содержать неточности и ошибки. Перевод выполнил <strong><a href="http://topolyan.com/" target="_blank">Кирилл Топольян</a></strong>, 2016.</p>

  <div class="head" id="head">
<header>

   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

    <h1>HTML Canvas 2D Context</h1>
   <h2 class="no-num no-toc subline">Рекомендация W3C от 19 ноября 2015</h2>
   </header>
<dl>
    <dt>Эта версия:</dt>
    <dd><a href="http://www.w3.org/TR/2015/REC-2dcontext-20151119/">http://www.w3.org/TR/2015/REC-2dcontext-20151119/</a></dd>
    <dt>Последняя опубликованная версия:</dt>
    <dd><a href="http://www.w3.org/TR/2dcontext/">http://www.w3.org/TR/2dcontext/</a></dd>
    <dt>Предыдущая версия:</dt>
    <dd><a href="http://www.w3.org/TR/2015/PR-2dcontext-20150924/">http://www.w3.org/TR/2015/PR-2dcontext-20150924/</a></dd>
    <dt>
      <dt id="specification-editors">Редакторы:</dt>
      <dd>W3C:</dd>
      <dd><a href="mailto:cabanier@adobe.com">Rik Cabanier</a>, Adobe Systems, Inc.</dd>
      <dd><a href="mailto:jmann@microsoft.com">Jatinder Mann</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:jaymunro@microsoft.com">Jay Munro</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:wiltzius@google.com">Tom Wiltzius</a>, Google, Inc.</dd>
      <dd>WHATWG:</dd>
      <dd><a href="mailto:ian@hixie.ch">Ian Hickson</a>, Google, Inc.</dd>
   </dl>
   <p>Посмотрите <a href="http://www.w3.org/2015/11/2dcontext-errata.html"><strong>страницу исправлений</strong></a> этого документа, которая может включать в себя изменения после публикации.</p>

   <p>Также смотрите <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=2dcontext"> <strong>переводы</strong></a>.</p>

   <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2015 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C придерживается правил <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">ответственности</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">торговой марки</a> и <a href="http://www.w3.org/Consortium/Legal/copyright-documents">использования документов</a>.</p>

</div>


  <hr class="top">


  <h2 class="no-num no-toc" id="abstract">Аннотация</h2>

  <p>Эта спецификация определяет 2D Context для HTML элемента
  <a href='http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element'><code>canvas</code></a>. 2D Context предоставляет
   объекты, методы и свойства для рисования и управления
   графиками на поверхности рисования <code>canvas</code>.</p>

  <h2 class="no-num no-toc" id="status-of-this-document">Статус этого документа</h2>

<p><em>Этот раздел описывает статус данного документа на момент его публикации. Другие документы могут заменять этот документ. Со списком текущих публикаций W3C и последней ревизией этого технического доклада можно ознакомиться в <a href="http://www.w3.org/TR/">индексе технических докладов W3C</a>, http://www.w3.org/TR/.</em></p>

    <p>
      Эта спецификация для 2D Context для HTML элемента canvas опубликована <a href='http://www.w3.org/html/wg/'>Рабочей группой HTML</a>.
    </p>


    <p>Если вы хотите оставить комментарии к этому документу в порядке
    который отслеживается W3C, пожалуйста добавьте их с помощью <a href="https://github.com/w3c/2dcontext/issues" target="_blank" rel="nofollow">нашего публичного списка вопросов</a>. Если вы не можете сделать это, вы можете отправить e-mail на <a href="mailto:public-canvas-api@w3.org">public-canvas-api@w3.org</a>
    (<a href="mailto:public-canvas-api-request@w3.org?subject=subscribe">подписка</a>,
    <a href="http://lists.w3.org/Archives/Public/public-canvas-api/" target="_blank" rel="nofollow">архивы</a>),
    и мы примем меры чтобы перенести комментарии в нашу
    публичную базу данных багов. Любая обратная связь приветствуется.</p>
    <p>
      Публикуя эту рекомендацию, W3C ожидает что функциональность описанная в этой рекомендации не будет зависеть от изменений Web IDL, CSS Object Model, CSS Images Values, или CSS Fonts так как эти спецификации прошли Рекомендацию.
    </p>
    <p>
      Работа по расширению этой спецификации, как правило, проходит через
      <a href="http://www.w3.org/html/wg/wiki/ExtensionSpecifications">расширение спецификаций</a>
      к которым следует обращаться, чтобы увидеть, какие новые возможности будут рассмотрены.
    </p>
               <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
       <p class="alt">Основная часть текста данной спецификации также доступна в WHATWG <a href="https://html.spec.whatwg.org/#2dcontext">HTML Living Standard</a>, в соответствии с лицензией, которая разрешает повторное использование текста спецификации.</p>
       <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->

  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->

  <!-- relationship to other work (required) -->

    <p>Работа по данной спецификации также сделана в <a href="https://whatwg.org/">WHATWG</a>. Рабочая группа W3C HTML активно следит за сходимостью
  HTML спецификации с рабочими стандартами WHATWG, в рамках <a href="http://www.w3.org/2013/09/html-charter.html">устава рабочей группы W3C HTML</a>. Есть разные способы следить за этой работой в WHATWG:</p>
  <ul>
      <li>Наблюдать за почтовым коммит-листом (полное сравнение исходников): <a href="http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org">http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org</a></li>
      <li>Коммиты на Github: <a href="https://github.com/whatwg/html/commits" target="_blank" rel="nofollow">https://github.com/whatwg/html/commits</a></li>
  </ul>


  <p>Этот документ был рассмотрен членами W3C, разработчиками программного обеспечения, а также другими группами W3C и заинтересованными лицами, и одобрен Директором в качестве Рекомендации W3C. Это стабильный документ и может быть использован в качестве справочного материала или цитироваться из другого документа. Цель W3C для создания Рекомендации заключается в привлечении внимания к спецификации и способствовании ее широкому распространению. Это повышает функциональность и совместимость Сети.</p>

  <p>
    <a href='https://www.w3.org/Bugs/Public/buglist.cgi?bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED&amp;bug_status=VERIFIED&amp;bug_status=CLOSED&amp;component=CR%20HTML%20Canvas%202D%20Context&amp;list_id=57536&amp;product=HTML%20WG&amp;query_format=advanced'>Старый список багов</a> по-прежнему доступен. Никаких изменений не было сделано с момента предыдущей публикации.
  </p>

 <p>
    В период рассмотрения в Рекомендации, группа сделала доступный <a href="http://w3c.github.io/test-results/2dcontext/all.html">отчет о реализации</a>, также как и <a href="https://www.w3.org/wiki/HTML/Canvas_Task_Force/CR-Test">дополнительный отчет для <code>drawFocusIfNeeded</code> и <code>addHitRegion</code></a>.
  </p>

  <p>Эта спецификация является расширением для языка HTML5. Все нормативное содержание в спецификации HTML5, если оно не было перезаписано в данной спецификации, предназначено стать основой для нее.</p>

<p>Этот документ был подготовлен группой действующей под <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">Патентной политикой W3C от 5 февраля 2004</a>. W3C поддерживает публичный <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">список открытых патентов</a>, сделанных в связи с результатами деятельности группы; эта страница также включает в себя инструкции по раскрытию патента. Человек, который имеет фактическое знание патента, который удовлетворяет <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">основным требованиям</a>, должен раскрывать информацию в соответствии с разделом 6 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">патентной политики W3C</a>.</p>

<p>Этот документ регулируется <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">W3C Process Document от 14 октября 2005</a>. </p>

  <h2 class="no-num no-toc" id="contents">Содержание</h2>

<!--begin-toc-->
<ol class="toc">
 <li><a href="#conformance-requirements"><span class="secno">1 </span>Требования к соответствию</a></li>
 <li><a href="#the-canvas-state"><span class="secno">2 </span>Состояние canvas</a></li>
 <li><a href="#line-styles"><span class="secno">3 </span>Стили линий</a></li>
 <li><a href="#text-styles"><span class="secno">4 </span>Стили текста</a></li>
 <li><a href="#building-paths"><span class="secno">5 </span>Построение пути</a></li>
 <li><a href="#transformations"><span class="secno">6 </span>Преобразования</a></li>
 <li><a href="#image-sources-for-2d-rendering-contexts"><span class="secno">7 </span>Источники изображений для 2D рендеринга</a></li>
 <li><a href="#fill-and-stroke-styles"><span class="secno">8 </span>Стили заполнения и обводки</a></li>
 <li><a href="#drawing-rectangles-to-the-canvas"><span class="secno">9 </span>Рисование прямоугольников на холсте</a></li>
 <li><a href="#drawing-text-to-the-canvas"><span class="secno">10 </span>Рисование текста на холсте</a></li>
 <li><a href="#drawing-paths-to-the-canvas"><span class="secno">11 </span>Рисование пути на холсте</a></li>
 <li><a href="#drawing-images-to-the-canvas"><span class="secno">12 </span>Рисование изображений на холсте</a></li>
 <li><a href="#hit-regions"><span class="secno">13 </span>Hit области</a></li>
 <li><a href="#pixel-manipulation"><span class="secno">14 </span>Пиксельная манипуляция</a></li>
 <li><a href="#compositing"><span class="secno">15 </span>Композиция</a></li>
 <li><a href="#shadows"><span class="secno">16 </span>Тени</a></li>
 <li><a href="#drawing-model"><span class="secno">17 </span>Модель рисования</a></li>
 <li><a href="#best-practices"><span class="secno">18 </span>Советы</a></li>
 <li><a href="#examples"><span class="secno">19 </span>Примеры</a></li>
 <li><a class="no-num" href="#references">Ссылки</a></li></ol>
<!--end-toc-->
  <hr>


  <h2 id="conformance-requirements"><span class="secno">1 </span>Требования к соответствию</h2>

  <p>Эта спецификация является спецификацией HTML. Все требования на соответствие, соответствие классов, определения, зависимости, терминология и типографские конвенции, описанные в спецификации ядра HTML5, применимы к данной спецификации. <a href="#refsHTML">[HTML]</a></p>

  <p>Интерфейсы определяются в терминах Web IDL. <a href="#refsWEBIDL">[WEBIDL]</a></p>

  <p>Эта спецификация определяет тип <dfn id="canvas-context-2d" title="canvas-context-2d"><code>2d</code></dfn> context, чей API реализован с использованием интерфейса <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>.</p>

  <div class="impl">

  <p>Когда метод <a href='http://www.w3.org/TR/html5/scripting-1.html#dom-canvas-getcontext'><code title="dom-canvas-getContext">getContext()</code></a> элемента <a href='http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element'><code>canvas</code></a> <span title="getContext-return">возвращает новый объект для <var>contextId</var></span> <code title="canvas-context-2d"><a href="#canvas-context-2d">2d</a></code>, агент пользователя должен вернуть новый объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>. Любые дополнительные аргументы игнорируются.</p>

  </div>

  <p>2D context представляет собой прямоугольную систему координат, начало которой
  (0,0) находится в верхнем левом углу, с координатами пространства, где значения
  <var>x</var> идут вправо и значения <var>y</var> идут вниз.</p>

  <pre class="idl">
typedef (<span>HTMLImageElement</span> or
         <span>HTMLVideoElement</span> or
         <span>HTMLCanvasElement</span>) <dfn id="canvasimagesource">CanvasImageSource</dfn>;

interface <dfn id="canvasrenderingcontext2d">CanvasRenderingContext2D</dfn> {

  // back-reference to the canvas
  readonly attribute <a href='http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement'><span>HTMLCanvasElement</span></a> <a href="#dom-context-2d-canvas" title="dom-context-2d-canvas">canvas</a>;

  // state
  void <a href="#dom-context-2d-save" title="dom-context-2d-save">save</a>(); // push state on state stack
  void <a href="#dom-context-2d-restore" title="dom-context-2d-restore">restore</a>(); // pop state stack and restore state
<!--
  // v7 we've also received requests for:
          attribute boolean <span title="dom-context-2d-forceHighQuality">forceHighQuality</span> // (default false)
  // when enabled, it would prevent the UA from falling back on lower-quality but faster rendering routines
  // useful e.g. for when an image manipulation app uses <canvas> both for UI previews and the actual work

-->
  // transformations (default: transform is the identity matrix)
  void <a href="#dom-context-2d-scale" title="dom-context-2d-scale">scale</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-rotate" title="dom-context-2d-rotate">rotate</a>(unrestricted double angle);
  void <a href="#dom-context-2d-translate" title="dom-context-2d-translate">translate</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-transform" title="dom-context-2d-transform">transform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void <a href="#dom-context-2d-settransform" title="dom-context-2d-setTransform">setTransform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
<!--
  // v7 we've also received requests (though not many so far) for:
  void skew(...);                             // is this common enough that one can't just use setTransform()?
  void reflect(...);  and  void mirror(...);  // aren't negative values in scale() sufficient for these?

-->
  // compositing
           attribute unrestricted double <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">globalAlpha</a>; // (default: 1.0)
           attribute DOMString <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">globalCompositeOperation</a>; // (default: "source-over")
<!--
  // v7 we've also received requests for:
  - turning off antialiasing to avoid seams when patterns are painted next to each other
    - might be better to overdraw?
    - might be better to just draw at a higher res then downsample, like for 3d?
  - nested layers
    - the ability to composite an entire set of drawing operations with one shadow all at once
      http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2008-August/015567.html

-->
  // colors and styles (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
           attribute (DOMString or CanvasGradient or CanvasPattern) <a href="#dom-context-2d-strokestyle" title="dom-context-2d-strokeStyle">strokeStyle</a>; // (default: "black")
           attribute (DOMString or CanvasGradient or CanvasPattern) <a href="#dom-context-2d-fillstyle" title="dom-context-2d-fillStyle">fillStyle</a>; // (default: "black")
  <a href="#canvasgradient">CanvasGradient</a> <a href="#dom-context-2d-createlineargradient" title="dom-context-2d-createLinearGradient">createLinearGradient</a>(double x0, double y0, double x1, double y1);
  <a href="#canvasgradient">CanvasGradient</a> <a href="#dom-context-2d-createradialgradient" title="dom-context-2d-createRadialGradient">createRadialGradient</a>(double x0, double y0, double r0, double x1, double y1, double r1);
  <a href="#canvaspattern">CanvasPattern</a> <a href="#dom-context-2d-createpattern" title="dom-context-2d-createPattern">createPattern</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, [TreatNullAs=EmptyString] DOMString repetition);

  // shadows
           attribute unrestricted double <a href="#dom-context-2d-shadowoffsetx" title="dom-context-2d-shadowOffsetX">shadowOffsetX</a>; // (default: 0)
           attribute unrestricted double <a href="#dom-context-2d-shadowoffsety" title="dom-context-2d-shadowOffsetY">shadowOffsetY</a>; // (default: 0)
           attribute unrestricted double <a href="#dom-context-2d-shadowblur" title="dom-context-2d-shadowBlur">shadowBlur</a>; // (default: 0)
           attribute DOMString <a href="#dom-context-2d-shadowcolor" title="dom-context-2d-shadowColor">shadowColor</a>; // (default: "transparent black")

  // rects
  void <a href="#dom-context-2d-clearrect" title="dom-context-2d-clearRect">clearRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-fillrect" title="dom-context-2d-fillRect">fillRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-strokerect" title="dom-context-2d-strokeRect">strokeRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);

  // path API (see also <a href="#canvaspathmethods">CanvasPathMethods</a>)
  void <a href="#dom-context-2d-beginpath" title="dom-context-2d-beginPath">beginPath</a>();
  void <a href="#dom-context-2d-fill" title="dom-context-2d-fill">fill</a>();
  void <a href="#dom-context-2d-stroke" title="dom-context-2d-stroke">stroke</a>();
  void <a href="#dom-context-2d-drawfocusifneeded" title="dom-context-2d-drawFocusIfNeeded">drawFocusIfNeeded</a>(<span>Element</span> element);
  void <a href="#dom-context-2d-clip" title="dom-context-2d-clip">clip</a>();
  boolean <a href="#dom-context-2d-ispointinpath" title="dom-context-2d-isPointInPath">isPointInPath</a>(unrestricted double x, unrestricted double y);

  // text (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
  void <a href="#dom-context-2d-filltext" title="dom-context-2d-fillText">fillText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void <a href="#dom-context-2d-stroketext" title="dom-context-2d-strokeText">strokeText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);<!-- v6DVT
  void <span title="dom-context-2d-fillVerticalText">fillVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight);
  void <span title="dom-context-2d-strokeVerticalText">strokeVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight); -->
  <a href="#textmetrics">TextMetrics</a> <a href="#dom-context-2d-measuretext" title="dom-context-2d-measureText">measureText</a>(DOMString text);

  // drawing images
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy);
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);

  // hit regions
  void <a href="#dom-context-2d-addhitregion" title="dom-context-2d-addHitRegion">addHitRegion</a>(<a href="#hitregionoptions">HitRegionOptions</a> options);
  void <a href="#dom-context-2d-removehitregion" title="dom-context-2d-removeHitRegion">removeHitRegion</a>(DOMString id);
  void <a href="#dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions">clearHitRegions</a>();

  // pixel manipulation
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-createimagedata" title="dom-context-2d-createImageData">createImageData</a>(unrestricted double sw, unrestricted double sh);
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-createimagedata" title="dom-context-2d-createImageData">createImageData</a>(<a href="#imagedata">ImageData</a> imagedata);
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-getimagedata" title="dom-context-2d-getImageData">getImageData</a>(double sx, double sy, double sw, double sh);
  void <a href="#dom-context-2d-putimagedata" title="dom-context-2d-putImageData">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy);
  void <a href="#dom-context-2d-putimagedata" title="dom-context-2d-putImageData">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
};
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvasdrawingstyles">CanvasDrawingStyles</a>;
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvaspathmethods">CanvasPathMethods</a>;

[NoInterfaceObject]
interface <dfn id="canvasdrawingstyles">CanvasDrawingStyles</dfn> {
  // line caps/joins
           attribute unrestricted double <a href="#dom-context-2d-linewidth" title="dom-context-2d-lineWidth">lineWidth</a>; // (default: 1)
           attribute DOMString <a href="#dom-context-2d-linecap" title="dom-context-2d-lineCap">lineCap</a>; // "butt", "round", "square" (default: "butt")
           attribute DOMString <a href="#dom-context-2d-linejoin" title="dom-context-2d-lineJoin">lineJoin</a>; // "round", "bevel", "miter" (default: "miter")
           attribute unrestricted double <a href="#dom-context-2d-miterlimit" title="dom-context-2d-miterLimit">miterLimit</a>; // (default: 10)

  // dashed lines
  void <a href="#dom-context-2d-setlinedash" title="dom-context-2d-setLineDash">setLineDash</a>(sequence&lt;unrestricted double&gt; segments); // (default: empty)
  sequence&lt;unrestricted double&gt; <a href="#dom-context-2d-getlinedash" title="dom-context-2d-getLineDash">getLineDash</a>();
           attribute unrestricted double <a href="#dom-context-2d-linedashoffset" title="dom-context-2d-lineDashOffset">lineDashOffset</a>;


  // text
           attribute DOMString <a href="#dom-context-2d-font" title="dom-context-2d-font">font</a>; // (default: "10px sans-serif")
           attribute DOMString <a href="#dom-context-2d-textalign" title="dom-context-2d-textAlign">textAlign</a>; // "start", "end", "left", "right", "center" (default: "start")
           attribute DOMString <a href="#dom-context-2d-textbaseline" title="dom-context-2d-textBaseline">textBaseline</a>; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
};

[NoInterfaceObject]
interface <dfn id="canvaspathmethods">CanvasPathMethods</dfn> {
  // shared path API methods
  void <a href="#dom-context-2d-closepath" title="dom-context-2d-closePath">closePath</a>();
  void <a href="#dom-context-2d-moveto" title="dom-context-2d-moveTo">moveTo</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-lineto" title="dom-context-2d-lineTo">lineTo</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-quadraticcurveto" title="dom-context-2d-quadraticCurveTo">quadraticCurveTo</a>(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-beziercurveto" title="dom-context-2d-bezierCurveTo">bezierCurveTo</a>(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-arcto" title="dom-context-2d-arcTo">arcTo</a>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius); <!-- see ARC-ORDER note below -->
  void <a href="#dom-context-2d-rect" title="dom-context-2d-rect">rect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-arc" title="dom-context-2d-arc">arc</a>(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean counterclockwise = false); <!-- see ARC-ORDER note below -->

  };

interface <dfn id="canvasgradient">CanvasGradient</dfn> {
  // opaque object
  void <a href="#dom-canvasgradient-addcolorstop" title="dom-canvasgradient-addColorStop">addColorStop</a>(double offset, DOMString color);
};

interface <dfn id="canvaspattern">CanvasPattern</dfn> {
  // opaque object
};

interface <dfn id="textmetrics">TextMetrics</dfn> {
  readonly attribute double <a href="#dom-textmetrics-width-0" title="dom-textmetrics-width">width</a>;
};

dictionary <dfn id="hitregionoptions">HitRegionOptions</dfn> {
  // dictionary to allow expansion on Hit Regions in Canvas Context 2D Level 2
  <span>DOMString</span> <span title="dom-HitRegionOptions-id">id</span> = "";
  // for control-backed regions:
  <span>Element?</span> <span title="dom-HitRegionOptions-control">control</span> = null;
};

interface <dfn id="imagedata">ImageData</dfn> {
  readonly attribute unsigned long <a href="#dom-imagedata-width" title="dom-imagedata-width">width</a>;
  readonly attribute unsigned long <a href="#dom-imagedata-height" title="dom-imagedata-height">height</a>;
  readonly attribute <span>Uint8ClampedArray</span> <a href="#dom-imagedata-data" title="dom-imagedata-data">data</a>;
};

</pre>

 <!-- ARC-ORDER note (see above):
      some demos rely on the precise order of the arc() and arcTo()
      methods, see https://bugzilla.mozilla.org/show_bug.cgi?id=623437
      for an example, and its duplicates for more -->

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code></dt>

   <dd>

    <p>Возвращает элемент <code>canvas</code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-context-2d-canvas" title="dom-context-2d-canvas"><code>canvas</code></dfn>
  должен возвращать элемент <code>canvas</code>, нарисованный контекстом.</p>

  <p>За исключением случаев когда указано иное, для 2D context интерфейса,
  <strong>любой вызов метода с числовым аргументом, значение которого бесконечно либо NaN, должен быть проигнорирован</strong>.</p>

  <!--
   Philip Taylor wrote:
   > My experience with some 3d canvas code is that infinities come up in
   > naturally harmless places, e.g. having a function that scales by x then
   > translates by 1/x and wanting it to work when x=0 (which ought to draw
   > nothing, since anything it draws is zero pixels wide), and it's a bit
   > annoying to track down and fix those issues, so I'd probably like it if
   > they were harmless in canvas methods. Opera appears to silently not draw
   > anything if the transformation matrix is not finite, but Firefox <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throws</a>
   > exceptions when passing in non-finite arguments.
  -->

  <p>Всякий раз, когда значение CSS <code>currentColor</code> используется в качестве цвета в этом API, вычисленное значения свойства 'color'
  для целей определения вычисленного значения <code>currentColor</code>, ключевым словом является вычисленное значение
  'color' элемента о котором идет речь, когда цвет задан (например когда соответствующий атрибут установлен или когда вызван метод; не тогда когда цвет визуализируется или в другом случае). Если вычисленное значение свойства 'color' не определено для конкретного случая (например, потому что элемент находится не
  <span>в <code>Document</code></span>), то для определения вычисленного значения свойства 'color' определяется значением <code>currentColor</code>, ключевое слово полностью непрозрачный черный. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p>В случае с <code title="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop()</a></code> на
  <code><a href="#canvasgradient">CanvasGradient</a></code>, для целей определения вычисленного значения
  <code>currentColor</code> ключевое слово всегда полностью непрозрачный черный (нет связанного с ним элемента). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p class="note">Это потому что объекты <code><a href="#canvasgradient">CanvasGradient</a></code> <code>canvas</code>-нейтральные —
  объект <code><a href="#canvasgradient">CanvasGradient</a></code> созданный одним <code>canvas</code> может использоваться другим, и поэтому
  нет способа узнать "элемент в деле" в то время как цвет определен.</p>

  <p class="note">Это касается также шрифтов, правила для них подробно описаны в разделе ниже.</p>

  </div>



<!--FIXUP 2dcontext +4-->
  <h2 id="the-canvas-state"><span class="secno">2 </span>Состояние canvas</h2>

  <p>Каждый контекст поддерживает стек из состояний рисования. <dfn id="drawing-state" title="drawing state">Состояние рисования</dfn> состоит из:</p>

  <ul class="brief">
   <li>Текущей <a href="#transformations" title="dom-context-2d-transformation">матрицы преобразования</a>.</li>
   <li>Текущего <a href="#clipping-region">clipping region</a>.</li>
   <li>Текущих значений следующих атрибутов: <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>, <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>, <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>, <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>, <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>, <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code>, <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code>, <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code>, <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>, <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>, <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>, <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code>, <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>.</li>
  </ul>

  <p class="note">Текущий путь и текущий битмап не являются частью состояния рисования. <span>Текущий путь</span> постоянен и может быть сброшен только с помощью
  метода <code title="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath()</a></code>.
  Текущий битмап является свойством холста, а не контекста.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-save"><a href="#dom-context-2d-save">save</a></code>()</dt>

   <dd>

    <p>Сохраняет текущее состояние в стек.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-restore"><a href="#dom-context-2d-restore">restore</a></code>()</dt>

   <dd>

    <p>Сбрасывает верхнее состояние в стеке, восстанавливая контекст к этому состоянию.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-save" title="dom-context-2d-save"><code>save()</code></dfn>
  должен поместить копию текущего состояния на стек состояния рисования.</p>

  <p>Метод <dfn id="dom-context-2d-restore" title="dom-context-2d-restore"><code>restore()</code></dfn> должен взять верхний элемент в стеке состояния, и сбросить состояние которое он описывает. Если нет сохраненного состояния, метод не должен делать ничего.</p>

  <!-- v7
idea from Mihai:
> 5. Drawing states should be saveable with IDs, and for easier restoring.
>
> save(id)
> restore(id)
>
> If id is not provided, then save() works as defined now. The same for
> restore().
>
> Currently, it's not trivial to save and restore a specific state.
...and from Philip:
> I think a more convenient syntax would be:
>   var state = ctx.save();
>   ctx.restore(state);
> But how would it interact with normal calls to ctx.restore()?
  -->

  </div>


  <h2 id="line-styles"><span class="secno">3 </span>Стили линий</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущую ширину линии.</p>

    <p>Может быть установлен, чтобы изменить ширину линии. Дробные значения больше нуля игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает стиль окончания линии.</p>

    <p>Может быть установлен для изменения стиля окончания.</p>

    <p>Возможные значения: "<code>butt</code>",
    "<code>round</code>", и "<code>square</code>". Другие значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль соединения линии.</p>

    <p>Может быть установлен для изменения стиля соединения.</p>

    <p>Возможные стили "<code>bevel</code>",
    "<code>round</code>", и "<code>miter</code>". Другие значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущее значение miter limit.</p>

    <p>Может быть установлен для изменения значения miter limit. Дробные значения кроме нуля игнорируются.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-setLineDash"><a href="#dom-context-2d-setlinedash">setLineDash</a></code>(<var>segments</var>)</dt>

   <dd>

    <p>Устанавливает текущий шаблон пунктирной линии (используется при сглаживании). Аргумент представляет собой массив расстояний.</p>

   </dd>


   <dt><var>segments</var> = <var>context</var> . <code title="dom-context-2d-getLineDash"><a href="#dom-context-2d-getlinedash">getLineDash</a></code>()</dt>

   <dd>

    <p>Возвращает копию текущего шаблона пунктирной линии. Возвращаемый массив всегда будет иметь четное количество записей (т.е. оно нормализуется).</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает смещение фазы (в тех же единицах, что и пунктирная линия).</p>

    <p>Может быть установлен для изменения смещения фазы. Дробные значения игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Объекты, которые реализуют интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  имеют атрибуты и методы (определенные в этом разделе), которые контролируют как линии обрабатываются объектом.</p>

  <p>Атрибут <dfn id="dom-context-2d-linewidth" title="dom-context-2d-lineWidth"><code>lineWidth</code></dfn>
  задает ширину линий в координатном пространстве единиц. При получении, он должен вернуть текущее значение. При установке нулевого,
  негативного, бесконечного и NaN, значения должны быть проигнорированы, оставляя значение без изменений; другие значения должны изменить его на текущее значение.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> создан, атрибут <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> должен изначально иметь значение <code>1.0</code>.</p>

  <hr>

  <p>Атрибут <dfn id="dom-context-2d-linecap" title="dom-context-2d-lineCap"><code>lineCap</code></dfn> определяет тип окончаний которые агент пользователя поместит на конец линий.
  Три валидных значения: "<code>butt</code>", "<code>round</code>",
  и "<code>square</code>".</p>

  <p>При получении, он должен вернуть текущее значение. При настройке, если новое значение является одной из строк "<code>butt</code>",
  "<code>round</code>", и "<code>square</code>", текущее значение
  должно быть изменено на новое значение; другие значения должны игнорироваться и ничего не менять.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> должен изначально иметь значение "<code>butt</code>".</p>

  <hr>

  <p>Атрибут <dfn id="dom-context-2d-linejoin" title="dom-context-2d-lineJoin"><code>lineJoin</code></dfn>
  определяет тип соединения, которое агент пользователя поместит туда где две линии встречаются. Есть три валидных значения: "<code>bevel</code>",
  "<code>round</code>", и "<code>miter</code>".</p>

  <p>При получении, он должен вернуть текущее значение. При настройке, если новое значение одно из "<code>bevel</code>",
  "<code>round</code>" или "<code>miter</code>", текущее значение изменится на новое; другие значения будут проигнорированы и ничего не изменят.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> должен изначально иметь значение "<code>miter</code>".</p>

  <hr>

  <p>Когда атрибут <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>
  имеет значение "<code>miter</code>", штрихи используют значение miter
  limit чтобы решить как соединиться. Значение miter limit ratio
  может быть задано атрибутом <dfn id="dom-context-2d-miterlimit" title="dom-context-2d-miterLimit"><code>miterLimit</code></dfn>. При получении, он должен вернуть текущее значение. При настройке,
  нулевые, отрицательные, бесконечные и NaN значения должны игнорироваться, не меняя значение; другие значения должны изменять текущее на новое значение.</p>
  <!-- values less than 1.0 are equivalent to 1.0, since it's compared
       against a ratio that can't be less than 1.0 -->

  <p>Когда объект, реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> должен изначально иметь значение <code>10.0</code>.</p>

  <hr>

  <hr><p>Каждый объект <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> имеет <dfn id="dash-list">dash list</dfn>, который либо пуст, либо состоит из четного числа и положительных ненулевых чисел. Изначально <a href="#dash-list">dash list</a>
  должен быть пуст.</p>

  <p>Когда вызывается метод <dfn id="dom-context-2d-setlinedash" title="dom-context-2d-setLineDash"><code>setLineDash()</code></dfn>
  он должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать <var>a</var> копией массива предоставленного в качестве аргумента.</p></li>

   <li><p>Если какое-либо значение в массиве не является конечным числом (например бесконечное или NaN), или значение негативное (меньше ноля), то прервать эти шаги (без исключений; пользовательский агент может показать сообщение на консоли разработчика, это может помочь для отладки).</p></li>

   <li><p>Если число элементов в <var>a</var> нечетное,
   то сделать <var>a</var> результатом сложения двух копий <var>a</var>.</p></li>

   <li><p>Позволить объекту <a href="#dash-list">dash list</a> быть <var>a</var>.</p></li>

  </ol>

  <p>Когда вызывается метод <dfn id="dom-context-2d-getlinedash" title="dom-context-2d-getLineDash"><code>getLineDash()</code></dfn>, он должен вернуть созданный массив, значения которого являются значениями объекта <a href="#dash-list">dash list</a>, в том же порядке.</p>

  <p>Иногда полезно изменить "фазу" паттерна пунктира, например для достижения эффекта "бегущих муравьев". Фаза может быть установлена с  помощью атрибута <dfn id="dom-context-2d-linedashoffset" title="dom-context-2d-lineDashOffset"><code>lineDashOffset</code></dfn>. При получении, он должен возвратить текущее значение. При настройке,
  бесконечные и NaN значения должны быть проигнорированы, оставив значение без изменений; другие значения должны изменить текущее значение на новое.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>
  должен изначально иметь значение <code>0.0</code>.</p>

   <hr>

  <p>Когда пользовательский агент <dfn id="trace-a-path">чертит <span title="concept-path">путь</span></dfn>, <!-- <dfn>trace a path</dfn> -->
  заданный объектом <var data-anolis-xref="">style</var>, который реализует интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>, он должен выполнить следующий алгоритм. Этот алгоритм возвращает новый <a href="#concept-path" title="concept-path">путь</a>.</p>

  <ol>

   <li><p>Сделать <var data-anolis-xref="">path</var> копией пути который чертится.</p></li>

   <!-- PATH SANITIZATION -->

   <li><p>Сократить все элементы нулевой длины строки с <var data-anolis-xref="">path</var>.</p></li>

   <li><p>Удалить с <var data-anolis-xref="">path</var> любые подпути без линий (т.е. подпути только с одной точкой).</p></li>

   <li><p>Заменить каждую точку в каждом подпути <var data-anolis-xref="">path</var>, кроме первой и последней точки каждого подпути с помощью <i>join</i>, который соединяет линию ведущую к этой точке на линии ведущей из этой точки, таким образом все подпути состоят из двух точек (стартовая и конечная), одной или более линий (соединяющих точки), и ноля или более соединений (каждое соединяет одну линию с другой), соединенных друг с другом таким образом, что каждый подпуть представляет собой серию из одной или нескольких линий с соединениями между каждой из точек на каждом конце.</p></li>

   <li><p>Добавить прямую линию закрытия каждого замкнутого подпути в <var data-anolis-xref="">path</var> соединяющую последнюю точку и первую точку этого подпути; изменить последнюю точку в соединение (от предыдущей последней строки к новой добавленной закрывающей линии), и изменить первую точку в соединение (от предыдущей последней строки к новой добавленной закрывающей линии).</p>

   </li><li><p>Если <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a> пуст, перейти к шагу помеченному как <i>convert</i>.</p></li>

   <!-- DASHING -->

   <li><p>Сделать <var data-anolis-xref="">pattern width</var> суммой всех записей <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, в координатном пространстве единиц.</p>

   </li><li><p>Для каждого подпути <var data-anolis-xref="">subpath</var> в <var data-anolis-xref="">path</var>, запустить следующие подэтапы. Эти подэтапы превратятся в подпути <var data-anolis-xref="">path</var> <i>сами собой</i>.</p>

    <ol>

     <li><p>Сделать <var data-anolis-xref="">subpath width</var> длиной всех линий от <var data-anolis-xref="">subpath</var>, в координатном пространстве единиц.</p>

     </li><li><p>Сделать <var data-anolis-xref="">offset</var> значением <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>, в координатном пространстве единиц.</p></li>

     <li>

      <p>Если <var data-anolis-xref="">offset</var> больше чем <var data-anolis-xref="">pattern width</var>,
      уменьшить его до <var data-anolis-xref="">pattern width</var>.</p>

      <p>Если <var data-anolis-xref="">offset</var> меньше ноля, реализовать его с помощью <var data-anolis-xref="">pattern
      width</var>.</p>

     </li>

     <li><p>Определить <var data-anolis-xref="">L</var> линией в линейных координатах в <var data-anolis-xref="">subpath</var>, таким образом, что начало первой строки подпути определяется как координата 0, и конец последней строки в подпути определяется как координата <var data-anolis-xref="">subpath width</var>.</p></li>

     <li><p>Сделать <var data-anolis-xref="">position</var> нулем минус <var data-anolis-xref="">offset</var>.</p></li>

     <li><p>Сделать <var data-anolis-xref="">index</var> равным 0.</p></li>

     <li><p>Сделать <var data-anolis-xref="">current state</var> равным <i>off</i> (другие состояния являются <i>on</i>
     и <i>zero-on</i>).</p></li>

     <li><p><i id='step-dash-on'>Dash on</i>: Сделать <var data-anolis-xref="">segment length</var> значением стилей <var data-anolis-xref="">styles</var> списка тире <a href="#dash-list">dash
     list</a> записью номер <var data-anolis-xref="">index</var>.</p></li>

     <li><p>Увеличить <var data-anolis-xref="">position</var> на <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда закончить эти подэтапы для этих подпутей и начать их снова для следующего подпути; если больше нет подпутей, тогда перейти к шагу помеченному как <i>convert</i>.</p></li>

     <li><p>Если <var data-anolis-xref="">segment length</var> не нулевая, сделать <var data-anolis-xref="">current state</var> равной <i>on</i>.</p></li>

     <li><p>Увеличить <var data-anolis-xref="">index</var> на единицу.</p></li>

     <li><p><i>Dash off<!-- labeled for consistency only --></i>: Сделать <var data-anolis-xref="">segment
     length</var> значением <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a> <var data-anolis-xref="">index</var>-й записи.</p></li>

     <li><p>Сделать <var data-anolis-xref="">start</var> смещением <var data-anolis-xref="">position</var> на <var data-anolis-xref="">L</var>.</p></li>

     <li><p>Увеличить <var data-anolis-xref="">position</var> на <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>Если <var data-anolis-xref="">position</var> меньше ноля, тогда перейти к шагу помеченному как
     <i>post-cut</i>.</p></li> <!-- start and end both before zero -->

     <li><p>Если <var data-anolis-xref="">start</var> меньше ноля, тогда сделать <var data-anolis-xref="">start</var> равным нолю.</p></li> <!-- end will be (at or) after zero -->

     <li><p>Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда сделать <var data-anolis-xref="">end</var> смещением <var data-anolis-xref="">subpath width</var> на <var data-anolis-xref="">L</var>. В другом случае, сделать <var data-anolis-xref="">end</var> смещением <var data-anolis-xref="">position</var> на <var data-anolis-xref="">L</var>.</p></li>

     <li>

      <p>Выполнить один из следующих подэтапов, в зависимости от обстоятельств:</p>

      <dl class="switch">

       <dt>Если <var data-anolis-xref="">segment length</var>  равен нулю и <var data-anolis-xref="">current state</var> равно <i>off</i></dt>

       <dd>

        <p>Ничего не делать, перейти к следующему шагу.</p>

       </dd>


       <dt>Если <var data-anolis-xref="">current state</var> равен <i>off</i></dt>

       <dd>

        <p>Обрезать линию на которой <var data-anolis-xref="">end</var> оказывается коротким <var data-anolis-xref="">end</var> и поместить точку там, сокращая ее содержащий подпуть до двух;
        удалить все сегменты линий, соединения, точки и подпути которые между <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var>; и наконец-то разместить одну точку на <var data-anolis-xref="">start</var> без линий соединенных с ней.</p>

        <p>Точка имеет <i>направленность</i> для целей рисования шапки линии (смотрите ниже).
        Направленность является направлением, которое исходная линия имела в этой точке (т.е. когда <var data-anolis-xref="">L</var> был определен выше).</p>
       </dd>


       <dt>В другом случае</dt>

       <dd>

        <p>Обрезать линию на которой <var data-anolis-xref="">start</var> находят себя в двух на <var data-anolis-xref="">start</var> и поместить точку там, обрезать подпуть в котором их было двое, а также обрезать линию на которой <var data-anolis-xref="">end</var> оказывается коротким на <var data-anolis-xref="">end</var> и поместить точку там, обрезать подпуть <em>в котором</em> их было двое, и затем удалить все отрезки, соединения, точки и подпути которые были между <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var>.</p>

        <p>Если <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var> в одной точке, в результате линии сокращаются и две точки вставляется там без удаления чего-либо, если только соединение не происходит в этой точке, тогда соединение тоже удаляется.</p>
       </dd>

      </dl>

     </li>

     <li><p><i>Post-cut</i>: Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда перейти к шагу помеченному как <i>convert</i>.</p></li>

     <li><p>Если <var data-anolis-xref="">segment length</var> больше нуля, определить <var data-anolis-xref="">positioned-at-on-dash</var> как false.</p></li>

     <li><p>Увеличить <var data-anolis-xref="">index</var> на единицу. Если он равен количеству записей в
     <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, тогда определить <var data-anolis-xref="">index</var> как
     0.</p></li>

     <li><p>Перейти к шагу помеченному как <i><a href='#step-dash-on'>dash on</a></i>.</p></li>

    </ol>

   </li>

   <!-- STROKING -->

   <li>

    <p><i>Convert</i>: Это шаг, который преобразует путь к новому пути, который представляет свой ход.</p>

    <p>Создается новый <a href="#concept-path" title="concept-path">path</a>, который описывает края областей которые будут покрыты, если прямая линия длиной равная <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> была охвачена вдоль каждого пути в <var data-anolis-xref="">path</var> в то время как была под углом таким образом, что линия перпендикулярна к пути
    была охвачена, заменив каждую точку с end cap, необходимой для удовлетворения атрибута <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>, как описано выше и подробно рассмотрена ниже, и замена каждого соединения на соединение необходимое, чтобы удовлетворить тип <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>, как определено ниже.</p>

    <p><strong>Окончания</strong>: Каждая точка имеет плоский край, перпендикулярной к направлению линии выходящей из нее. Это их дополнение в соответствии со значением из <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>. Значение "<code>butt</code>"
    означает, что никакое дополнительное окончание не задано. Значение "<code>round</code>" означает что
    полукруг с диаметром, равным <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, ширина должна быть дополнительно размещена на линии, выходящей из каждой точки. Значение "<code>square</code>" означает что прямоугольник с длинной с <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> и шириной половины <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, поверхностью плотно прилегает к краю, перпендикулярной к направлению линии, выходящей из точки, должен быть добавлен в каждой точке.</p>

    <p>Точки без линий выходящих из них должны иметь два окончания расположенные спина-к-спине как если бы это были две точки соединенные друг с другом бесконечно короткой прямой линией.</p>

    <p><strong>Соединения</strong>: В дополнение к точке где происходит соединение, две дополнительные точки
    присоединяются к каждой, одна для каждой линии: одна перпендикулярная для каждой линии, линия на каждой стороне наиболее удаленной от другой линии.</p>

    <p>Значение "<code>bevel</code>" означает что это всё что отображено в соединениях.</p>

    <p>Значение "<code>round</code>" означает, что заполненная дуга, соединяющая два вышеупомянутых угла соединения, примыкает (а не перекрывает) к вышеупомянутому треугольнику, с диаметром, равным ширине линии и началом координат в точке соединения, должна быть добавлена в соединения.</p>

    <p>Значение "<code>miter</code>" означает что второй заполненный треугольник должен (если он может с учетом длины скоса) быть добавлен в соединение, с одной линией, будучи линией между двумя вышеупомянутыми углами.</p>

<!-- the actual ratio can't possibly be less than 1.0 -->

<div class="example">
<br>
<p>Ниже неплохой пример miter:</p>
<pre>
  c.clearRect(0, 0, 640, 480);
  c.beginPath();

  c.moveTo((new Date()/100) % 600, 100);
  c.lineTo(300, 300);
  c.lineTo(500, 300);

  c.lineWidth = 50;
  c.miterLimit = 10000;
  c.strokeStyle = 'silver'
  c.stroke();

  c.miterLimit = 0.0001;
  c.strokeStyle = 'black'
  c.stroke();

  c.lineWidth = 1;
  c.strokeStyle = 'red'
  c.stroke();
</pre>
</div>


    <p>Подпути во созданном пути должны проходить по часовой стрелке, независимо от направления путей в <var data-anolis-xref="">path</var>.</p>

    <!-- ...because both of these examples result in two lines (assuming non-zero winding rules,
    things are different under even/odd), there's no "hole" where the lines overlap:

            c.beginPath();
            c.lineWidth=30;
            c.moveTo(200,200); // subpath 1
            c.lineTo(400,200);
            c.moveTo(400,210); // subpath 2
            c.lineTo(200,190);
            c.stroke();

            c.beginPath();
            c.lineWidth=30;
            c.moveTo(200,200); // subpath 1
            c.lineTo(400,200);
            c.lineTo(300,300);
            c.closePath();
            c.moveTo(400,210); // subpath 2
            c.lineTo(200,190);
            c.lineTo(300,300);
            c.closePath();
            c.stroke();

     ...and we want the same result when you create the two subpaths in each example above as two
     Paths, stroke them onto a third Path, and then fill that Path on the context.
    -->

   </li>

   <li><p>Вернуть созданный путь.</p></li>

  </ol>

<!--v6: Another request has been for hairline width lines, that remain hairline width with
transform. ack Shaun Morris. -->


  </div>


  <h2 id="text-styles"><span class="secno">4 </span>Стили текста</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие настройки шрифта.</p>

    <p>Может быть настроен, чтобы изменить шрифт. Синтаксис тот же как и для свойства 'font' в CSS; значения которые не могут прочитаться как значения шрифта в CSS, игнорируются.</p>

    <p>Относящиеся ключевые слова и размеры вычисляются относящимися к шрифту элемента <code>canvas</code>.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие параметры выравнивания текста.</p>

    <p>Может быть настроен, чтобы изменить выравнивание. Возможные значения:
    "<code>start</code>", "<code>end</code>", "<code>left</code>", "<code>right</code>", и "<code>center</code>". Другие значения игнорируются. По умолчанию:
    "<code>start</code>".</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие настройки выравнивания базовой линии.</p>

    <p>Может быть настроен, чтобы изменить выравнивание базовой линии. Возможные значения и что они означают - написано ниже. Другие значения игнорируются. По умолчанию: "<code>alphabetic</code>".</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-context-2d-font" title="dom-context-2d-font"><code>font</code></dfn> IDL, при настройке, должен читаться тем же образом что и свойство 'font'
  в CSS (но без поддержки синтаксиса независимых свойств стилей типа 'inherit'), и полученный шрифт должен быть назначен к контексту, с компонентом 'line-height' принужденным к
  'normal', с компонентом 'font-size' конвертированным в пиксели CSS,
  и с системными шрифтами вычисляемыми до явных значений. Если новое значение синтаксически некорректно (включая использование синтаксиса
  независимых свойств стилей типа 'inherit' или
  'initial'), они должны быть игнорированы, без назначения нового значения шрифта. <a href="#refsCSS">[CSS]</a></p>

  <p>Имена шрифтов должны интерпретироваться в контексте <span>font
  style source node</span> таблицы стилей, когда шрифт будет использовать <code>@font-face</code>, поэтому таким образом шрифты должны быть доступны после того как однажды загружены. (Если отсылка к шрифту используется раньше чем он полностью загрузился, либо если <span>font style source node</span> не имеет данного шрифта, то он должен рассматриваться как если бы это был неизвестный шрифт, как это описано в соответствующих спецификациях CSS.) <a href="#refsCSSFONTS">[CSSFONTS]</a></p>

  <p>Только векторные шрифты должны использоваться агентом пользователя; если бы пользовательский агент использовал растровые шрифты, после преобразования, скорее всего, шрифты выглядели бы очень некрасиво.</p>

  <p>При получении, атрибут <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>
  должен возвращать <span title="serializing a CSS
  value">последовательную форму</span> текущего шрифта контекста
  (без компонента 'line-height'). <a href="#refsCSSOM">[CSSOM]</a></p>

  <div class="example">

   <p>Например, после следующего утверждения:</p>

   <pre>context.font = 'italic 400 12px/2 Unknown Font, sans-serif';</pre>

   <p>...выражение <code>context.font</code> будет оценивать строку "<code>italic 12px "Unknown Font", sans-serif</code>". Значение
   "400" font-weight не появляется, потому что это значение по умолчанию. Высота линии не появляется, потому что она приравнивается к "normal" по умолчанию.</p>

  </div>

  <p>Когда контекст создается, шрифт контекста должен быть установлен в 10px
  sans-serif. Когда компонент 'font-size' установлен в длину с помощью процентов, 'em' или 'ex' единицами, или ключевыми словами 'larger' / 'smaller', они должны быть интерпретированы по отношению к расчетному значению свойства 'font-size' от <span>font style source
  node</span> в то время как атрибут установлен, если это элемент. Когда компонент 'font-weight' установлен на относительные значение 'bolder' и 'lighter', они должны быть интерпретированы по отношению к вычисленному значению значению свойства 'font-weight' от <span>font
  style source node</span> в то время как атрибут установлен, если это элемент. Если вычисленные значения не определены для конкретного случая (например потому что <span>font style source
  node</span> не элемент или он не <span>в
  <code>Документе</code></span>), тогда относящиеся ключевые слова должны быть интерпретированы по отношению к normal-weight 10px sans-serif
  по умолчанию.</p>

  <p>Атрибут IDL <dfn id="dom-context-2d-textalign" title="dom-context-2d-textAlign"><code>textAlign</code></dfn>, при получении, должен возвращать текущее значение. При настройке, если значение одно из "<code>start</code>", "<code>end</code>", "<code>left</code>", "<code>right</code>", или "<code>center</code>", то значение должно быть изменено на новое значение. В другом случае, новое значение должно быть проигнорировано. Когда контекст создан, атрибут <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> должен изначально иметь значение "<code>start</code>".</p>

  <p>Атрибут IDL <dfn id="dom-context-2d-textbaseline" title="dom-context-2d-textBaseline"><code>textBaseline</code></dfn>, при получении, должен возвращать текущее значение. При настройке, если значение одно из "<code title="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code>", "<code title="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code>", "<code title="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code>", "<code title="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code>",
  "<code title="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code>",
  или "<code title="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code>",
  то значение должно быть изменено на новое значение. В другом случае, новое значение должно быть проигнорировано. Когда объект реализующий интерфейс
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> создан, атрибут <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> должен изначально иметь значение "<code>alphabetic</code>".</p>

  </div>

  <p>Атрибут <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>
  дает ключевым словам соответствие точкам выравнивания шрифта:</p>

  <!-- this is filler to make sure the TCP packet boundary doesn't fall in the middle of one of the NCRs below -->
  <!-- (because otherwise the parser in anolis screws it up) -->
  <p><img alt="The top of the em square is roughly at the top of the glyphs in a font, the hanging baseline is where some glyphs like आ are anchored, the middle is half-way between the top of the em square and the bottom of the em square, the alphabetic baseline is where characters like Á, ÿ, f, and Ω are anchored, the ideographic baseline is where glyphs like 私 and 達 are anchored, and the bottom of the em square is roughly at the bottom of the glyphs in a font. The top and bottom of the bounding box can be far from these baselines, due to glyphs extending far outside the em square." height="300" src="./baselines.png" width="738"></p>

  <p>Ключевые слова карты по этим точкам выравнивания следующие:</p>

  <dl>

   <dt><dfn id="dom-context-2d-textbaseline-top" title="dom-context-2d-textBaseline-top"><code>top</code></dfn>
   </dt><dd>Верх от em square</dd>

   <dt><dfn id="dom-context-2d-textbaseline-hanging" title="dom-context-2d-textBaseline-hanging"><code>hanging</code></dfn>
   </dt><dd>Висящий на baseline</dd>

   <dt><dfn id="dom-context-2d-textbaseline-middle" title="dom-context-2d-textBaseline-middle"><code>middle</code></dfn>
   </dt><dd>Середина от em square</dd>

   <dt><dfn id="dom-context-2d-textbaseline-alphabetic" title="dom-context-2d-textBaseline-alphabetic"><code>alphabetic</code></dfn>
   </dt><dd>Базовая линия alphabetic</dd>

   <dt><dfn id="dom-context-2d-textbaseline-ideographic" title="dom-context-2d-textBaseline-ideographic"><code>ideographic</code></dfn>
   </dt><dd>Базовая линия ideographic</dd>

   <dt><dfn id="dom-context-2d-textbaseline-bottom" title="dom-context-2d-textBaseline-bottom"><code>bottom</code></dfn>
   </dt><dd>Низ от em square</dd>

  </dl>

  <p><dfn id="text-preparation-algorithm">Алгоритм подготовки текста</dfn> выглядит следующим образом. Он принимает в качестве входной строки <var>text</var>, объект
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> <var>target</var>,
  и опционально длину <var>maxWidth</var>. Он возвращает массив форм глифов, каждый из которых расположен на общем координатном пространстве,
  и <var>physical alignment</var> который имеет значение из:
  <i>left</i>, <i>right</i> и <i title="">center</i>. (Большинство вызывающих этот алгоритм игнорируют <var>physical alignment</var>.)</p>

  <ol>

   <li><p>Если <var>maxWidth</var> был предоставлен, но равен нулю или меньше него, возвращается пустой массив.</p></li>

   <li><p>Заменить все <span title="space character">символы пробела</span> в <var>text</var> на U+0020 символы.</p></li>

   <li><p>Сделать <var>font</var> текущим шрифтом <var>target</var>, как дано для объекта атрибута <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>.</p></li>

   <li>

    <p>Применить соответствующий пункт из следующего списка, чтобы определить значение <var>direction</var>:</p>

    <dl class="switch">

     <dt>Если <var>target</var> объекта <span>font style
     source node</span> является элементом</dt>

     <dd>Сделать <var>direction</var> <span>направленным</span> от <var>target</var> объекта
     <span>font style source node</span>.</dd>

     <dt>Если <var>target</var> объекта <span>font style
     source node</span> является <code>Document</code> и этот
     <code>Документ</code> является корневым элементом вложенного</dt>

     <dd>Сделать <var>direction</var> <span>направленным</span> от вложенного корневого элемента <var>target</var> объекта
     <span>font style source node</span>.</dd>

     <dt>Если <var>target</var> объект <span>font style
     source node</span> является <code>Document</code> и этот
     <code>Документ</code> не имеет вложенного элемента корневого</dt>

     <dd>Сделать <var>direction</var> '<span title="concept-ltr">ltr</span>'.</dd>

    </dl>

   </li>

   <li><p>Форма гипотетического бесконечно широкого CSS лайн-бокса, содержащая единственный инлайн-блок, содержащий текст <var>text</var>,
   со всеми свойствами в их изначальных значениях кроме свойства 'font',
   в инлайн-боксе устанавливается <var>font</var>, свойство
   'direction' инлайн-бокса устанавливается <var>direction</var>, и свойство 'white-space' устанавливается к
   'pre'. <a href="#refsCSS">[CSS]</a></p></li>

   <!-- if you insert a step here, make sure to adjust the next step's
   final words -->

   <li><p>Если <var>maxWidth</var> предоставлено и гипотетическая ширина инлайн-бокса в гипотетическом лайн-боксе больше чем <var>maxWidth</var> CSS пикселей, тогда изменить <var>font</var> чтобы иметь более обобщенный шрифт (если он доступен или достаточно читаемый, можно синтезировать с помощью горизонтального коэффициента для шрифта) или меньший шрифт, и вернуться к предыдущему шагу.</p></li>

   <li>

    <p><var>anchor point</var> является точкой на инлайн-боксе, а <var>physical alignment</var> является одним из значений <i>left</i>, <i>right</i>, and <i title="">center</i>. Эти вариации значений <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> и <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> определяются как следующие:</p>

    <p>Горизонтальная позиция:</p>

    <dl>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>left</code></dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>start</code> и <var>direction</var> равняется
     'ltr'</dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>end</code> и <var>direction</var> равняется
     'rtl'</dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> левым краем от инлайн-бокса, и сделать <var>physical alignment</var> равным <i>left</i>.</dd>


     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>right</code></dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>end</code> и <var>direction</var> равняется
     'ltr'</dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>start</code> и <var>direction</var> равняется
     'rtl'</dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> правым краем инлайн-бокса, и сделать <var>physical alignment</var> равным <i>right</i>.</dd>


     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>center</code></dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> ровно посередине между левым и правым краями инлайн-бокса, и сделать <var>physical alignment</var> равной
     <i title="">center</i>.</dd>

    </dl>

    <p>Вертикальная позиция:</p>

    <dl>

     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> верхом от em box первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var>
     висящей на baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> ровно посередине верха и низа от em box первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> the alphabetic baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> ideographic baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var>низом от em box первого доступного шрифта в инлайн-боксе.</dd>

    </dl>

   </li>

   <li>

    <p>Сделать <var>result</var> массивом построенным перебиранием каждого глифа в инлайн-боксе от левого до правого (если есть), добавить в массив, для каждого глифа, форму глифа как в инлайн-боксе, расположенную в координатном пространстве с помощью
    CSS пикселей с его началом в <var>anchor
    point</var>.</p>

   </li>

   <li><p>Возвратить <var>result</var> и, для тех кто вызывает его, <var>physical alignment</var> как значение выравнивания.</p></li>

  </ol>


  <h2 id="building-paths"><span class="secno">5 </span>Построение пути</h2>

  <p>Каждый объект реализующий интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>
  имеет <a href="#concept-path" title="concept-path">путь</a> (path). <dfn id="concept-path" title="concept-path">Путь</dfn> имеет список из нуля или больше подпутей.
  Каждый подпуть содержит список из одной или более точек, соединенных прямыми или изогнутыми линиями, и флаг-индикатор является ли подпуть закрытым или нет. Закрытый путь это когда последняя точка подпути соединена с первой точкой подпути прямой линией. Подпути с меньше чем двумя точками игнорируются при рисовании пути.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>
  создан, его <a href="#concept-path" title="concept-path">path</a>
  должен быть инициализирован в ноль подпутей.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Создает новый подпуть с заданной точкой.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-closePath"><a href="#dom-context-2d-closepath">closePath</a></code>()</dt>

   <dd>

    <p>Помечает текущий подпуть как закрытый, и начинает новый подпуть с той же точки что начало и конец только что закрытого подпути.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineTo"><a href="#dom-context-2d-lineto">lineTo</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, соединенную с предыдущей прямой линией.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-quadraticCurveTo"><a href="#dom-context-2d-quadraticcurveto">quadraticCurveTo</a></code>(<var>cpx</var>, <var>cpy</var>, <var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, с помощью одной квадратичной кривой Безье с заданной контрольной точкой.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-bezierCurveTo"><a href="#dom-context-2d-beziercurveto">bezierCurveTo</a></code>(<var>cp1x</var>, <var>cp1y</var>, <var>cp2x</var>, <var>cp2y</var>, <var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, соединенную с предыдущей с помощью кубической кривой Безье с заданными контрольными точками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-arcTo"><a href="#dom-context-2d-arcto">arcTo</a></code>(<var>x1</var>, <var>y1</var>, <var>x2</var>, <var>y2</var>, <var>radius</var>)</dt>

   <dd>

    <p>Добавляет дугу с заданными контрольными точками и радиусом к текущему подпути, соединенную с прошлой точкой прямой линией.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если заданный радиус является отрицательным.</p>

    <figure class="diagrams">
     <!-- if anyone wants to try writing alternative text for this, be my guest. I can't work out how to describe it. -->
     <img alt="" src="./arc1.png">
    </figure>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc</a></code>(<var>x</var>, <var>y</var>, <var>radius</var>, <var>startAngle</var>, <var>endAngle</var> [, <var>counterclockwise</var> ] )</dt>

   <dd>

    <p>Добавляет точки в подпуть таким образом что дуга описана окружностями круга описанного аргументами, начиная с заданного стартового угла и заканчивая на заданном конечном угле, идущего в заданном направлении (по умолчанию по часовой стрелке), добавленному в пути, соединенному с предыдущей точкой прямой линией.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если заданный радиус является отрицательным.</p>

<!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  var x0 = 50;
  var y0 = 200;
  var x = 255;
  var y = 150;
  var radius = 100;
  var startAngle = 2.4
  var endAngle = 0.7;
  var direction = false;

  var bottom = 280;
  var center = 50;

  var fontSize = 16;
  var margin = 50;
  var dotHalfSize = 5;
  var arrowHead = 5;

  // (also update the label positions at the bottom)

  // ========

  function dot(x,y,s) {
    c.beginPath();
    c.arc(x,y,dotHalfSize,0,Math.PI*2);
    c.fill();
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillText(s,x,y+dotHalfSize);
  }

  function arc(x, y, r, sA, eA, d, fr, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'red';
    c.beginPath();
    c.arc(x, y, r, sA, eA, d);
    c.stroke();

    c.save();
    c.translate(x, y);
    c.rotate(eA);
    c.beginPath();
    c.moveTo(r-arrowHead, arrowHead);
    c.lineTo(r, 0);
    c.lineTo(r+arrowHead, arrowHead);
    c.stroke();

    c.strokeStyle = 'silver';
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(fr, 0);
    c.stroke();
    c.restore();

    c.textAlign = 'right';
    c.textBaseline = 'middle';
    c.fillStyle = 'black';
    c.fillText(s + ' ',x-r,y);
  }

  function radial(x, y, length, rotation, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'blue';
    c.save();
    c.translate(x, y);
    c.rotate(rotation);
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(length, 0);
    c.stroke();
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillStyle = 'black';
    c.fillText(s,length/2,0);
    c.restore();
  }

  c.font = fontSize + 'px Gill Sans';

  // construction lines
  c.lineWidth = 1;
  c.strokeStyle = 'silver';
  // circle
  c.beginPath();
  c.arc(x, y, radius, 0, 2*Math.PI);
  c.stroke();
  // angles
  arc(x, y, 2*radius/3, 0, startAngle, true, radius, '\u03B1');
  arc(x, y, radius/3, 0, endAngle, true, radius, '\u03B2');
  // radii
  radial(x, y, radius, 0, 'radius');

  // the line
  c.lineWidth = 15;
  c.lineCap = 'round';
  c.strokeStyle = 'rgba(20,200,40,0.8)';
  c.beginPath();
  c.moveTo(x0,y0);
  c.arc(x,y,radius,startAngle,endAngle,direction);
  c.stroke();

  dot(x0,y0, "x\u2080,y\u2080");
  dot(x,y, "x,y");

  c.textAlign = 'left';
  c.textBaseline = 'alphabetic';
  var L = 0;

  function print(s) {
    c.fillText(s, center, bottom+L*fontSize*1.3);
    L += 1;
  }
  print('// the thick line corresponds to:');
  print('context.moveTo(x\u2080, y\u2080)');
  print('context.arc(x, y, radius, \u03B1, \u03B2)');
  print('context.stroke()');

  c.fillStyle = 'green';
  c.fillText("\u25be initial line", x0, y0-fontSize);
  c.textAlign = 'center';
  c.fillText("\u25be arc", x, y-radius-fontSize);

} finally {
  c.restore();
}
-->

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-rect"><a href="#dom-context-2d-rect">rect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Добавляет новый закрытый подпуть в путь, представляющий заданный прямоугольник.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Следующие методы позволяют авторам манипулировать <a href="#concept-path" title="concept-path">путями</a> объектов, реализующих интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>.</p>

  <p>Для объектов <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>, точки и линии добавленные к <a href="#current-default-path">current default path</a> с помощью этих методов должны быть преобразованы в соответствии с <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей трансформации</a> перед тем как быть добавлены к пути.</p>


  <p>Метод <dfn id="dom-context-2d-moveto" title="dom-context-2d-moveTo"><code>moveTo(<var>x</var>, <var>y</var>)</code></dfn> должен создать новый подпуть с заданной точкой в качестве первой (и единственной) точки.</p>

  <p>Когда пользовательский агент должен <dfn id="ensure-there-is-a-subpath">обеспечить там подпуть</dfn> для координат (<var>x</var>, <var>y</var>) на
  <a href="#concept-path" title="concept-path">path</a>, агент пользователя должен проверить, чтобы убедиться, что <a href="#concept-path" title="concept-path">path</a> имеет любые подпути,
  и если нет, пользовательский агент должен создать новый подпуть с точкой (<var>x</var>, <var>y</var>) как его первой (и единственной) точкой, как если метод <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code> был вызван.</p>


  <p>Метод <dfn id="dom-context-2d-closepath" title="dom-context-2d-closePath"><code>closePath()</code></dfn>
  не должен ничего делать если путь объекта не имеет подпутей.
  В другом случае, он должен пометить последний подпуть как закрытый, создать новый подпуть первая точка которого та же что и первая точка предыдущего подпути, и наконец добавить этот подпуть к path.</p>

  <p class="note">Если последний подпуть имел больше чем одну точку в своем списке точек, то это эквивалентно добавлению прямой линии, соединяющей последнюю точку с первой точкой, таким образом "закрывает" форму, и потом повторяет последний (возможно подразумеваемый) вызов <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code>.</p>


  <p>Новые точки и линии соединяющие их добавлены в подпути, с помощью методов описанных ниже. Во всех случаях, методы изменяют только последний подпуть в пути объекта.</p>


  <p>Метод <dfn id="dom-context-2d-lineto" title="dom-context-2d-lineTo"><code>lineTo(<var>x</var>, <var>y</var>)</code></dfn> должен
  <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>x</var>, <var>y</var>)</span> если путь объекта не имеет подпутей. В другом случае, он должен соединить последнюю точку в подпути с заданной точкой (<var>x</var>, <var>y</var>) используя прямую линию, и должен затем добавить заданную точку (<var>x</var>, <var>y</var>) в подпуть.</p>


  <p>Метод <dfn id="dom-context-2d-quadraticcurveto" title="dom-context-2d-quadraticCurveTo"><code>quadraticCurveTo(<var>cpx</var>, <var>cpy</var>, <var>x</var>,
  <var>y</var>)</code></dfn> должен <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>cpx</var>,
  <var>cpy</var>)</span>, и затем должен соединить последнюю точку в подпути с заданной точной (<var>x</var>, <var>y</var>) используя квадратичную кривую Безье с контрольной точкой (<var>cpx</var>, <var>cpy</var>), и должен затем добавить заданную точку (<var>x</var>, <var>y</var>) в подпуть. <a href="#refsBEZIER">[BEZIER]</a></p>


  <p>Метод <dfn id="dom-context-2d-beziercurveto" title="dom-context-2d-bezierCurveTo"><code>bezierCurveTo(<var>cp1x</var>, <var>cp1y</var>, <var>cp2x</var>, <var>cp2y</var>, <var>x</var>, <var>y</var>)</code></dfn> должен
  <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>cp1x</var>, <var>cp1y</var>)</span>, и затем должен соединить последнюю точку в подпути с заданной точкой (<var>x</var>, <var>y</var>) используя кубическую кривую Безье с контрольными точками (<var>cp1x</var>, <var>cp1y</var>) и (<var>cp2x</var>, <var>cp2y</var>). Затем, он должен добавить точку (<var>x</var>, <var>y</var>) в подпуть. <a href="#refsBEZIER">[BEZIER]</a></p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-arcto" title="dom-context-2d-arcTo"><code>arcTo(<var>x1</var>, <var>y1</var>, <var>x2</var>,
  <var>y2</var>, <var>radius</var>)</code></dfn>
  должен сначала <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>x1</var>, <var>y1</var>)</span>.
  Затем поведение основывается на аргументах и последней точке подпути, как указано ниже.</p>

  <p>Отрицательные значения для <var>radius</var> должны вызвать показ <code>IndexSizeError</code> исключения.

  </p><p>Сделать точку (<var>x0</var>, <var>y0</var>) последней точкой в подпути.</p>

  <p>Если точка (<var>x0</var>, <var>y0</var>) равняется точке (<var>x1</var>, <var>y1</var>)
  или если точка (<var>x1</var>, <var>y1</var>) равняется точке (<var>x2</var>, <var>y2</var>),
  или если радиус <var>radius</var> равен нолю, тогда метод должен добавить точку (<var>x1</var>, <var>y1</var>)
  в подпуть и соединить эту точку с предыдущей точкой (<var>x0</var>, <var>y0</var>) прямой линией.</p>

  <p>В другом случае, если точки (<var>x0</var>, <var>y0</var>), (<var>x1</var>, <var>y1</var>), и (<var>x2</var>, <var>y2</var>) все лежат на одной прямой линии, метод должен добавить точку (<var>x1</var>, <var>y1</var>) в подпуть и соединить эту точку с предыдущей точкой (<var>x0</var>, <var>y0</var>) прямой линией.</p>

  <p>В другом случае, сделать <var>The Arc</var> самой короткой дугой
  заданной окружностью имеющей радиус <var>radius</var> и которая имеет одну точку касательной к полубесконечной линии, которая пересекает точку (<var>x0</var>, <var>y0</var>) и заканчивает в точке (<var>x1</var>,
  <var>y1</var>), и которая имеет другую точку касательную к полубесконечной линии, которая заканчивается в точке (<var>x1</var>, <var>y1</var>), и пересекает точку
  (<var>x2</var>, <var>y2</var>). В точках, в которых этот круг прикасается, эти две называются началом и концом точки касания соответственно. Метод должен соединять точку
  (<var>x0</var>, <var>y0</var>) с точкой касательной старта по прямой линии, добавляя начальную касательную точку в подпуть, затем должен соединить начальную касательную линию с конечной касательной линией к <var>The Arc</var>, добавляя конечную касательную точку в подпуть.</p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-arc" title="dom-context-2d-arc"><code>arc(<var>x</var>, <var>y</var>, <var>radius</var>,
  <var>startAngle</var>, <var>endAngle</var>, <var>counterclockwise</var>)</code></dfn> рисует дугу.</p>

  <p> Если контекст имеет какие-либо подпути, то этот метод должен добавить прямую линию от последней точки в подпути к начальной точке дуги.
  В любом случае, он должен нарисовать дугу между начальной точкой дуги и конечной точкой дуги, и добавить эти точки в подпуть. Дуга и ее начальная/конечная точки определяются как следующие:</p>

  <p>Рассмотрим круг, который имеет свое происхождение в (<var>x</var>, <var>y</var>)
  и его радиус <var>radius</var>.
  Точки в <var>startAngle</var> и <var>endAngle</var> окружности этого круга, измеренные в радианах по часовой стрелке от положительной оси х, являются начальной и конечной точкой соответственно.</p>

  <p>Если аргумент <var>counterclockwise</var> ложный и <span><var>endAngle</var>-<var>startAngle</var></span> равняются или более чем <span>2π</span>, или если аргумент <var>counterclockwise</var>
  является <em>true</em> и <span><var>startAngle</var>-<var>endAngle</var></span> равняются или более чем <span>2π</span>, то дуга это вся окружность этого круга.</p>

  <p>В другом случае, дуга это путь по окружности круга от начальной до конечной точки, идущая против часовой стрелки если аргумент <var>counterclockwise</var> равен true, и по часовой стрелке если нет. Так как точки на окружности, а не просто углы от нуля, дуга никогда не может покрыть угол больше чем <span>2π</span> радиус. Если две точки одинаковы или радиус равен нулю, то дуга определяется нулевой длины в обоих направлениях.</p>

  <p>Негативные значение для <var>radius</var> должны вызывать показ
  <code>IndexSizeError</code> исключения.</p>

  <hr>



  <p>Метод <dfn id="dom-context-2d-rect" title="dom-context-2d-rect"><code>rect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен создавать новый подпуть
  содержащий только 4 точки (<var>x</var>, <var>y</var>), (<var>x</var>+<var>w</var>,
  <var>y</var>), (<var>x</var>+<var>w</var>, <var>y</var>+<var>h</var>),
  (<var>x</var>, <var>y</var>+<var>h</var>), с этими четырьмя точками соединенными прямыми линиями, и затем должен пометить подпуть закрытым. Затем он должен создать новый подпуть с точкой (<var>x</var>, <var>y</var>) как единственной.</p>


  <!-- v6 feature request:
        * points as a primitive shape
          http://home.comcast.net/~urbanjost/canvas/vogle4.html
  -->

  </div>


  <h2 id="transformations"><span class="secno">6 </span><dfn title="dom-context-2d-transformation">Преобразования</dfn></h2>

  <p>Каждый объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> имеет
  <i>текущую матрицу преобразования</i>, как и методы (описанные в этом разделе) для управления им. Когда объект
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> создан, его матрица преобразования должна быть инициализирована к идентичности преобразования.</p>

  <p>Матрица преобразования применяется к координатам при создании текущего пути и когда рисуется текст,
  формы, пути на объектах
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>.</p> <!-- conformance
  criteria for actual drawing are described in the various sections
  below -->

  <p class="note">Большая часть API использует объекты <code>SVGMatrix</code>, а не этого API. Этот API остается в основном по историческим причинам.</p>

  <div class="impl">

  <p>Преобразования должны быть выполнены в обратном порядке.</p>

  <p class="note">Например, если преобразование масштабированием, которое удваивает ширину, идет перед преобразованием поворотом, при рисовании прямоугольника ширина которого в два раза меньше высоты, фактически выйдет квадрат.</p> <!-- q.v.
  http://goo.gl/5RLrN -->

  </div>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-scale"><a href="#dom-context-2d-scale">scale</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование масштабированием с заданными характеристиками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-rotate"><a href="#dom-context-2d-rotate">rotate</a></code>(<var>angle</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование поворотом с заданными характеристиками. Угол в радианах.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-translate"><a href="#dom-context-2d-translate">translate</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование перемещения с заданными характеристиками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-transform"><a href="#dom-context-2d-transform">transform</a></code>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить матрицу с заданными аргументами, как описано ниже.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-setTransform"><a href="#dom-context-2d-settransform">setTransform</a></code>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования <em>на</em> матрицу с заданными аргументами, как описано ниже.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-scale" title="dom-context-2d-scale"><code>scale(<var>x</var>, <var>y</var>)</code></dfn> должен добавить масштабирующее преобразование, описанное аргументами в матрице преобразования. Аргумент <var>x</var> представляет собой масштабный коэффициент в горизонтальном направлении, и аргумент <var>y</var> представляет собой масштабный коэффициент в вертикальном направлении. Факторы являются кратными.</p>

  <p>Метод <dfn id="dom-context-2d-rotate" title="dom-context-2d-rotate"><code>rotate(<var>angle</var>)</code></dfn> должен добавить поворотное преобразование, описанное аргументами в матрице преобразования. Аргумент <var>angle</var> представляет собой
  угол поворота по часовой стрелке выраженный в радианах.</p>

  <p>Метод <dfn id="dom-context-2d-translate" title="dom-context-2d-translate"><code>translate(<var>x</var>, <var>y</var>)</code></dfn> должен добавить преобразование перемещения, описанное аргументами в матрице преобразования. Аргумент <var>x</var> представляет собой
  дистанцию перемещения в горизонтальном направлении, и аргумент <var>y</var> представляет собой дистанцию перемещения в вертикальном направлении. Аргументы в координатном пространстве единиц.</p>

  <p>Метод <dfn id="dom-context-2d-transform" title="dom-context-2d-transform"><code>transform(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</code></dfn> должен заместить текущую матрицу преобразования результатом умножения текущей матрицы и матрицы описанной с помощью:</p>

  </div>

  <table class="matrix">
   <tbody><tr>
    <td><var>a</var></td>
    <td><var>c</var></td>
    <td><var>e</var></td>
   </tr>
   <tr>
    <td><var>b</var></td>
    <td><var>d</var></td>
    <td><var>f</var></td>
   </tr>
   <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
   </tr>
  </tbody></table>

  <p class="note">Аргументы <var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, и <var>f</var> иногда называются
  <var>m11</var>, <var>m12</var>, <var>m21</var>, <var>m22</var>, <var>dx</var>,
  и <var>dy</var> или <var>m11</var>, <var>m21</var>, <var>m12</var>, <var>m22</var>, <var>dx</var>, и <var>dy</var>. Следует проявлять осторожность, в частности, с порядком второго и третьего аргументов (<var>b</var> and <var>c</var>), поскольку их порядок варьируется от API к API и они иногда используют обозначения <var>m12</var>/<var>m21</var> и иногда <var>m21</var>/<var>m12</var> для этих позиций.</p>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-settransform" title="dom-context-2d-setTransform"><code>setTransform(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>,
  <var>f</var>)</code></dfn> должен сбросить текущее преобразование к единичной матрице, затем вызвать метод <code><a href="#dom-context-2d-transform" title="dom-context-2d-transform">transform</a>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>,
  <var>f</var>)</code> с теми же аргументами.</p>

  </div>

  <h2 id="image-sources-for-2d-rendering-contexts"><span class="secno">7 </span>Источники изображений для 2D рендеринга</h2>

<p>Этот объединенный тип позволяет объектам реализовать любой из следующих интерфейсов как источник изображения:</p>

  <ul><li><code id="image-sources-for-2d-rendering-contexts:htmlimageelement"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-img-element"><a href="http://www.w3.org/TR/html/embedded-content-0.html#the-img-element">img</a></code> элементы)</li><li><code id="image-sources-for-2d-rendering-contexts:htmlvideoelement"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-video-element"><a href="http://www.w3.org/TR/html/embedded-content-0.html#the-video-element">video</a></code> элементы)</li><li><code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-canvas-element"><a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">canvas</a></code> элементы)</li></ul>

  <p>Когда агент пользователя должен <dfn id="check-the-usability-of-the-image-argument">проверить пригодность аргумента <var>image</var></dfn>, где <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-2"><a href="#canvasimagesource">CanvasImageSource</a></code>, агент пользователя должен следовать следующим шагам, которые возвращают <i>good</i>, <i>bad</i> или
  <i>aborted</i>:</p>

  <ol><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-2"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> в <a href="http://www.w3.org/TR/html/embedded-content-0.html#img-error" id="image-sources-for-2d-rendering-contexts:img-error">битом</a> состоянии, тогда показать
   <code id="image-sources-for-2d-rendering-contexts:invalidstateerror"><a href="http://www.w3.org/TR/WebIDL-1/#invalidstateerror">InvalidStateError</a></code> исключение, возвратить <i>aborted</i> и прервать эти шаги.</p>

   </li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-3"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> который не <a href="http://www.w3.org/TR/html/embedded-content-0.html#img-good" id="image-sources-for-2d-rendering-contexts:img-good">полностью декодируемый</a> или если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-2"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> который <code id="image-sources-for-2d-rendering-contexts:dom-media-readystate"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-readystate">readyState</a></code> атрибут либо <code id="image-sources-for-2d-rendering-contexts:dom-media-have_nothing"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-have_nothing">ничего не содержит</a></code> или <code id="image-sources-for-2d-rendering-contexts:dom-media-have_metadata"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-have_metadata">имеет метаданные</a></code>, тогда возвратить <i>bad</i> и прервать эти шаги.</p></li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-4"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> с
   шириной или высотой (или обоими) равными нулю, тогда возвратить <i>bad</i> и прервать эти шаги.</p>

   </li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-2"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> с горизонтальной или вертикальной размерностью равными нулю, тогда возвратить <i>bad</i> и прервать эти шаги.</p>

   </li><li><p>Возвратить <i>good</i>.</p></li></ol>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-3"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-5"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code>, изображение элемента должно использоваться как исходное изображение.</p>

  <p>В частности, когда обект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-4"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой анимированное изображение в
  <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-6"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code>, агент пользователя должен использовать дефолтное изображение анимации (то которое формат определяет быть использованным когда анимация не поддерживается или отключена), или если там нет такого изображения, первый кадр анимации при визуализации изображения для
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-3"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API.</p>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-5"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-3"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code>, тогда кадр в <a id="image-sources-for-2d-rendering-contexts:current-playback-position" href="http://www.w3.org/TR/html/embedded-content-0.html#current-playback-position">текущей playback позиции</a>. Когда метод с аргументом вызваны, должно быть использовано исходное изображение при визуализации изображения для
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-4"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API, и размеры исходного изображения должны быть <a href="http://www.w3.org/TR/html/embedded-content-0.html#concept-video-intrinsic-width" id="image-sources-for-2d-rendering-contexts:concept-video-intrinsic-width">внутренней ширины</a> и <a href="http://www.w3.org/TR/html/embedded-content-0.html#concept-video-intrinsic-height" id="image-sources-for-2d-rendering-contexts:concept-video-intrinsic-height">внутренней высоты</a> от <a id="image-sources-for-2d-rendering-contexts:media-resource" href="http://www.w3.org/TR/html/embedded-content-0.html#media-resource">источника медиа</a>
  (т.е. после того как любая коррекция соотношения была применена).</p>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-6"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-3"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code>, битмап элемента должен быть использован как исходное изображение.</p>

  <p><dfn id="the-image-argument-is-not-origin-clean"><var>Аргумент image</var> не изначально чист</dfn> если это
  <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-7"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> или <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-4"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> чье <a id="image-sources-for-2d-rendering-contexts:origin-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">начало</a> не <a href="http://www.w3.org/TR/html/browsers.html#same-origin" id="image-sources-for-2d-rendering-contexts:same-origin">то же</a> как <a id="image-sources-for-2d-rendering-contexts:origin-2-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">начало</a> заданное в <a id="image-sources-for-2d-rendering-contexts:entry-settings-object" href="http://www.w3.org/TR/html/webappapis.html#entry-settings-object">объекте настройки</a>, или если это <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-4"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> битмап которого с ложным флагом <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="image-sources-for-2d-rendering-contexts:concept-canvas-origin-clean">origin-clean</a>, или если это объект
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-7"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> битмап которого с ложным флагом <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="image-sources-for-2d-rendering-contexts:concept-canvas-origin-clean-2">origin-clean</a>.</p>

  <h2 id="fill-and-stroke-styles"><span class="secno">8 </span>Стили заполнения и обводки</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль используемый для заполнения форм.</p>

    <p>Может быть установлен, чтобы изменить стиль заполнения.</p>

    <p>Стиль может быть строкой, содержащей цвет CSS, либо
    <code><a href="#canvasgradient">CanvasGradient</a></code> или объект <code><a href="#canvaspattern">CanvasPattern</a></code>. Неверные значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль используемый для сглаживания форм.</p>

    <p>Может быть установлен, чтобы изменить стиль сглаживания.</p>

    <p>Стиль может быть строкой содержащей цвет CSS, либо
    <code><a href="#canvasgradient">CanvasGradient</a></code> или объект <code><a href="#canvaspattern">CanvasPattern</a></code>. Неверные значения игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <!-- v6 feature requests:

   * Getting and setting colours by component to bypass the CSS value parsing.

     Either:
        context.fillStyle.red += 1;

     Or:
        var array = context.fillStyle;
        array[1] += 1;
        context.fillStyle = array;

   * A more performant way of setting colours in general, e.g.:

       context.setFillColor(r,g,b,a) // already supported by webkit

     Or:

       context.fillStyle = 0xRRGGBBAA; // set a 32bit int directly

   * fill rule for deciding between winding and even-odd algorithms.
     SVG has fill-rule: nonzero | evenodd
       http://www.w3.org/TR/SVG/painting.html#FillProperties
     see also mozFillRule: http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-June/032002.html

  -->

  <p>Атрибут <dfn id="dom-context-2d-fillstyle" title="dom-context-2d-fillStyle"><code>fillStyle</code></dfn>
  представляет собой цвет или стиль используемый внутри форм, и атрибут <dfn id="dom-context-2d-strokestyle" title="dom-context-2d-strokeStyle"><code>strokeStyle</code></dfn>
  представляет собой цвет или стиль используемый для линий вокруг форм.</p>

  <p>Оба атрибута могут быть строки или
  <code><a href="#canvasgradient">CanvasGradient</a></code>, или <code><a href="#canvaspattern">CanvasPattern</a></code>. При настройке, строки должны быть <span title="parsed as a CSS <color>
  value">прочитаны как значения цвета CSS</span>. Объекты <code><a href="#canvasgradient">CanvasGradient</a></code> и
  <code><a href="#canvaspattern">CanvasPattern</a></code> должны назначать сами себя <a href="#refsCSSCOLOR">[CSSCOLOR]</a>. Если значение строчное, но не может быть <span>прочитано как значение цвета CSS</span>, не является строкой <code><a href="#canvasgradient">CanvasGradient</a></code> или
  <code><a href="#canvaspattern">CanvasPattern</a></code>, тогда должно быть проигнорировано и атрибут должен возвратиться к предыдущему значению. Если новое значение это объект <code id="fill-and-stroke-styles:canvaspattern-5"><a href="#canvaspattern">CanvasPattern</a></code> помеченный как <a style="" href="#concept-canvas-pattern-not-origin-clean" id="fill-and-stroke-styles:concept-canvas-pattern-not-origin-clean">not origin-clean</a>, тогда флаг битмапа <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="fill-and-stroke-styles:concept-canvas-origin-clean">origin-clean</a> должен быть поставлен ложный.</p>

  <p>Когда контекст создан, атрибуты <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> и <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> должны изначально иметь строчное значение <code>#000000</code>.</p>

  <p>Если значение является цветом, на него не должна влиять матрица преобразования.</p> <!-- so
  singular matrices don't affect solid color fillStyles -->

  </div>

  <hr>

  <p>Существует два типа градиентов, линейный градиент и радиальный, оба представлены объектами реализующими непрозрачный интерфейс <code><a href="#canvasgradient">CanvasGradient</a></code>.</p>

  <p id="interpolation">Когда градиент был создан (смотрите выше),
  остановки (stops) расположены вдоль него, чтобы определить, как цвета распределены вдоль градиента. <span class="impl">Цвет градиента на
  каждой остановке это цвет указанный для нее. Между каждой такой остановкой цвета и альфа-компонент должны быть линейно интерполированы над RGBA пространством без умножения альфа значения, чтобы найти цвет используемый на этом смещении. Перед первой остановкой, цвет должен быть цветом первой остановки. После последней остановки, цвет должен быть цветом последней остановки. Когда нет остановок, градиент является прозрачным черным.</span></p>

  <dl class="domintro">

   <dt><var>gradient</var> . <code title="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop</a></code>(<var>offset</var>, <var>color</var>)</dt>

   <dd>

    <p>Добавляет цвет остановки с заданным цветом градиента на заданное смещение. 0.0 это смещение на одном конце градиента, 1.0 - на другом.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если смещение не в диапазоне. Выдает исключение <code>SyntaxError</code> если цвет не может быть прочитан.</p>

   </dd>

   <dt><var>gradient</var> = <var>context</var> . <code title="dom-context-2d-createLinearGradient"><a href="#dom-context-2d-createlineargradient">createLinearGradient</a></code>(<var>x0</var>, <var>y0</var>, <var>x1</var>, <var>y1</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvasgradient">CanvasGradient</a></code> который представляет линейный градиент, рисующий вдоль заданной линии с помощью координат.</p>

   </dd>

   <dt><var>gradient</var> = <var>context</var> . <code title="dom-context-2d-createRadialGradient"><a href="#dom-context-2d-createradialgradient">createRadialGradient</a></code>(<var>x0</var>, <var>y0</var>, <var>r0</var>, <var>x1</var>, <var>y1</var>, <var>r1</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvasgradient">CanvasGradient</a></code>, представляющий радиальный градиент, рисующий вдоль конуса с помощью кругов представленных в аргументах.</p>

    <p>Если какой-то из радиусов негативный, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдает</a> исключение <code>IndexSizeError</code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-canvasgradient-addcolorstop" title="dom-canvasgradient-addColorStop"><code>addColorStop(<var>offset</var>, <var>color</var>)</code></dfn>
  на интерфейсе <code><a href="#canvasgradient">CanvasGradient</a></code> добавляет новую остановку
  в градиент. Если <var>offset</var> меньше чем 0 или больше чем 1, тогда должно быть показано исключение <code>IndexSizeError</code>. Если <var>color</var> не может быть <span>прочитан как значение
  CSS &lt;color&gt;</span>, тогда показывается исключение <code>SyntaxError</code>. В другом случае, градиент должен иметь размещенную остановку на смещении <var>offset</var> по отношению ко всему градиенту и цветом полученным при чтении <var>color</var> как значения CSS &lt;color&gt;. Если множество остановок
  добавляются в одно и тоже смещение, они должны быть расположены в порядке добавления, с первой на начале градиента и каждой последующей на ничтожном растоянии от друг друга вдоль линии.</p>

  <p>Метод <dfn id="dom-context-2d-createlineargradient" title="dom-context-2d-createLinearGradient"><code>createLinearGradient(<var>x0</var>, <var>y0</var>, <var>x1</var>,
  <var>y1</var>)</code></dfn> принимает четыре аргумента, которые представляют собой начальную точку (<var>x0</var>, <var>y0</var>) и конечную точку (<var>x1</var>, <var>y1</var>) градиента. Метод должен возвратить линейный
  <code><a href="#canvasgradient">CanvasGradient</a></code> инициализируемый в указанной строке.</p>

  <p>Линейные градиенты должны визуализироваться таким образом, чтоб все точки на линии
  перпендикулярной к линии пересекающей начальную и конечную точку, имели
  цвет в точке где эти две линии пересекаются (с цветами исходящими от <a href="#interpolation">интерполяции и экстраполяции</a> описанных выше). Точки в линейном градиенте должны преобразоваться как описано <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей преобразования</a> при визуализации (рендеринге).</p>

  <p>Если <span><var>x0</var> = <var>x1</var></span> и <span><var>y0</var> = <var>y1</var></span>, то линейный градиент не должен рисовать ничего.</p>

  <p>Метод <dfn id="dom-context-2d-createradialgradient" title="dom-context-2d-createRadialGradient"><code>createRadialGradient(<var>x0</var>, <var>y0</var>, <var>r0</var>,
  <var>x1</var>, <var>y1</var>, <var>r1</var>)</code></dfn> принимает шесть аргументов, первые три представляют собой
  начало круга с началом (<var>x0</var>, <var>y0</var>) и радиусом <var>r0</var>, последние три представляют собой конец круга
  с началом (<var>x1</var>, <var>y1</var>) и радиусом <var>r1</var>. Значения в координатном пространстве единиц. Если что-то из <var>r0</var> или <var>r1</var>
  являются негативными, должно показаться исключение <code>IndexSizeError</code>. В другом случае, метод должен возвратить радиальный
  <code><a href="#canvasgradient">CanvasGradient</a></code> с двумя заданными кругами.</p>

  <p>Радиальные градиенты должны быть визуализированы при помощи следующих шагов:</p>

  <ol>

   <li><p>Если <span><var>x<sub>0</sub></var> = <var>x<sub>1</sub></var></span> и <span><var>y<sub>0</sub></var> = <var>y<sub>1</sub></var></span> и <span><var>r<sub>0</sub></var> = <var>r<sub>1</sub></var></span>, то радиальный градиент не должен рисовать ничего. Прервать эти шаги.</p></li>

   <li>

    <p>Сделать <span>x(<var>ω</var>) = (<var>x<sub>1</sub></var>-<var>x<sub>0</sub></var>)<var>ω</var> + <var>x<sub>0</sub></var></span></p>

    <p>Сделать <span>y(<var>ω</var>) = (<var>y<sub>1</sub></var>-<var>y<sub>0</sub></var>)<var>ω</var> + <var>y<sub>0</sub></var></span></p>

    <p>Сделать <span>r(<var>ω</var>) = (<var>r<sub>1</sub></var>-<var>r<sub>0</sub></var>)<var>ω</var> + <var>r<sub>0</sub></var></span></p>

    <p>Сделать цвет в <var>ω</var> цветом в позиции на градиенте (с цветами исходящими из <a href="#interpolation">интерполяции и экстраполяции</a>
    описанных выше).</p>

   </li>

   <li><p>Для всех значений <var>ω</var> где <span>r(<var>ω</var>) &gt; 0</span>,
   начинать со значения <var>ω</var> ближайшего к
   положительной бесконечности и заканчивать со значением <var>ω</var> ближайшим к негативной бесконечности, нарисовать окружность с радиусом <span>r(<var>ω</var>)</span> на позиции (<span>x(<var>ω</var>)</span>, <span>y(<var>ω</var>)</span>), с цветом в <var>ω</var>, но только рисовать на частях холста (canvas) которые еще не были зарисованы раннее на этом шаге.</p></li>

  </ol>

  <p class="note">Это фактически создает конус, затронутый двумя кругами определенными в создании градиента, с частью конуса перед началом круга (0.0) цвета первого смещения и частью конуса после конечного круга (1.0) цвета последнего смещения, а зоны за конусом не затронуты градиентом (прозрачный черный).</p>

  <p>Полученный в результате радиальный градиент должен затем быть преобразован как описано в <a href="#transformations" title="dom-context-2d-transformation">текущей матрице преобразования</a> когда визуализируется.</p>

  <p>Градиенты должны быть нарисованы только когда соответствующие сглаживания или
  эффекты заполнения требуют чтобы они были нарисованы.</p>

  </div>

  <hr>

  <p>Паттерны представлены объектами реализующими прозрачный
  <code><a href="#canvaspattern">CanvasPattern</a></code> интерфейс.</p>

  <dl class="domintro">

   <dt><var>pattern</var> = <var>context</var> . <code title="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern</a></code>(<var>image</var>, <var>repetition</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvaspattern">CanvasPattern</a></code>, который использует данное изображение
    и повторяет в направлении заданном аргументом <var>repetition</var>.</p>

    <p>Допустимые значения <var>repetition</var>: "<code>repeat</code>" (оба направления), "<code>repeat-x</code>" (горизонтальное), "<code>repeat-y</code>" (вертикальное) и "<code>no-repeat</code>" (ни один). Если аргумент <var>repetition</var> пуст, значение <code>repeat</code> используется.</p>

    <p>Если изображение не имеет данных, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>InvalidStateError</code>. Если второй аргумент
    не один из допустимых, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение <code>SyntaxError</code>. Если изображение еще не полностью декодировано, то аргумент возвращает null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Для создания объектов этого типа используется метод <dfn id="dom-context-2d-createpattern" title="dom-context-2d-createPattern"><code>createPattern(<var>image</var>, <var>repetition</var>)</code></dfn>. Когда метод вызван, пользовательский агент должен выполнить следующие шаги:</p>

  <ol>
  <li>Сделать <var>image</var> первым аргументом и <var>repetition</var> — вторым.</li>
  <li><a href="#check-the-usability-of-the-image-argument">Проверить пригодность аргумента изображения</a>. Если это возвращает <var>aborted</var>, тогда показывается исключение и метод не возвращает ничего; прервать эти шаги. Если возвращает <var>bad</var>, тогда возвратить null прервать эти шаги. В другом случае это возвращает <var>good</var>; продолжить эти шаги.</li>
  <li>Если <var>repetition</var> пустая строка, сделать ее "<code>repeat</code>".</li>
  <li>Если <var>repetition</var> не один из: "<code>repeat</code>", "<code>repeat-x</code>", "<code>repeat-y</code>", or "<code>no-repeat</code>", выдать исключение <var>SyntaxError</var> и прервать эти шаги.</li>
  <li>Создать новый объект <code><a href="#canvaspattern">CanvasPattern</a></code> с изображением <var>image</var> и поведением повторения заданным <var>repetition</var>.</li>
  <li>Если <a href="#the-image-argument-is-not-origin-clean">если аргумент не origin-clean</a>, пометить объект <code><a href="#canvaspattern">CanvasPattern</a></code> как <dfn id="concept-canvas-pattern-not-origin-clean"><i>not origin-clean</i></dfn>.</li>
  <li>Возвратить объект <code><a href="#canvaspattern">CanvasPattern</a></code>.</li>
  </ol>
  <p>
  Изменения этого <var>изображения</var> после вызова метода <code title="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern()</a></code> не должно влиять на паттерн. </p>

  <p>Паттерны должны быть нарисованы так что верхняя левая часть первого изображения
  закреплена в начале координатного пространства, затем изображения повторяются по горизонтали слева направо, если
  строка была задана строка <code>repeat-x</code>, или вертикально сверху
  вниз, если была задана строка <code>repeat-y</code>, или во всех четырех направлениях всего холста, если была задана строка <code>repeat</code>. Изображения не масштабируются в этом процессе; один CSS
  пиксель изображения должен быть нарисован на одной координатной единице. Когда отображено, однако, паттерны
  должны быть нарисованы только там где эффекты сглаживания или заполнения
  требуют этого, и паттерн повторения должен быть
  затронут <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей преобразования</a>. Пиксели не охватываемые паттерном повторения (если строка <code>repeat</code> не задана) должны быть прозрачными черными.</p>

  <p>Если данные исходного изображения растровые, значение нарисованное
  в точке в зоне повторений вычисляются фильтрованием данных исходного изображения. Пользовательский агент может использовать любой алгоритм фильтрования (например, билинейной интерполяции или схожий).
  <!-- drawImage() has a similar paragraph with different rules -->

  </p>

  <!--
   Requests for v5 features:
    * apply transforms to patterns, so you don't have to create
      transformed patterns manually by rendering them to an off-screen
      canvas then using that canvas as the pattern.
  -->

  </div>

  <div class="impl">

  <hr>

  <p>Если радиальный градиент или паттерн повторения используется когда
  матрица преобразования сингулярна, в результате стиль должен быть
  прозрачный черный (в другом случае градиент или паттерн
  разрушились бы до точки или линии, оставив другие пиксели неопределенными).
  Линейные градиенты и цвета всегда определяют все точки даже с
  сингулярной матрицей преобразования.</p>

  </div>




  <h2 id="drawing-rectangles-to-the-canvas"><span class="secno">9 </span>Рисование прямоугольников на холсте</h2>

  <p>Есть три метода которые сразу рисуют прямоугольники на битмапе. Каждый из них принимает четыре аргумента; первые два задают координаты <var>x</var> и <var>y</var> верхнего левого угла, а вторые два задают ширину <var>w</var> и высоту <var>h</var> прямоугольника, соответственно.</p>

  <div class="impl">

  <p><a href="#transformations" title="dom-context-2d-transformation">Текущая матрица преобразования</a> должна быть применена к следующим четырем координатам, которые формируют путь который затем должен быть закрыт чтобы получился заданный прямоугольник: <span>(<var>x</var>, <var>y</var>)</span>, <span>(<span><var>x</var>+<var>w</var></span>, <var>y</var>)</span>,
  <span>(<span><var>x</var>+<var>w</var></span>,
  <span><var>y</var>+<var>h</var></span>)</span>,
  <span>(<var>x</var>, <span><var>y</var>+<var>h</var></span>)</span>.</p>

  <p>Фигуры рисуются без влияния <a href="#current-default-path">current default
  path</a> и подлежат <a href="#clipping-region" title="clipping
  region">clipping region</a>, за исключением <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code>, также <a href="#shadows" title="shadows">эффектов теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, and <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global операторов</a>.</p>

  </div>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Очищает все пиксели на холсте в заданном прямоугольнике к прозрачному черному.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-fillRect"><a href="#dom-context-2d-fillrect">fillRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Рисует заданный прямоугольник на холсте, используя текущий стиль заполнения.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-strokeRect"><a href="#dom-context-2d-strokerect">strokeRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Рисует прямоугольник на холст, используя текущий строчный стиль.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-clearrect" title="dom-context-2d-clearRect"><code>clearRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать<var>pixels</var> сетом пикселей в заданном прямоугольнике, которые также пересекают текущий clipping
   region.</p></li>

   <li><p>Очистить пиксели в <var>pixels</var> к полностью прозрачному черному, удаляя любое предыдущее изображение.</p></li>

   <li><p><span>Очистить регионы которые покрывают пиксели</span> в <var>pixels</var> в элементе <code>canvas</code>.</p></li>

  </ol>

  <p class="note">Если высота или ширина равна нулю, этот метод не имеет эффекта, так как сет пикселей будет пустым.</p>

  <p>Метод <dfn id="dom-context-2d-fillrect" title="dom-context-2d-fillRect"><code>fillRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен нарисовать указанную прямоугольную область в <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>. Если ширина или высота равна нулю, этот метод не имеет эффекта.</p>

  <p>Метод <dfn id="dom-context-2d-strokerect" title="dom-context-2d-strokeRect"><code>strokeRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен принять результат от <a href="#trace-a-path" title="trace a path">tracing the path</a> описанного ниже, используя стили линий объекта <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> и
  заполнить с <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>.</p>

  <p>Если оба <var>w</var> и <var>h</var> равны нулю,
  путь имеет один подпуть только с одной точкой (<var>x</var>, <var>y</var>), без линий, и этот метод не имеет эффекта (алгоритм <a href="#trace-a-path">trace a path</a> возвращает пустой путь в этом случае).</p>

  <p>Если только один из <var>w</var> и <var>h</var> равен нулю, тогда путь имеет один подпуть с двумя точками, с координатами (<span><var>x</var></span>, <span><var>y</var></span>) и (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>+<var>h</var>), в этом порядке,
  соединенные одной прямой линией.</p>

  <p>В другом случае, путь имеет один подпуть содержащий четыре точки с координатами (<span><var>x</var></span>, <span><var>y</var></span>), (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>), (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>+<var>h</var>) и (<span><var>x</var></span>, <span><var>y</var>+<var>h</var></span>), соединенные друг с другом прямыми линиями.</p>

  </div>



  <h2 id="drawing-text-to-the-canvas"><span class="secno">10 </span>Рисование текста на холсте</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText</a></code>(<var>text</var>, <var>x</var>, <var>y</var> [, <var>maxWidth</var> ] )</dt>
   <dt><var>context</var> . <code title="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText</a></code>(<var>text</var>, <var>x</var>, <var>y</var> [, <var>maxWidth</var> ] )</dt>

   <dd>

    <p>Заполнения и обводки (соответственно) заданного текста на заданной позиции. Если максимальная ширина задана, при необходимости текст будет отрегулирован чтобы соответствовать ей.</p>

   </dd>

   <dt><var>metrics</var> = <var>context</var> . <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText</a></code>(<var>text</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#textmetrics">TextMetrics</a></code> с метрикой данного текста в текущем шрифте.</p>

   </dd>

   <dt><var>metrics</var> . <code title="dom-textmetrics-width"><a href="#dom-textmetrics-width-0">width</a></code></dt>

   <dd>

    <p>Возвращает ширину текста, который был передан методом
    <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Интерфейс <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> обеспечивает следующие методы для отображения текста непосредственно на холст.</p>

  <p>Методы <dfn id="dom-context-2d-filltext" title="dom-context-2d-fillText"><code>fillText()</code></dfn> и
  <dfn id="dom-context-2d-stroketext" title="dom-context-2d-strokeText"><code>strokeText()</code></dfn>
 принимают три или четыре аргумента: <var>text</var>, <var>x</var>, <var>y</var>, и опционально <var>maxWidth</var>, и отображают заданный <var>text</var> на заданных (<var>x</var>, <var>y</var>) координатах, обеспечивая текст не шире
  чем <var>maxWidth</var> если это задано, используя текущие значения
  <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> и <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>. А именно, когда методы вызываются, агент пользователя должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Запустить <a href="#text-preparation-algorithm">алгоритм подготовки текста</a>, передавая ему
   <var>text</var>, объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>
   и, если аргумент <var>maxWidth</var> был задан, этот аргумент. Сделать <var>glyphs</var> результатом.</p>

   </li><li><p>Переместить все фигуры в <var>glyphs</var> вправо на <var>x</var> CSS пикселей и вниз на <var>y</var> CSS пикселей.</p></li>

   <li>

    <p>Нарисовать формы заданные в <var>glyphs</var>, как преобразованные с помощью <a href="#transformations" title="dom-context-2d-transformation">текущей матрицы преобразования</a>, с каждым CSS пикселем в координатном пространстве <var>glyphs</var>.</p>

    <p>Для <code title="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText()</a></code>,
    <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> должен применяться к формам и <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> должен быть проигнорирован. Для <code title="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText()</a></code> наоборот: <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>
    должен примениться к результату <a href="#trace-a-path" title="trace a
    path">начертания</a> с помощью объекта
    <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> для стилей линий,
    и <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> должен быть проигнорирован.</p>

    <p>Эти формы рисуются без влияния текущего пути
    и подлежат <a href="#shadows" title="shadows">эффектам теней</a>,
    <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>,
    <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

   </li>

   <li><p>Если <a href="#text-preparation-algorithm" id="drawing-text-to-the-bitmap:text-preparation-algorithm-2">алгоритм подготовки текста</a> использует шрифт который имеет <a id="drawing-text-to-the-bitmap:origin-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">происхождение</a>,
   которое не <a href="http://www.w3.org/TR/html/browsers.html#same-origin" id="drawing-text-to-the-bitmap:same-origin">то же</a>, что <a id="drawing-text-to-the-bitmap:origin-2-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">происхождение</a> описанное в <a id="drawing-text-to-the-bitmap:entry-settings-object" href="http://www.w3.org/TR/html/webappapis.html#entry-settings-object">entry settings object</a> (даже если "использование шрифта" означает просто проверку имеет ли этот шрифт особый глиф, перед переходом к другому шрифту), тогда установить флаг битмапа <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="drawing-text-to-the-bitmap:concept-canvas-origin-clean">origin-clean</a> ложным.</p></li>
  </ol>

<!--v6DVT - this is commented out until CSS can get its act together
enough to actual specify vertical text rendering (how long have we
been waiting now?)

WHEN EDITING THIS, FIX THE PARTS MARKED "&#x0058;&#x0058;&#x0058;" BELOW

ALSO NOTE THAT THIS PROBABLY NEEDS ENTIRELY REVISITING NOW THAT WE
HAVE REJIGGED HOW TEXT WORKS IN v5

  <p>The <dfn
  title="dom-context-2d-fillVerticalText"><code>fillVerticalText()</code></dfn>
  and <dfn
  title="dom-context-2d-strokeVerticalText"><code>strokeVerticalText()</code></dfn>
  methods take three or four arguments, <var>text</var>, <var
  title="">x</var>, <var>y</var>, and optionally <var
  title="">maxHeight</var>, and render the given <var
  title="">text</var> as vertical text at the given (<var
  title="">x</var>, <var>y</var>) coordinates ensuring that
  the text isn't taller than <var>maxHeight</var> if
  specified, using the current <code
  title="dom-context-2d-font">font</code> and <code
  title="dom-context-2d-textAlign">textAlign</code>
  values. Specifically, when the methods are called, the user agent
  must run the following steps:</p>

  <ol>

   <li><p>If <var>maxHeight</var> is present but less than or
   equal to zero, return without doing anything; abort these
   steps.</p></li>

   <li><p>Let <var>font</var> be the current font of the
   context, as given by the <code
   title="dom-context-2d-font">font</code> attribute.</p></li>

   <li><p>Replace all the <span title="space character">space
   characters</span> in <var>text</var> with U+0020 SPACE
   characters.</p></li>

   <li><p>Form a <em class="&#x0058;&#x0058;&#x0058;">whatever CSS ends up calling
   vertical line boxes and inline boxes</em> containing the text <var
   title="">text</var>, with all the properties at their initial
   values except the 'font' property of the inline box set to <var
   title="">font</var> and the 'direction' property of the inline
   box set to <span>the directionality</span> of the <code>canvas</code>
   element.</p></li>

   <!- - if you insert a step here, make sure to adjust the next step's
   final words - ->

   <li><p>If the <var>maxHeight</var> argument was specified
   and the hypothetical height of the <em class="&#x0058;&#x0058;&#x0058;">box</em>
   in the hypothetical line box is greater than <var
   title="">maxHeight</var> CSS pixels, then change <var
   title="">font</var> to have a more condensed font (if one is
   available or if a reasonably readable one can be synthesized by
   applying an appropriate scale factor to the font) or a smaller
   font, and return to the previous step.</p></li>

   <li>

    <p>Let the <var>anchor point</var> be a point on the <em
    class="&#x0058;&#x0058;&#x0058;">inline box</var>, determined by the <code
    title="dom-context-2d-textAlign">textAlign</code>, as follows:</p>

    <p>Vertical position:</p>

    <dl>

     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">start</code></dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">left</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'ltr'</dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">right</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var>anchor point</var>'s vertical
     position be the top edge of the <em class="&#x0058;&#x0058;&#x0058;">inline
     box</em>.</dd>

     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">end</code></dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">right</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'ltr'</dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">left</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var>anchor point</var>'s vertical
     position be the bottom edge of the <em class="&#x0058;&#x0058;&#x0058;">inline
     box</em>.</dd>


     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">center</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position
     be halfway between the top and bottom edges of the <em
     class="&#x0058;&#x0058;&#x0058;">inline box</em>.</dd>


    </dl>

    <p>Let the horizontal position be half way between the left and
    right edges of the em box of the first available font of the <em
    class="&#x0058;&#x0058;&#x0058;">inline box</em>.</p>

   </li>

   <li>

    <p>Paint the hypothetical inline box as the shape given by the
    text's glyphs, as transformed by the <span
    title="dom-context-2d-transformation">current transformation
    matrix</span>, and anchored and sized so that before applying the
    <span title="dom-context-2d-transformation">current transformation
    matrix</span>, the <var>anchor point</var> is at (<var
    title="">x</var>, <var>y</var>) and each CSS pixel is
    mapped to one coordinate space unit.</p>

    <p>For <code
    title="dom-context-2d-fillVerticalText">fillVerticalText()</code>
    <code title="dom-context-2d-fillStyle">fillStyle</code> must be
    applied and <code
    title="dom-context-2d-strokeStyle">strokeStyle</code> must be
    ignored. For <code
    title="dom-context-2d-strokeVerticalText">strokeVerticalText()</code>
    the reverse holds and <code
    title="dom-context-2d-strokeStyle">strokeStyle</code> must be
    applied and <code
    title="dom-context-2d-fillStyle">fillStyle</code> must be
    ignored.</p>

    <p>Text is painted without affecting the current path, and is
    subject to <span title="shadows">shadow effects</span>, <span
    title="dom-context-2d-globalAlpha">global alpha</span>, the <span
    title="clipping region">clipping region</span>, and <span
    title="dom-context-2d-globalCompositeOperation">global composition
    operators</span>.</p>

   </li>

   <li>
       <p>If the text preparation algorithm used a font that has an <span>origin</span> that is not the same
	   as the entry script's <span>origin</span> even if "using a font" means just checking if that font has a particular glyph in it before falling back to another font), then set the <i>origin-clean</i> flag to false.
	   </p>
   </li>
  </ol>

v6DVT (also check for '- -' bits in the part above) -->

  <p>Метод <dfn id="dom-context-2d-measuretext" title="dom-context-2d-measureText"><code>measureText()</code></dfn>
  принимает один аргумент, <var>text</var>. Когда метод
  вызван, пользовательский агент должен запустить алгоритм подготовки текста, передать
  новый объект TextMetrics с его атрибутами установленными как описано в следующем списке.
  Если при выполнении этих измерений необходимо использовать шрифт, который имеет
  <span>происхождение</span> которое не <span title="same
  origin">то же</span> что у объекта <code>Document</code> который
  содержит элемент <code>canvas</code> (даже если "использование шрифта" означает
  просто проверку имеет ли этот шрифт особый глиф, перед
  переходом к другому шрифту), тогда метод должен выдать исключение
  <code>SecurityError</code>.
  В другом случае, он должен возвратить новый объект <code><a href="#textmetrics">TextMetrics</a></code>.
  <a href="#refsCSS">[CSS]</a>

  </p>

  <dl>
  <dt>Атрибут <dfn id="dom-textmetrics-width" title="dom-textmetrics-width"><code>width</code></dfn></dt>

   <dd>
   <p>Ширина этого инлайн-бокса в CSS пикселях. (Расстояние между глифами в тексте.)</p>
   </dd>

  </dl>

<!--ADD-TOPIC:Security-->
  Если при выполнении этих измерений необходимо использовать шрифт, который имеет
  <span>происхождение</span> которое не <span title="same
  origin">то же</span> что у объекта <code>Document</code> который
  содержит элемент <code>canvas</code> (даже если "использование шрифта" означает
  просто проверку имеет ли этот шрифт особый глиф, перед
  переходом к другому шрифту), тогда метод должен выдать исключение
  <code>SecurityError</code>.
<!--REMOVE-TOPIC:Security-->
  В другом случае, он должен возвратить новый объект <code><a href="#textmetrics">TextMetrics</a></code>.
  <a href="#refsCSS">[CSS]</a>

  <p></p>

  <p>Интерфейс <code><a href="#textmetrics">TextMetrics</a></code> используется для объектов
  возвращенных от <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>. Он имеет один атрибут, <dfn id="dom-textmetrics-width-0" title="dom-textmetrics-width"><code>width</code></dfn>, который устанавливается методом <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>.</p>

  </div>

  <p class="note">Будущая версия 2D context API может обеспечивать
  путь к отображению фрагментов документов с помощью CSS, прямо на холст.</p>



  <h2 id="drawing-paths-to-the-canvas"><span class="secno">11 </span>Рисование пути на холсте</h2>

  <p>Контекст всегда имеет <dfn id="current-default-path">текущий путь по умолчанию</dfn>. Есть только один текущий путь, это не часть
  <a href="#drawing-state">состояния рисования</a>. Текущий путь является <a href="#concept-path" title="concept-path">path</a>, как описано выше.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath</a></code>()</dt>

   <dd>

    <p>Сбрасывает текущий путь.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-fill"><a href="#dom-context-2d-fill">fill</a></code>()</dt>

   <dd>

    <p>Заполняет подпути текущего пути или заданного пути текущим стилем заполнения.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-stroke"><a href="#dom-context-2d-stroke">stroke</a></code>()</dt>

   <dd>

    <p>Сглаживает подпути текущего или заданного пути текущим стилем сглаживания.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a></code>(<var>element</var>)</dt>

   <dd>

    <p>Информирует пользователя холста о месте запасного элемента, на основе текущего пути. Если заданный элемент имеет фокус, рисует обводку фокуса вокруг текущего пути, следуя правилам платформы или пользовательского агента.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-clip"><a href="#dom-context-2d-clip">clip</a></code>()</dt>

   <dd>

    <p>В дальнейшем ограничивает clipping region текущему пути.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-isPointInPath"><a href="#dom-context-2d-ispointinpath">isPointInPath</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Возвращает true если заданная точка имеется в текущем пути.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-beginpath" title="dom-context-2d-beginPath"><code>beginPath()</code></dfn>
  должен очистить список подпутей в текущем пути контекста, поэтому здесь в очередной раз ноль подпутей.</p>

   <p>Метод <dfn id="dom-context-2d-fill" title="dom-context-2d-fill"><code>fill()</code></dfn>
  должен заполнить все подпути текущего пути, используя <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>. Открытые подпути должны быть неявно
  закрыты при заполнении (без влияния на фактические
  подпути).</p>

  <p class="note">Таким образом, если пересекаются два подпути, имеющие разные витки, они компенсируются и не приводят к
  заполнению. Если они имеют одинаковый виток, эта область просто рисуется
  один раз.</p>

  <p>Метод <dfn id="dom-context-2d-stroke" title="dom-context-2d-stroke"><code>stroke()</code></dfn>
  должен <a href="#trace-a-path" title="trace a path">чертить</a> путь,
  используя объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> для стилей
  линий, а затем заполнить общую площадь сглаживания с помощью атрибута <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>.</p>

  <p class="note"><em>Стиль</em> сглаживания зависит от
  преобразования во время рисования, даже если путь это
  <a href="#current-default-path">текущий путь по умолчанию</a>.</p>

  <p>Пути, при заполнении или сглаживании, должны быть нарисованы без влияния
  текущего пути, но должны подвергаться <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global
  alpha</a>, <a href="#clipping-region" title="clipping region">clipping
  region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition
  операторов</a>.</p>

  <p>Сегменты линий нулевой длины убираются перед тем как сглаживать путь.
  Пустые подпути должны быть проигнорированы.</p>

  <hr>

  <p id="dom-context-2d-focusoutline">Метод <dfn id="dom-context-2d-drawfocusifneeded" title="dom-context-2d-drawFocusIfNeeded"><code>drawFocusIfNeeded(<var>element</var>)</code></dfn> при вызове должен выполнить следующие шаги:</p>

  <ol>
   <li>
   <p>
   Если текущий путь имееть ноль подпутей, тогда прервать эти шаги.
   </p>
   </li>
   <li><p>Если <var>element</var> не сфокусирован или не является
   вложенным элемента с которым контекст ассоциирован, прервать эти шаги.</p></li>

   <li>

    <p>Если пользователь запросил использование отдельных контуров фокуса
    (например высококонтрастных контуров) или <var>element</var> будет иметь контур нарисованный вокруг него,
    тогда нарисовать контур фокуса соответствующего стиля вдоль намеченного
    пути, следуя правилам платформы.</p>

    <p class="note">Некоторые платформы рисуют только линии фокуса вокруг
    элементов которые сфокусированы с помощью клавиатуры, а не с помощью
    мышки. Другие платформы вообще не рисуют линии фокуса вокруг некоторых элементов, если только соответствующая
    функция не включена. Этот API предназначен чтобы следовать данным правилам. Пользовательские агенты, которые реализуют это в зависимости от способа которым элемент был сфокусирован, поощряются делать это с помощью метода <code title="dom-focus">focus()</code>
    основанном на способе вызова (если он был).</p>

    <p>Контуры фокуса не должны подвергаться <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, или
    <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global
    composition операторам</a>, но <em>должны</em> подвергаться <a href="#clipping-region" title="clipping region">clipping region</a>.
    Когда зона фокуса обрезана с помощью элемента canvas, только визуальное представление контура фокуса вырезается в clipping region.

	</p>

	<p>
    Если зона фокуса не в пределах экрана, нужно прокрутить в видимую зону, тогда она получит фокус.
	</p>

   </li>

   <li>

    <p><a href="#inform">Проинформировать пользователя</a> о заданном расположении. Полное расположение
	соответствующего запасного элемента передается к
	доступному API, если оно поддерживается. Пользовательские агенты могут ждать до следующего
	раза, когда <span>цикл обработки</span> достигает своего шага "обновить рендеринг".
   </li>

  </ol>

  <p class="note" id="inform">"Проинформировать пользователя", используемое в этом разделе, может означать вызов доступного API системы, которое будет уведомлять вспомогательные технологии, такие как инструменты увеличения.</p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-clip" title="dom-context-2d-clip"><code>clip()</code></dfn>
  должен создать новый <dfn id="clipping-region">clipping region</dfn> путем вычисления
  пересечения текущей вырезанной области и зоной
  описаной с помощью пути, используя правило ненулевого индекса. Открытые подпути должны быть неявно закрыты при вычислении (без влияния на фактические подпути). Новая вырезанная область
  (clipping region) заменяет текущую вырезанную область.</p>

  <p>При инициализации контекста, вырезанная область (clipping region) должна быть установлена
  прямоугольником с верхним левым углом на (0,0), с шириной и высотой координатного пространства.</p>

  <!-- v6
   Jordan OSETE suggests:
    * support ways of extending the clipping region (union instead of intersection)
       - also "add", "subtract", "replace", "intersect" and "xor"
       - maybe just support creating unions, intersections, and other -ions of paths
  -->
  <!-- v5
   Jordan OSETE suggests:
    * support ways of resetting the clipping region without save/restore
  -->

  <hr>

  <p>Метод <dfn id="dom-context-2d-ispointinpath" title="dom-context-2d-isPointInPath"><code>isPointInPath()</code></dfn>
  должен возвращать true если точка заданная с помощью координат <var>x</var> и <var>y</var> при обработке как координат в координатном пространстве холста,
  не зависимо от текущего преобразования, внутри предполагаемого
  пути как определено правилом ненулевого индекса; и должен возвратить false в другом случае. Точки на самом пути должны рассматриваться как внутри пути. Если какой-то из аргументов равен бесконечности или
  NaN, тогда метод должен возвратить false.</p>

  <hr>

  </div>

  <h2 id="drawing-images-to-the-canvas"><span class="secno">12 </span>Рисование изображений на холсте</h2>

  <p>Для того чтобы нарисовать изображение на холсте, используется метод <dfn id="dom-context-2d-drawimage" title="dom-context-2d-drawImage"><code>drawImage</code></dfn>.</p>

  <p>Этот метод может быть вызван с тремя различными наборами аргументов:</p>

  <ul class="brief">
   <li><code>drawImage(<var>image</var>, <var>dx</var>, <var>dy</var>)</code>
   </li><li><code>drawImage(<var>image</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</code>
   </li><li><code>drawImage(<var>image</var>, <var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</code>
  </li></ul>

  <!-- v3: drawImage() of an ImageData object might make sense (when resizing as well as filtering) - ack Charles Pritchard -->

  <p>Каждый из них может принять
  <code>HTMLImageElement</code>, <code>HTMLCanvasElement</code> или <code>HTMLVideoElement</code> для аргумента изображения <var>image</var>.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>dx</var>, <var>dy</var>)</dt>
   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</dt>
   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</dt>

   <dd>

    <p>Рисует заданное изображение на холст. Аргументы интерпретируются следующим образом:</p>

    <p><img alt="The sx and sy parameters give the x and y coordinates of the source rectangle; the sw and sh arguments give the width and height of the source rectangle; the dx and dy give the x and y coordinates of the destination rectangle; and the dw and dh arguments give the width and height of the destination rectangle." height="356" src="./drawImage.png" width="356"></p>

    <p>Если первый аргумент не является элементом <code>img</code>,
    <code>canvas</code> или <code>video</code>, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>TypeMismatchError</code>. Если изображение не содержит данных, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение <code>InvalidStateError</code>. Если
    один из размеров исходного прямоугольника равен нулю, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>IndexSizeError</code>. Если изображение (еще) не полностью декодировано, ничего не рисуется.</p>

   </dd>

  </dl>

  <div class="impl">

<p>Когда метод <code id="drawing-images:dom-context-2d-drawimage-4"><a href="#dom-context-2d-drawimage">drawImage()</a></code> вызван, пользовательский агент должен выполнить шаги:</p>

  <ol><li><p><a href="#check-the-usability-of-the-image-argument" id="drawing-images:check-the-usability-of-the-image-argument">Проверить пригодность аргумента<var>image</var></a>. Если возвращается
   <i>aborted</i>, то исключение было выдано и метод не выдает ничего;
   прервать эти шаги. Если возвращается <i>bad</i>, то прервать эти шаги ничего не рисуя.
   В другом случае возвращается <i>good</i>; продолжить.</p></li><li>

    <p>Установить источник и назначение прямоугольников как:</p>

    <p>Если не задано, аргументы <var>dw</var> и <var>dh</var> должны по умолчанию быть
    <var>sw</var> и <var>sh</var>, интерпретируемые таким образом, что один CSS пиксель в изображении рассматривается как единица в координатном пространстве единиц битмапа. Если аргументы <var>sx</var>,
    <var>sy</var>, <var>sw</var> и <var>sh</var> не заданы, по умолчанию они равняются 0,
    0, внутренней ширине изображения в пикселях и внутренней высоте изображения в пикселях, соответственно. Если изображение не имеет внутренних размеров, должен быть использован <i>конкретный размер объекта</i>, как определено CSS алгоритмом "<a href="http://www.w3.org/TR/css3-images/#default-sizing">Concrete Object Size Resolution</a>". Если же <i>заданный размер</i> не имеет указанных ширины/высоты и прочих параметров, внутренние данные объекта будут взяты из аргумента <var>image</var>, и <a id="drawing-images:default-object-size" href="http://www.w3.org/TR/css3-images/#default-object-size">размером объекта по умолчанию</a> будет размер битмапа. <a href="#refsCSSIMAGES">[CSSIMAGES]</a></p>

    <p>Исходный прямоугольник — прямоугольник с углами в точках (<var>sx</var>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <span><var>sy</var>+<var>sh</var></span>),
    (<var>sx</var>, <span><var>sy</var>+<var>sh</var></span>).</p>

    <p>Конечный прямоугольник — с углами в точках (<var>dx</var>, <var>dy</var>), (<span><var>dx</var>+<var>dw</var></span>, <var>dy</var>), (<span><var>dx</var>+<var>dw</var></span>, <span><var>dy</var>+<var>dh</var></span>),
    (<var>dx</var>, <span><var>dy</var>+<var>dh</var></span>).</p>

    <p>Когда исходный прямоугольник за пределами исходного изображения, исходный прямоугольник должен быть обрезан под исходное изображение
    и конечный прямоугольник обрезан в той же пропорции.</p>

    <p class="note">Когда конечный прямоугольник за пределами конечного изображения (битмапа), пиксели которые за пределами отбрасываются.</p>

   </li><li><p>Если один из аргументов <var>sw</var> или <var>sh</var> равен нулю, прервать эти шаги. Ничего не рисуется.</p></li><li>

    <p>Нарисовать зону аргумента <var>image</var> заданную исходным прямоугольником
    на зоне растрового изображения (битмапа) контекста заданной конечным прямоугольником, после применения <a href="#transformations" id="drawing-images:transformations">текущей матрицы преобразования</a> на конечном прямоугольнике.</p>

    <p>Данные изображения должны быть обработаны в изначальном направлении, даже если указаны отрицательные размеры. </p>

  <p class="note">Данная спецификация не определяет алгоритм, используемый при масштабировании изображения.</p>

  <p class="note">Когда холст рисуется, <a href="#drawing-model">модель рисования</a> требует источник для копирования перед тем как изображение нарисуется на холсте, так что можно скопировать части холста на перекрывающие его части.</p>

    <p>Если исходное изображение является растровым изображением, значение нарисованное на месте конечного прямоугольника
    вычисляется с помощью фильтрации данных исходного изображения. Агент пользователя может использовать любой алгоритм
    фильтрации (например, билинейной интерполяции или схожий). Когда алгоритм фильтрации
    требует значение пикселя за пределами оригинального изображения, он должен вместо этого использовать значение ближайшего пикселя с краю. Когда алгоритм фильтрации запрашивает значение пикселя извне исходного прямоугольника, но внутри оригинального изображения, следует использовать значение из оригинального изображения.</p>



    <p class="note">Таким образом, масштабирование изображения по частям или в целом будет иметь тот же эффект.</p>

    <p>Изображения рисуются без влияния текущего пути (current path), но подлежат <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

   </li><li><p>Если <a href="#the-image-argument-is-not-origin-clean" id="drawing-images:the-image-argument-is-not-origin-clean"><var>image argument</var> не origin-clean</a>, установить флаг <var>origin-clean</var> битмапа ложным.</p></li></ol>

  <p>Изображения рисуются без влияния текущего пути (current path), но подлежат <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

  </div>

  <h2 id="hit-regions"><span class="secno">13 </span>Hit области</h2>

  <p>Каждый элемент <code>canvas</code> чей <span>основной контекст</span> это объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>,
  должен иметь <dfn id="hit-region-list">список hit областей</dfn> связанный с его битмапом.</p>

  <p><a href="#hit-region-list">Список hit областей</a> это список из <a href="#hit-region" title="hit
  region">hit областей</a>.</p>

  <p>Каждая <dfn id="hit-region">hit область</dfn> содержит следующую информацию:</p>

  <ul>

  <li><p><dfn id="hit-region's-path" title="hit region's path">Путь</dfn> на битмапе элемента <code>canvas</code> для которого он предназначен.</p></li>

  <li><p><dfn id="hit-region's-bounding-circumference" title="hit region's bounding circumference">Ограничивающую окружность</dfn> на битмапе элемента <code>canvas</code>, которая окружает <a href="#hit-region's-path">путь hit области</a> в том виде котором он создан.</p></li>

  <li><p>Опционально, непустая строка, представляющая <dfn id="hit-region's-id" title="hit region's ID">ID</dfn> для отличия этой области от других.</p></li>

   <li>
   <p>Опционально, элемент управления <a href="#hit-region's-control" title="hit region's control">control</a>.</p>

   <p><dfn id="hit-region's-control" title="hit region's control">Control</dfn> это ссылка на узел <code>Element</code>, к которому, в определенных условиях, агент пользователя будет отправлять события, и из которого агент пользователя будет определять состояние hit области для целей доступных инструментов. (Control игнорируется когда он
   не является потомком элемента canvas.)</p>

   </li>
  </ul>

  <dl class="domintro">

  <dt><var>context</var> . <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion</a></code>(<var>options</var>)</dt>

  <dd>

   <p>Добавляет hit область на холст, на основе текущего пути по умолчанию. Аргумент это объект со следующими членами:</p>

   <dl>

    <dt><code title="dom-HitRegionOptions-id">id</code> (по умолчанию пустая строка)

	</dt><dd>ID используемый для этой области. Он используется в событиях
     <code>MouseEvent</code> на <code>canvas</code> (<code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">event.region</a></code>) и как путь
    к вызову этой области в последующих вызовах к <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</dd>
     <dt><code title="dom-HitRegionOptions-control">control</code> (по умолчанию null)

     </dt><dd>Элемент (потомок <code>canvas</code>)
     к которому события должны быть направлены, и который доступные инструменты
     используют как суррогат для описания и взаимодействия с этой областью.</dd>

    </dl>

   <p>Hit области могут быть использованы для различных целей:</p>

   <ul>
    <li>С ID, они могут сделать обнаружение hit проще с помощью
    проверки агентом пользователя на какую область наведена мышь и включить
    ID в события мыши.</li>

    <li>С control, они могут сделать передачу событий к DOM элементам
    автоматической, что позволяет, например, кликнуть на холст чтобы автоматически
    отправить форму с помощью <code>button</code> элемента.</li>

    </ul>

    <p class="note">В то время как ID и control не являются обязательными, при вызове
	addHitRegion, как минимум один из двух должен быть предоставлен
   чтобы создать hit область. </p>


	</dd>

	<dt><var>context</var> . <code title="dom-context-2d-removeHitRegion"><a href="#dom-context-2d-removehitregion">
	removeHitRegion</a></code>(<var>id</var>)</dt>

  <dd>

   <p>Удаляет hit область с битмапа холста. Аргумент это ID области заданный с помощью <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</p>

  <p>Путь который был покрыт этой областью в результате этой операции очищается, оставляя область не-интерактивной. В частности, области которые занимали тот же путь
   перед тем как удаленные области были добавлены, не возобновляют свои прежние роли.</p>

   </dd>

   	<dt><var>context</var> . <code title="dom-context-2d-clearHitRegions"><a href="#dom-context-2d-clearhitregions">
	clearHitRegions</a></code>()</dt>

  <dd>

   <p>Удаляет все hit области с битмапа холста. </p>

  <p>Пути которые были покрыты этими областями в результате
   очищаются, оставляя все области не-интерактивными. </p>

   </dd>

   </dl>

   <div class="impl">

   <p><dfn id="the-region-identified-by-the-id">Область идентифицируемая с помощью ID</dfn> <var>ID</var> в битмапе <var>bitmap</var> это значение возвращаемое следующим алгоритмом (который может вернуть <a href="#hit-region">hit область</a> или ничего):</p>

   <ol>

   <li><p>Если <var>ID</var> равен null, не возвращать ничего и прервать эти шаги.</p></li>

   <li><p>Сделать <var>list</var> <a href="#hit-region-list">списком hit областей</a> связанным с <var>bitmap</var>.</p></li>

   <li><p>Если есть <a href="#hit-region">hit область</a> в <var>list</var> которая <a href="#hit-region's-id" title="hit region's ID">ID</a>
   <span>чувствительна к регистру</span> для <var>ID</var>,
   то вернуть эту <a href="#hit-region">hit область</a> и прервать эти шаги.</p></li>

   <li><p>В другом случае, не возвращать ничего.</p></li>

  </ol>

  <p><dfn id="the-region-representing-the-control">Область представляющая элемент управления</dfn> <var>control</var> для битмапа <var>bitmap</var> это значение возвращенное с помощью следующего
  алгоритма (который может вернуть <a href="#hit-region">hit область</a> или ничего):</p>

  <ol>

   <li><p>Если <var>control</var> равен null, не возвращать ничего и прервать эти шаги.</p></li>

   <li><p>Сделать <var>list</var> <a href="#hit-region-list">списком hit областей</a> связанным с <var>bitmap</var>.</p></li>

   <li><p>Если есть <a href="#hit-region">hit область</a> в <var>list</var> чей <a href="#hit-region's-control" title="hit region's
   control">control</a> равен <var>control</var>, то
   возвратить эту <a href="#hit-region">hit область</a> и прервать эти шаги.</p></li>

   <li><p>В другом случае, не возвращать ничего.</p></li>

  </ol>

  <p><dfn id="the-control-represented-by-a-region">Элемент управления представленный областью</dfn> <var>region</var> для <code>canvas</code> элемента <var>ancestor</var> это значение возвращаемое следующим алгоритмом (который может вернуть элемент или ничего):</p>

  <ol>

   <li><p>Если <var>region</var> не имеет <a href="#hit-region's-control" title="hit
   region's control">control</a>, не возвращать ничего и прервать эти шаги.</p></li>

   <li><p>Сделать <var>control</var> <a href="#hit-region's-control" title="hit region's
   control">элементом управления</a> области <var>region</var>.</p></li>

   <li><p>Если <var>control</var> не наследник <var>ancestor</var>, то не выдавать ничего и прервать эти шаги.</p></li>

   <li><p>В другом случае, возвратить <var>control</var>.</p></li>

  </ol>

  <p><dfn id="the-region-for-a-pixel">Область для пикселя</dfn> <var>pixel</var> на битмапе
  <var>bitmap</var> это значение выдаваемое следующим алгоритмом (который может вернуть
  <a href="#hit-region">hit region</a> или ничего):</p>

  <ol>

   <li><p>Сделать <var>list</var> <a href="#hit-region-list">списком hit областей</a> связанным с <var>bitmap</var>.</p></li>

   <li><p>Если есть <a href="#hit-region">hit область</a> в <var>list</var> чей <a href="#hit-region's-path">путь</a> содержит <var>pixel</var>,
   то возвратить эту <a href="#hit-region">hit область</a> и прервать эти шаги.</p></li>

   <li><p>В другом случае, не возвращать ничего.</p></li>

  </ol>
<!--
  <p>To <dfn>clear regions that cover the pixels</dfn> <var
  title="">pixels</var> on a bitmap <var>bitmap</var>, the user agent must run the following
  steps:</p>

  <ol>

   <li><p>Let <var>list</var> be the <span>hit region
   list</span> associated with <var>bitmap</var>.</p></li>

   <li><p>Remove all pixels in <var>pixels</var> from the
   <span title="hit region's set of pixels">set of pixels</span> of
   each <span>hit region</span> in <var>list</var>.</p></li>



  </ol>
  -->



  <hr>

  <p>Когда вызван метод <dfn id="dom-context-2d-addhitregion" title="dom-context-2d-addHitRegion"><code>addHitRegion()</code></dfn>, агент пользователя должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать <var>arguments</var> объектом для аргументов метода.</p></li>

   <li><p>Сделать <var title="dom-HitRegionOptions-path">source path</var> <a href="#current-default-path">текущим путем по умолчанию</a> объекта <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>.</p></li>

   <li><p>Сделать <var>specified pixels</var> пикселями внутри <var>source path</var>.

   </p></li><li><p>Удалить из <var>specified pixels</var> все пиксели которые не содержатся внутри <a href='#clipping-region'>clipping
   region</a>.</p></li>

   <li><p>Если <code title="dom-HitRegionOptions-id">id</code> объекта <var>arguments</var> является пустой строкой, сделать его null.</p></li>

   <li><p>Если <code title="dom-HitRegionOptions-id">id</code> объекта <var>arguments</var> является null и <code title="dom-HitRegionOptions-control">control</code> объекта <var>arguments</var> является null,
   выдать исключение <code>NotSupportedError</code> и прервать эти шаги.</p></li>

   <li><p>Если <code title="dom-HitRegionOptions-id">id</code> объекта <var>arguments</var> является null, то сделать <var>previous region for this ID</var> <a href="#the-region-identified-by-the-id">областью идентифицируемой ID</a> заданным значением <code title="dom-HitRegionOptions-id">id</code> для этого
   <code>canvas</code>. Если <code title="dom-HitRegionOptions-id">id</code> является null или такой области сейчас нет, сделать <var>previous region for this ID</var> равным null.</p></li>

   <li>
    <p>Если <var>specified pixels</var> не содержат пикселей, выдать исключение
    <code>NotSupportedError</code> и прервать эти шаги.</p>

   </li>


   <li>

    <p>Сделать <var>region</var> созданной <a href="#hit-region">hit
    областью</a>, с ее информацией настроенной как:</p>

    <dl>

     <dt><a href="#hit-region's-path">Путь hit области</a>

     </dt><dd><p><var>specified pixels</var>.


     </p></dd><dt><a href="#hit-region's-bounding-circumference">Ограничивающая окружность hit области</a>

     </dt><dd><p>Определенная агентом пользователя форма которая оборачивает пиксели содержащиеся в <var>source path</var>. (В простом случае, это может быть просто ограничивающий прямоугольник; эта спецификация позволяет ему иметь любую форму, чтобы поддерживать разные интерфейсы.)

     </p></dd><dt><a href="#hit-region's-id">ID hit области</a>

     </dt><dd><p>Если <code title="dom-HitRegionOptions-id">id</code> объекта <var>arguments</var> не является null: то значение <code title="dom-HitRegionOptions-id">id</code>. В другом случае, <var>region</var> не имеет <a href="#hit-region's-id" title="hit region's id">id</a>.

     </p></dd><dt><a href="#hit-region's-control">Hit region's control</a>

     </dt><dd><p>Если <code title="dom-HitRegionOptions-control">control</code> объекта <var>arguments</var> не является
     null: то значение <code title="dom-HitRegionOptions-control">control</code>.
     В другом случае, <var>region</var> не имеет <a href="#hit-region's-control" title="hit
     region's control">control</a>.

    </p></dd></dl>

   </li>

   <li><p>Если <code title="dom-HitRegionOptions-control">control</code> объекта <var>arguments</var> не является
   null, то сделать <var>previous region for the control</var>
   <a href="#the-region-representing-the-control">областью представляющей control</a> заданным с
   <code title="dom-HitRegionOptions-control">control</code> значением этого <code>canvas</code> элемента. Если <code title="dom-HitRegionOptions-control">control</code> является null
   или такой области сейчас нет, сделать <var>previous
   region for the control</var> равным null.</p></li>


   <li><p>Если есть <var>previous region with this
   control</var>, удалить его с <a href="#hit-region-list">списка hit областей</a>  <code>canvas</code>.</p></li>

   <li><p>Если <code title="dom-HitRegionOptions-control">
   control</code> объекта arguments не является null, <a href='#inform'>проинформировать пользователя</a> о расположении области
   представляющей <code title="dom-HitRegionOptions-control">control</code>
   заданный с помощью значения control для этого элемента <code>canvas</code>.
   Полное местонахождение соответствующего резервного элемента,
   относящегося к <code title="dom-HitRegionOptions-control">control</code>,
   передается к доступному API, если поддерживается.</p></li>

   <li><p>Если есть <var>previous region with this
   ID</var>, удалить его со <a href="#hit-region-list">списка hit областей</a> <code>canvas</code> .</p></li>

   <li><p>Добавить <var>region</var> на <a href="#hit-region-list">список hit областей</a> <code>canvas</code>.</p></li>

  </ol>

  <p>Когда вызван метод <dfn id="dom-context-2d-removehitregion" title="dom-context-2d-removeHitRegion"><code>removeHitRegion()</code></dfn>, агент пользователя должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать <var>region</var> <a href="#the-region-identified-by-the-id">областью идентифицируемой с помощью ID</a> заданным с помощью аргумента метода в этом
   <code>canvas</code> элементе, если есть. Если нет такой области на данный момент, прервать эти шаги.</p>

   <p class="note"> Если аргумент метода это пустая строка, то ни одна область не будет соответствовать.</p>

   </li><li><p>Удалить <var>region</var> со <a href="#hit-region-list">списка hit областей</a> элемента <code>canvas</code>.</p></li>



  </ol>

    <p>Когда вызван метод <dfn id="dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions"><code>clearHitRegions()</code></dfn>, агент пользователя должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Удалить все <var>hit regions</var>
   с элемента <code>canvas</code> и очистить его <a href="#hit-region-list">список hit областей</a>. Если нет областей на данный момент, прервать эти шаги.</p></li>

  </ol>

  <p class="note">Вызов <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code> это способ очистить все или некоторые области. Вызов clearHitRegions()
  удаляет все hit области и очищает список hit областей. <a href="#hit-region-list">Список hit областей</a> сбрасывается также когда визуализируемый контекст сброшен.
  Например, когда объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> привязывается или отвязывается от <code>canvas</code>, или размеры битмапа меняются.</p>


  </div>

  <hr>

  <p>Интерфейс <code>MouseEvent</code> расширен для поддержки hit областей:</p>

  <pre class="idl">partial interface <span>MouseEvent</span> {
  readonly attribute DOMString? <a href="#dom-mouseevent-region" title="dom-MouseEvent-region">region</a>;
};

partial dictionary <span>MouseEventInit</span> {
  DOMString? region;
};</pre>

  <dl class="domintro">

   <dt><var>event</var> . <code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code></dt>

   <dd>

    <p>Если мышь была над <a href="#hit-region">hit областью</a>, то возвращает <a href="#hit-region's-id">ID hit области</a>, если она имеет его.</p>

    <p>В другом случае, возвращает null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-mouseevent-region" title="dom-MouseEvent-region"><code>region</code></dfn>
  на объектах <code>MouseEvent</code> должен возвратить значение на котором был инициализирован. Когда объект создан, этот атрибут должен быть установлен к null.</p>

  <p>Когда <code>MouseEvent</code> генерируется на элементе
  <code>canvas</code> с помощью агента пользователя в ответ на
наведение мышки, если элемент <code>canvas</code> имеет список hit областей,
  агент пользователя должен вместо этого выполнить следующие шаги. Если здесь указано <i>действовать в обычном режиме</i>, это означает что событие должно быть сгенерировано как если бы эти требования не были применены.</p>

  <ol>

   <li><p>Если указательное устройство (мышь или др.) не указывает на пиксель на холсте, <i>действовать в обычном режиме</i> и прервать эти шаги.</p></li>

   <li><p>Если элемент canvas не имеет списка hit областей, действовать в обычном режиме и прервать эти шаги.</p></li>

   <li><p>Сделать пиксель указанным с помощью указательного устройства.</p></li>

   <li><p>Сделать область hit областью для пикселя <var>pixel</var> на этом битмапе элемента canvas.</p></li>

   <li><p>Сделать <var>id</var> значением <a href="#hit-region's-id" title="hit region's ID">ID</a> области <var>region</var>, если есть.</p></li>

   <li><p>Если есть <var>id</var>, то установить атрибут объекта события <code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code> к <var>id</var>.</p></li>

   <li><p>Отправить событие, но с обновлением объекта события как задано предыдущими шагами.</p></li>

  </ol>

  <p class="note">Такой подход упрощает обработку событий, <a href="#dom-mouseevent-region">не перенацеливая событие</a>. Событие отправляется в обычном режиме как только атрибут event.region установлен к активному ID hit области.  Событие полученное с помощью элемента canvas позволяет автору определять поведение события.</p>
  <hr>

  <p>Агентам пользователя рекомендуется использовать информацию, предоставленную в <a href="#hit-region-list">списке hit областей</a> элемента <code>canvas</code>, для улучшения доступности элементов <code>canvas</code>.</p>

  <p>Каждая <a href="#hit-region">hit область</a> должна быть обработана в эквиваленте узла в виртуальном дереве DOM с корнем на
  <code>canvas</code> элементе. Иерархия этого виртуального дерева DOM
  должна соответствовать иерархии <a href="#hit-region" title="hit region">hit
  областей</a>. <!--, as described by the <span title="hit region's
  parent">parent</span> of each region. Regions without a <span
  title="hit region's parent">parent</span> must be treated as
  children of the <code>canvas</code> element for the purpose of this
  virtual DOM tree.--> Для каждого узла в таком дереве DOM, <a href="#hit-region's-bounding-circumference">ограничивающая окружность hit области</a> задает область экрана для использования при представлении узла (если необходимо).</p>

  <p>Семантика <a href="#hit-region">hit области</a> для целей
  этого виртуального дерева DOM это <a href="#hit-region's-control">control hit области</a>, если имеется.<!--, or else of a non-interactive element
  whose ARIA role, if any, is that given by the <span>hit region's
  ARIA role</span>, and whose textual representation, if any, is given
  by the <span>hit region's label</span>.--></p>

  <p>Для целей доступных инструментов, когда элемент <var>C</var> является потомком элемента <code>canvas</code>
  и есть <a href="#the-region-representing-the-control" title="the region representing the control">область представляющая control</a> <var>C</var>, то позиция элемента относительно документа должна быть представлена как если бы эта область была в виртуальном дереве DOM элемента
  <code>canvas</code>.</p>

  <hr>



  </div>


  <h2 id="pixel-manipulation"><span class="secno">14 </span><dfn>Пиксельная манипуляция</dfn></h2>

  <dl class="domintro">

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var>sw</var>, <var>sh</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#imagedata">ImageData</a></code> с заданными
    размерами в пикселях CSS (которые могут отображаться в другом количестве фактических пикселей устройства). Все пиксели в возвращаемом объекте — прозрачные черные.</p>

   </dd>

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var>imagedata</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#imagedata">ImageData</a></code> с теми же размерами как в аргументе. Все пиксели в возвращаемом объекте — прозрачные черные.</p>

   </dd>

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData</a></code>(<var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#imagedata">ImageData</a></code> содержащий данные изображения для заданного прямоугольника на холсте.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если ширина или высота равны нулю.</p>

    <p>Данные будут возвращены с одним пикселем данных изображения для каждой единицы координатного пространства на холсте (игнорируя преобразования).</p>

   </dd>

   <dt><var>imagedata</var> . <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code></dt>
   <dt><var>imagedata</var> . <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code></dt>

   <dd>

    <p>Возвращает фактические размеры данных в объекте <code><a href="#imagedata">ImageData</a></code>, в пикселях устройства.</p>

   </dd>

   <dt><var>imagedata</var> . <code title="dom-imagedata-data"><a href="#dom-imagedata-data">data</a></code></dt>

   <dd>

    <p>Возвращает одномерный массив содержащий данные в порядке RGBA, такие как целые числа в диапазоне от 0 до 255.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData</a></code>(<var>imagedata</var>, <var>dx</var>, <var>dy</var> [, <var>dirtyX</var>, <var>dirtyY</var>, <var>dirtyWidth</var>, <var>dirtyHeight</var> ])</dt>

   <dd>

    <p>Рисует данные с заданного объекта <code><a href="#imagedata">ImageData</a></code> на холст. Если предоставлен dirty прямоугольник, рисуются только пиксели с этого прямоугольника.</p>

    <p>Атрибуты <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>
    и <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>, также как и атрибуты теней, игнорируются для
    целей вызова этого метода; пиксели на холсте заменяются оптом, без композиции, альфа-смешивания, без теней и т.д.</p>

    <p>Выдает исключение <code>NotSupportedError</code> если какой-то из этих аргументов не конечное число.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-createimagedata" title="dom-context-2d-createImageData"><code>createImageData()</code></dfn>
  используется для создания экземпляров новых пустых объектов <code><a href="#imagedata">ImageData</a></code>. Когда метод вызван с двумя аргументами <var>sw</var> и <var>sh</var>, он должен вернуть объект
  <code><a href="#imagedata">ImageData</a></code> представляющий прямоугольник с шириной
  в пикселях CSS равной абсолютной величине <var>sw</var> и высотой в пикселях CSS равной абсолютной величине <var>sh</var>. Когда вызван только с аргументом <var>imagedata</var>, он должен возвратить объект
  <code><a href="#imagedata">ImageData</a></code> представляющий прямоугольник с
  теми же размерами что и объект <code><a href="#imagedata">ImageData</a></code>
  как передано аргументом. Возвращенный объект <code><a href="#imagedata">ImageData</a></code> должен быть заполнен прозрачным черным.</p>

  <p>Метод <dfn id="dom-context-2d-getimagedata" title="dom-context-2d-getImageData"><code>getImageData(<var>sx</var>, <var>sy</var>, <var>sw</var>,
  <var>sh</var>)</code></dfn> должен,
<!--ADD-TOPIC:Security-->
  если флаг битмап элемента <code>canvas</code> <i>origin-clean</i> установлен ложный, выдать исключение <code>SecurityError</code>; в другом случае, должен
<!--REMOVE-TOPIC:Security-->
  возвратить объект <code><a href="#imagedata">ImageData</a></code> представляющий
  базовые данные пикселей для области холста, обозначаемой
  прямоугольником, чьи углы в четырех точках (<var>sx</var>,
  <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <span><var>sy</var>+<var>sh</var></span>),
  (<var>sx</var>, <span><var>sy</var>+<var>sh</var></span>), в координатном пространстве canvas. Пиксели за пределами холста должны быть возвращены как прозрачный черный. Пиксели возвращаются как не предварительно умноженные альфа значения.</p>

  <p>Если любые аргументы <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData()</a></code> или <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code>
  бесконечны или NaN, метод должен выдать исключение
  <code>NotSupportedError</code>. Если один из аргументов <var>sw</var> или <var>sh</var> равен нолю,
  метод должен выдать исключение <code>IndexSizeError</code>.</p>

  <p>Объекты <code><a href="#imagedata">ImageData</a></code> должны быть инициализированы так, чтобы их атрибут
  <dfn id="dom-imagedata-width" title="dom-imagedata-width"><code>width</code></dfn>
  был установлен <var>w</var>, количество пикселей в строке устройства в данных изображения, их атрибут <dfn id="dom-imagedata-height" title="dom-imagedata-height"><code>height</code></dfn> был установлен к <var>h</var>, количество строк в данных изображения,
  и их атрибут <dfn id="dom-imagedata-data" title="dom-imagedata-data"><code>data</code></dfn>
  инициализирован к объекту <code>Uint8ClampedArray</code>.
  Объект <code>Uint8ClampedArray</code> должен использовать <a href="#canvas-pixel-arraybuffer">Canvas
  Pixel <code>ArrayBuffer</code></a> для его хранения, и должен иметь
  нулевое начальное смещение, и длину равную длине его хранилища
  в байтах. <a href="#canvas-pixel-arraybuffer">Canvas Pixel <code>ArrayBuffer</code></a>
  должен содержать данные изображения. Как минимум одна сумма пикселя данных изображения должна быть возвращена. <a href="#refsTYPEDARRAY">[TYPEDARRAY]</a></p>

  <p><dfn id="canvas-pixel-arraybuffer">Canvas Pixel <code>ArrayBuffer</code></dfn> это
  <code>ArrayBuffer</code>, данные которого представлены в
  порядке справа-налево, построчно сверху вниз, начиная с верха слева, с каждым красным, зеленым, синим и альфа-компонентом пикселя, приведенными в этом порядке для каждого пикселя. Каждый компонент каждого пикселя устройства
представленный в этом массиве должен находиться в диапазоне 0..255, представляя 8-битное значение для этого компонента. Компонентам должны быть назначены последовательные индексы начиная с 0 для верхнего левого красного компонента пикселя. <a href="#refsTYPEDARRAY">[TYPEDARRAY]</a></p>

  <p>Метод <dfn id="dom-context-2d-putimagedata" title="dom-context-2d-putImageData"><code>putImageData(<var>imagedata</var>, <var>dx</var>, <var>dy</var>, <var>dirtyX</var>, <var>dirtyY</var>, <var>dirtyWidth</var>, <var>dirtyHeight</var>)</code></dfn> записывает данные со структур
  <code><a href="#imagedata">ImageData</a></code> обратно на холст.</p>

  <p>Если какой-то из аргументов в методе бесконечен или NaN, метод должен выдать исключение <code>NotSupportedError</code>.</p>

  <p>Когда последние четыре аргументе опущены, они должны считаться со значениями 0, 0 — <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> структуры <var>imagedata</var> и <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> структуры <var>imagedata</var>, соответственно.</p>

  <p>Когда вызван с аргументами, которые не выдают исключение, метод <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> должен действовать следующим образом:</p>

  <ol>

   <li>

    <p>Сделать <var>dx<sub>device</sub></var> x-координатой
    пикселей устройства,
    соответствующей <var>dx</var> координатам в координатном пространстве canvas.</p>

    <p>Сделать <var>dy<sub>device</sub></var> y-координатой
    пикселей устройства,
   соответствующей  <var>dy</var> координатам в координатном пространстве canvas.</p>

   </li>

   <li>

    <p>Если значение <var>dirtyWidth</var> негативное, сделать <var>dirtyX</var> <span><var>dirtyX</var>+<var>dirtyWidth</var></span> и сделать <var>dirtyWidth</var> равным абсолютной величине
    <var>dirtyWidth</var>.</p>

    <p>Если значение <var>dirtyHeight</var> негативное, сделать <var>dirtyY</var> <span><var>dirtyY</var>+<var>dirtyHeight</var></span> и сделать <var>dirtyHeight</var> равным абсолютной величине
    <var>dirtyHeight</var>.</p>

   </li>

   <li>

    <p>Если значение <var>dirtyX</var> негативное, сделать <var>dirtyWidth</var> <span><var>dirtyWidth</var>+<var>dirtyX</var></span> и
    сделать <var>dirtyX</var> равным нулю.</p>

    <p>Если значение <var>dirtyY</var> негативное, сделать <var>dirtyHeight</var> <span><var>dirtyHeight</var>+<var>dirtyY</var></span> и
    сделать <var>dirtyY</var> равным нулю.</p>

   </li>

   <li>

    <p>Если <span><var>dirtyX</var>+<var>dirtyWidth</var></span> больше чем атрибут <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> аргумента <var>imagedata</var>, сделать <var>dirtyWidth</var> значением атрибута <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> минус значение <var>dirtyX</var>.</p>

    <p>Если <span><var>dirtyY</var>+<var>dirtyHeight</var></span> больше чем атрибут <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> аргумента <var>imagedata</var>, сделать <var>dirtyHeight</var> значением атрибута <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> минус значение <var>dirtyY</var>.</p>

   </li>

   <li>

    <p>Если после этих изменений одно из <var>dirtyWidth</var>
    или <var>dirtyHeight</var> равно нолю или меньше ноля, остановить эти шаги без влияния на холст.</p>

   </li>

   <li><p>В другом случае, для всех целых значений <var>x</var>
   и <var>y</var>, где <span><var>dirtyX</var> ≤ <var>x</var> &lt; <span><var>dirtyX</var>+<var>dirtyWidth</var></span></span>
   и <span><var>dirtyY</var> ≤ <var>y</var> &lt; <span><var>dirtyY</var>+<var>dirtyHeight</var></span></span>, копировать четыре канала пикселя с координатами (<var>x</var>, <var>y</var>) из данных структуры <var>imagedata</var>
   на пиксель с координатами (<span><var>dx<sub>device</sub></var>+<var>x</var></span>,
   <span><var>dy<sub>device</sub></var>+<var>y</var></span>) базовых данных пикселей canvas.</p></li>

  </ol>

  <p>Текущий путь, <a href="#transformations" title="dom-context-2d-transformation">матрица преобразования</a>,
  <a href="#shadows" title="shadows">атрибуты теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition
  оператор</a> не должны влиять на методы <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> и <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code>.</p>
<hr>
  </div>

  <div class="example">

   <p>В следующем примере, скрипт генерирует объект
   <code><a href="#imagedata">ImageData</a></code> таким образом, что он может рисовать на нем.</p>

   <pre>// canvas is a reference to a &lt;canvas&gt; element
var context = canvas.getContext('2d');

// create a blank slate
var data = context.createImageData(canvas.width, canvas.height);

// create some plasma
FillPlasma(data, 'green'); // green plasma

// add a cloud to the plasma
AddCloud(data, data.width/2, data.height/2); // put a cloud in the middle

// paint the plasma+cloud on the canvas
context.putImageData(data, 0, 0);

// support methods
function FillPlasma(data, color) { ... }
function AddCloud(data, x, y) { ... }</pre>

  </div>

  <div class="example">

   <p>Ниже приведен пример использования <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> и <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> для реализации фильтра обнаружения края.</p>

   <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Edge detection demo&lt;/title&gt;
  &lt;script&gt;
   var image = new Image();
   function init() {
     image.onload = demo;
     image.src = "image.jpeg";
   }
   function demo() {
     var canvas = document.getElementsByTagName('canvas')[0];
     var context = canvas.getContext('2d');

     // draw the image onto the canvas
     context.drawImage(image, 0, 0);

     // get the image data to manipulate
     var input = context.getImageData(0, 0, canvas.width, canvas.height);

     // get an empty slate to put the data into
     var output = context.createImageData(canvas.width, canvas.height);

     // alias some variables for convenience
     // notice that we are using input.width and input.height here
     // as they might not be the same as canvas.width and canvas.height
     // (in particular, they might be different on high-res displays)
     var w = input.width, h = input.height;
     var inputData = input.data;
     var outputData = output.data;

     // edge detection
     for (var y = 1; y &lt; h - 1; y += 1) {
       for (var x = 1; x &lt; w - 1; x += 1) {
         for (var c = 0; c &lt; 3; c += 1) {
           var i = (y*w + x)*4 + c;
           outputData[i] = 127 + -inputData[i - w*4 - 4] -   inputData[i - w*4] - inputData[i - w*4 + 4] +
                                 -inputData[i - 4]       + 8*inputData[i]       - inputData[i + 4] +
                                 -inputData[i + w*4 - 4] -   inputData[i + w*4] - inputData[i + w*4 + 4];
         }
         outputData[(y*w + x)*4 + 3] = 255; // alpha
       }
     }

     // put the image data back after manipulation
     context.putImageData(output, 0, 0);
   }
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body onload="init()"&gt;
  &lt;canvas&gt;&lt;/canvas&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>

  </div>




  <h2 id="compositing"><span class="secno">15 </span>Композиция</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущее альфа значение применяемое к операциям визуализиции.</p>

    <p>Может быть установлен, чтобы изменить альфа значение. Значения вне диапазона 0.0 .. 1.0 игнорируются.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущую операцию композиции, из приведенного ниже списка.</p>

    <p>Может быть установлен, чтобы изменить операцию композиции. Неизвестные значения игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Все операции рисования затрагиваются global compositing
  атрибутами, <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> и <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>.</p>

  <!-- conformance criteria for painting are described in the "drawing
  model" section below -->

  <p>Атрибут <dfn id="dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha"><code>globalAlpha</code></dfn>
  задает альфа значение которое применяется к формам и изображениям
  перед тем как они компонуются на холст. Значение должно быть в диапазоне от 0.0 (полностью прозрачный) до 1.0 (без прозрачности). При попытках установить атрибут к значению вне диапазона, включая бесконечность и NaN, атрибут должен вернуться к предыдущему значению. Когда контекст создан, атрибут <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> должен изначально иметь значение 1.0.</p>

  <p>Атрибут <dfn id="dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation"><code>globalCompositeOperation</code></dfn>
  устанавливает как формы и изображения рисуются на существующий битмап, как только они приняли <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> и текущую матрицу преобразования. Он должен быть установлен к значению из следующего списка. В описании ниже, исходное изображение, <var>A</var>, это визуализируемые форма или изображение,
  и конечное изображение, <var>B</var>, это текущее состояние битмапа.</p>

  </div>

  <dl>

   <dt><dfn id="gcop-source-atop" title="gcop-source-atop"><code>source-atop</code></dfn></dt>

   <dd><var>A</var> сверху <var>B</var>. <span class="note">Отображается исходное изображение везде где оба изображения непрозрачны. Отображается конечное изображение везде где конечное изображение непрозрачное, но исходное изображение прозрачное. Отображается прозрачность в других местах.</span></dd>

   <dt><dfn id="gcop-source-in" title="gcop-source-in"><code>source-in</code></dfn></dt>

   <dd><var>A</var> в <var>B</var>. <span class="note">Отображается исходное изображение везде где оба изображения непрозрачны. Отображается прозрачность в других местах.</span></dd>

   <dt><dfn id="gcop-source-out" title="gcop-source-out"><code>source-out</code></dfn></dt>

   <dd><var>A</var> вне <var>B</var>. <span class="note">Отображается исходное изображение везде где исходное изображение непрозрачно и конечное изображение прозрачно. Отображается прозрачность в других местах.</span></dd>

   <dt><dfn id="gcop-source-over" title="gcop-source-over"><code>source-over</code></dfn> (по умолчанию)</dt>

   <dd><var>A</var> над <var>B</var>. <span class="note">Отображается исходное изображение везде где исходное изображение непрозрачно. Отображается конечное изображение в других местах.</span></dd>


   <dt><dfn id="gcop-destination-atop" title="gcop-destination-atop"><code>destination-atop</code></dfn></dt>

   <dd><var>B</var> сверху <var>A</var>. <span class="note">То же что и <code title="gcop-source-atop"><a href="#gcop-source-atop">source-atop</a></code>, но используя конечное изображение вместо исходного изображения и наоборот.</span></dd>

   <dt><dfn id="gcop-destination-in" title="gcop-destination-in"><code>destination-in</code></dfn></dt>

   <dd><var>B</var> в <var>A</var>. <span class="note">То же что и <code title="gcop-source-in"><a href="#gcop-source-in">source-in</a></code>, но используя конечное изображение вместо исходного и наоборот.</span></dd>

   <dt><dfn id="gcop-destination-out" title="gcop-destination-out"><code>destination-out</code></dfn></dt>

   <dd><var>B</var> вне <var>A</var>. <span class="note">То же что и <code title="gcop-source-out"><a href="#gcop-source-out">source-out</a></code>, но используя конечное изображение вместо исходного и наоборот.</span></dd>

   <dt><dfn id="gcop-destination-over" title="gcop-destination-over"><code>destination-over</code></dfn></dt>

   <dd><var>B</var> над <var>A</var>. <span class="note">То же что и <code title="gcop-source-over"><a href="#gcop-source-over">source-over</a></code>, но используя конечное изображение вместо исходного и наоборот.</span></dd>


<!-- no clear definition of this operator (doesn't correspond to a PorterDuff operator)
   <dt><dfn title="gcop-darker"><code>darker</code></dfn></dt>

   <dd><span class="note">Display the sum of the source image and destination image,
   with color values approaching 0 as a limit.</span></dd>
-->

   <dt><dfn id="gcop-lighter" title="gcop-lighter"><code>lighter</code></dfn></dt>

   <dd><var>A</var> плюс <var>B</var>. <span class="note">Отображается сумма исходного и конечного изображений, со значениями цвета до 255 (100%) как лимит.</span></dd>


   <dt><dfn id="gcop-copy" title="gcop-copy"><code>copy</code></dfn></dt>

   <dd><var>A</var> (<var>B</var> игнорируется). <span class="note">Отображать исходное изображение вместо конечного изображения.</span></dd>


   <dt><dfn id="gcop-xor" title="gcop-xor"><code>xor</code></dfn></dt>

   <dd><var>A</var> xor <var>B</var>. <span class="note">Исключается OR
   исходного и конечного изображений.</span></dd>


   <dt class="impl"><code><var>vendorName</var>-<var>operationName</var></code></dt>

   <dd class="impl">Заданные вендором расширения этого списка должны использовать этот синтаксис.</dd>

  </dl>

  <div class="impl">

  <p>Операторы из списка выше должны быть обработаны как описано
  оператором данным в начале их описания
  (например, <var>A</var> над <var>B</var>). Они должны быть применены как часть <a href="#drawing-model">модели рисования</a>, при которой также применяется
  <a href="#clipping-region">clipping region</a>. (Без clipping
  region, эти операторы действуют на всем битмапе с каждой операцией.) <a href="#refsPORTERDUFF">[PORTERDUFF]</a></p>

  <p>Эти значения чувствительны к регистру — они должны использоваться точно как показано. Агенты пользователей должны не распознавать значений, которые не <span>чувствительны к регистру</span> для каждого значения из данных выше.</p>

  <p>При настройке, если агент пользователя не распознает заданное значение, оно игнорируется, оставляя значение <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> не затронутым.</p>

  <p>Когда контекст создан, атрибут <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> должен изначально иметь значение
  <code>source-over</code>.</p>

  </div>




  <h2 id="shadows"><span class="secno">16 </span><dfn>Тени</dfn></h2>

  <p>Все операции рисования затрагиваются четырьмя глобальными атрибутами теней.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий цвет тени.</p>

    <p>Может быть настроен, чтобы изменить цвет тени. Значения которые не читаются как цвета CSS, игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> [ = <var>value</var> ]</dt>
   <dt><var>context</var> . <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущее смещение тени.</p>

    <p>Может быть настроен, чтобы изменить смешение тени. Значения отличные от конечных чисел игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий уровень размытия применяемый к теням.</p>

    <p>Может быть настроен, чтобы изменить уровень размытия. Значения (конечные числа) больше ноля или равные ему, игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-context-2d-shadowcolor" title="dom-context-2d-shadowColor"><code>shadowColor</code></dfn> устанавливает цвет тени.</p>

  <p>Когда контекст создан, атрибут <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> изначально должен быть полностью прозрачным черным.</p>

  <p>При получении, должна быть возвращена <a href="#serialization-of-a-color" title="serialization of a
  color">последовательность цвета</a>.</p>

  <p>При настройке, новое значение должно <span>читаться как значение CSS
  &lt;color&gt;</span>. Если значение не может читаться как значение CSS &lt;color&gt;, то оно игнорируется, и атрибут должен возвратиться к предыдущему значению. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p>Атрибуты <dfn id="dom-context-2d-shadowoffsetx" title="dom-context-2d-shadowOffsetX"><code>shadowOffsetX</code></dfn>
  и <dfn id="dom-context-2d-shadowoffsety" title="dom-context-2d-shadowOffsetY"><code>shadowOffsetY</code></dfn>
  должны указать расстояние смещения тени в положительном горизонтальном и вертикальном расстоянии соответственно. Значения в координатном пространстве единиц. Они не затрагиваются текущей матрицей преобразования.</p>

  <p>Когда контекст создан, атрибуты смещения тени должны изначально иметь значение <code>0</code>.</p>

  <p>При получении, они должны вернуть текущее значение. При настройке, значение должно меняться на новое значение, кроме случая если оно бесконечное или NaN, тогда новое значение игнорируется.</p>

  <p>Атрибут <dfn id="dom-context-2d-shadowblur" title="dom-context-2d-shadowBlur"><code>shadowBlur</code></dfn>
  определяет уровень эффекта размытия. (Единицы не связаны с координатным пространством и не затрагиваются текущей матрицей преобразования.)</p>

  <p>Когда контекст создан, атрибут <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> должен изначально иметь значение <code>0</code>.</p>

  <p>При получении, атрибут должен возвращать текущее значение. При настройке он меняется на новое значение, кроме случая если оно негативное, бесконечное или NaN, тогда новое значение игнорируется.</p>

  <p><dfn id="when-shadows-are-drawn" title="when shadows are drawn">Тени рисуются только если</dfn> альфа компонент цвета <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> не нулевой и хотя бы один из <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>, <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> или <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> не нулевой.</p>

  <p class="critical">Вполне вероятно, что это изменится: разработчики браузеров выразили заинтересованность в изменении модели обработки для теней таким образом, что они рисуются только когда оператор композиции имеет значение "source-over" (по умолчанию). <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-May/thread.html#31457" target="_blank" rel="nofollow">Прочитать больше...</a></p>

  <p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, они должны быть визуализированы следующим образом:</p>

  <ol>

   <li> <p>Сделать <var>A</var> бесконечным прозрачным черным
   битмапом с исходным изображением для которого созданная тень была визуализирована.</p> </li>

   <li> <p>Сделать <var>B</var> бесконечным прозрачным черным битмапом, чье координатное пространство и происхождение идентичны к <var>A</var>.</p> </li>

   <li> <p>Копировать альфа-канал <var>A</var> на <var>B</var>, смещение <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> в положительном направлении <var>x</var>, и <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> в положительном направлении <var>y</var>.</p> </li>

   <li> <p>Если <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> больше чем 0:</p>

    <ol>

     <li> <p>Сделать <var>σ</var> половиной значения от
     <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>.</p></li>

     <li> <p>Выполнить 2D размытие по Гауссу на <var>B</var>,
     используя <var>σ</var> как стандартное отклонение.</p>
     <!-- wish i could find a reference for this --> </li>

    </ol>

    <p>Агенты пользователя могут ограничивать значения <var>σ</var> для
    реализации собственного максимального значения, чтоб избежать
    аппаратных ограничений во время операции размытия по Гауссу.</p>

   </li>

   <li> <p>Установить красный, зеленый и синий компоненты каждого пикселя в
   <var>B</var> к красному, зеленому и синему компонентам
   (соответственно) цвета в <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p> </li>

   <li> <p>Умножить альфа компонент каждого пикселя в <var>B</var> на альфа компонент цвета <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p> </li>

   <li> <p>Тень на битмапе <var>B</var> и она визуализируется как часть <a href="#drawing-model">модели рисования</a> описанной ниже.</p> </li>

  </ol>

  </div>

  <p>Если текущая операция композиции это <code title="gcop-copy"><a href="#gcop-copy">copy</a></code>, тени не будут отображаться
  (т.к. фигура перекроет тень).</p>



  <div class="impl">

  <h2 id="drawing-model"><span class="secno">17 </span><dfn>Модель рисования</dfn></h2>

  <p>Когда форма или изображение нарисованы, агенты пользователей должны следовать этим шагам в указанном порядке (или действовать как будто следуют):</p>

  <ol>

   <li><p>Визуализировать форму или изображение на бесконечно прозрачный черный битмап, создавая изображение <var>A</var>, как описано в предыдущих разделах. Для фигур текущее заполнение, обводки и стили должны быть выполнены, и сглаживание также должно быть подвергнуто текущей матрице преобразования.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, визуализировать тень с изображения <var>A</var>, используя текущие стили изображения, создавая изображение <var>B</var>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, умножить альфа-компонент каждого пикселя в <var>B</var> с помощью <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, добавить <var>B</var> в пределах <a href="#clipping-region">clipping region</a> над текущим битмапом холста с помощью current composition operator.</p></li>

   <li><p>Умножить альфа-компонент каждого пикселя в <var>A</var> с помощью <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p>Добавить <var>A</var> в пределах <a href="#clipping-region">clipping
   region</a> над текущим битмапом холста с помощью current composition operator.</p></li>

  </ol>

  </div>


  <h2 id="best-practices"><span class="secno">18 </span>Советы</h2>

  <p><i>Этот раздел не является нормативным.</i></p>
  <p>Когда холст является интерактивным, авторы должны включать фокусируемые элементы в содержание резерва элемента, соответствующие каждой фокусируемой части холста.</p>

  <p>Для того чтобы указать какая часть холста сейчас сфокусирована, авторы должны использовать метод <code title="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded()</a></code>, передавая ему элемент для которого рисуется контур. Этот метод рисует контур только если элемент сфокусирован, так что он может просто быть вызван при рисовании элемента, без проверки является ли элемент сфокусированным или нет.</p>
<hr>

  <p>Авторы должны избегать реализации элементов редактирования текста при использовании
  <code>canvas</code>, потому что это имеет множество минусов: придется переписывать всё начиная от движения знака вставки до нативных возможностей типа копировать-вставить.</p>

  <p>Это огромный объем работы, поэтому авторы должны быть сильно мотивированы не делать этого. Вместо этого можно использовать элемент
  <code>input</code>, элемент <code>textarea</code> или атрибут <code title="attr-contenteditable">contenteditable</code>.</p>


  <h2 id="examples"><span class="secno">19 </span>Примеры</h2>

  <p><i>Этот раздел не является нормативным.</i></p>
  <div class="example">

  <p>Ниже приведен пример кода, который использует canvas, чтобы нарисовать <a href="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIEhUTUw%2BDQo8aHRtbCBsYW5nPSJlbiI%2BDQogPGhlYWQ%2BDQogIDx0aXRsZT5QcmV0dHkgR2xvd2luZyBMaW5lczwvdGl0bGU%2BDQogPC9oZWFkPg0KIDxib2R5Pg0KPGNhbnZhcyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQ1MCI%2BPC9jYW52YXM%2BDQo8c2NyaXB0Pg0KDQogdmFyIGNvbnRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF0uZ2V0Q29udGV4dCgnMmQnKTsNCg0KIHZhciBsYXN0WCA9IGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKTsNCiB2YXIgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KIHZhciBodWUgPSAwOw0KIGZ1bmN0aW9uIGxpbmUoKSB7DQogICBjb250ZXh0LnNhdmUoKTsNCiAgIGNvbnRleHQudHJhbnNsYXRlKGNvbnRleHQuY2FudmFzLndpZHRoLzIsIGNvbnRleHQuY2FudmFzLmhlaWdodC8yKTsNCiAgIGNvbnRleHQuc2NhbGUoMC45LCAwLjkpOw0KICAgY29udGV4dC50cmFuc2xhdGUoLWNvbnRleHQuY2FudmFzLndpZHRoLzIsIC1jb250ZXh0LmNhbnZhcy5oZWlnaHQvMik7DQogICBjb250ZXh0LmJlZ2luUGF0aCgpOw0KICAgY29udGV4dC5saW5lV2lkdGggPSA1ICsgTWF0aC5yYW5kb20oKSAqIDEwOw0KICAgY29udGV4dC5tb3ZlVG8obGFzdFgsIGxhc3RZKTsNCiAgIGxhc3RYID0gY29udGV4dC5jYW52YXMud2lkdGggKiBNYXRoLnJhbmRvbSgpOw0KICAgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RYLCBsYXN0WSk7DQoNCiAgIGh1ZSA9IGh1ZSArIDEwICogTWF0aC5yYW5kb20oKTsNCiAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnaHNsKCcgKyBodWUgKyAnLCA1MCUsIDUwJSknOw0KICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICd3aGl0ZSc7DQogICBjb250ZXh0LnNoYWRvd0JsdXIgPSAxMDsNCiAgIGNvbnRleHQuc3Ryb2tlKCk7DQogICBjb250ZXh0LnJlc3RvcmUoKTsNCiB9DQogc2V0SW50ZXJ2YWwobGluZSwgNTApOw0KDQogZnVuY3Rpb24gYmxhbmsoKSB7DQogICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknOw0KICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTsNCiB9DQogc2V0SW50ZXJ2YWwoYmxhbmssIDQwKTsNCg0KPC9zY3JpcHQ%2BDQogPC9ib2R5Pg0KPC9odG1sPg0K">довольно яркие линии</a>.</p>

  <pre>&lt;canvas width="800" height="450"&gt;&lt;/canvas&gt;
&lt;script&gt;

 var context = document.getElementsByTagName('canvas')[0].getContext('2d');

 var lastX = context.canvas.width * Math.random();
 var lastY = context.canvas.height * Math.random();
 var hue = 0;
 function line() {
   context.save();
   context.translate(context.canvas.width/2, context.canvas.height/2);
   context.scale(0.9, 0.9);
   context.translate(-context.canvas.width/2, -context.canvas.height/2);
   context.beginPath();
   context.lineWidth = 5 + Math.random() * 10;
   context.moveTo(lastX, lastY);
   lastX = context.canvas.width * Math.random();
   lastY = context.canvas.height * Math.random();
   context.bezierCurveTo(context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         lastX, lastY);

   hue = hue + 10 * Math.random();
   context.strokeStyle = 'hsl(' + hue + ', 50%, 50%)';
   context.shadowColor = 'white';
   context.shadowBlur = 10;
   context.stroke();
   context.restore();
 }
 setInterval(line, 50);

 function blank() {
   context.fillStyle = 'rgba(0,0,0,0.1)';
   context.fillRect(0, 0, context.canvas.width, context.canvas.height);
 }
 setInterval(blank, 40);

&lt;/script&gt;</pre>

  </div>


<!--FIXUP 2dcontext -4-->
  <h2 class="no-num" id="references">Ссылки</h2><!--REFS-->

  <p>Все ссылки являются нормативными, если не указано "не нормативная".</p>

  <!-- Dates are only included for standards older than the Web, because the newer ones keep changing. -->

  <dl>
<!--REFERENCES ON-->

   <dt id="refsBEZIER">[BEZIER]</dt>
   <dd><cite>Courbes à poles</cite>, P. de Casteljau. INPI, 1959.</dd>

   <!--
   <dd><cite><a href="http://tools.ietf.org/html/rfc2109">HTTP State Management Mechanism</a></cite>, D. Kristol, L. Montulli. IETF.</dd>
   <dd><cite><a href="http://tools.ietf.org/html/rfc2965">HTTP State Management Mechanism</a></cite>, D. Kristol, L. Montulli. IETF.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/cors/">Cross-Origin
   Resource Sharing</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!-- really should be "NARUSE, Y." or some
   such, but there's a western bias to these references for
   consistency. sorry. -->

   <!-- really should be "NARUSE, Y." or some
   such, but there's a western bias to these references for
   consistency. sorry. -->

   <dt id="refsCSS">[CSS]</dt>
   <dd><cite><a href="http://www.w3.org/TR/CSS/">Cascading Style Sheets Level 2
   Revision 1</a> (URL: <a href="http://www.w3.org/TR/CSS/">http://www.w3.org/TR/CSS/</a>)</cite>, B. Bos, T. Çelik, I.
   Hickson, H. Lie. W3C.</dd>

   <dt id="refsCSSCOLOR">[CSSCOLOR]</dt>
   <!--
   <dd><cite><a href="http://www.w3.org/TR/css3-color/">CSS Color
   Module Level 3</a></cite>, T. &Ccedil;elik, C. Lilley, L.
   Baron. W3C.</dd>
   -->
   <dd><cite><a href="http://www.w3.org/TR/css3-color/">CSS Color
   Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-color/">http://www.w3.org/TR/css3-color/</a>)</cite>, T. Çelik, C. Lilley, L.
   Baron. 7 June 2011. Рекомендация W3C.</dd>

   <dt id="refsCSSFONTS">[CSSFONTS]</dt>
   <dd><cite><a href="http://www.w3.org/TR/css3-fonts/">CSS Fonts
   Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-fonts/">http://www.w3.org/TR/css3-fonts/</a>)</cite>, J. Daggett. W3C.</dd>

   <dt id="refsCSSIMAGES">[CSSIMAGES]</dt>
   <dd><cite><a href="http://www.w3.org/TR/css3-images/">CSS Image
   Values and Replaced Content Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-images/">http://www.w3.org/TR/css3-images/</a>)</cite>, E. Etemad,
   T. Atkins. W3C.</dd>

   <dt id="refsCSSOM">[CSSOM]</dt>
   <dd><cite><a href="http://www.w3.org/TR/cssom/">Cascading Style Sheets
   Object Model (CSSOM)</a> (URL: <a href="http://www.w3.org/TR/cssom/">http://www.w3.org/TR/cssom/</a>)</cite>, S. Pieters, G. Adams. W3C.</dd>

   <!--
   <dd><cite><a
   href="http://www.w3.org/TR/DOM-Level-3-Events/">Document Object
   Model (DOM) Level 3 Events Specification</a></cite>,
   B. H&ouml;hrmann, P. Le Hegaret, T. Pixley. W3C.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/eventsource/">Server-Sent
   Events</a></cite>, I. Hickson. W3C.</dd>
   -->
   <!-- http://www.iana.org/assignments/charset-reg/GBK -->

   <!--
   This book ("Computer Graphics: Principles and Practice in C")
   apparently does not make any references to literature in the
   bibliographic section to define the "even-odd" rule for polygon
   filling and hit testing. In the absence of such a reference, I
   guess that this book is the most authoritative reference.
   -->

   <dt id="refsHTML">[HTML]</dt>
   <dd>Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. <a href="http://www.w3.org/TR/html5/"><cite>HTML5</cite></a>. 28 октября 2014. Рекомендация W3C. URL: <a href="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/</a></dd>

   <!--
   <dd>(Non-normative) <cite><a
   href="http://www.w3.org/TR/html5-diff/">HTML5 differences from
   HTML4</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/css3-mediaqueries/">Media
   Queries</a></cite>, H. Lie, T.  &Ccedil;elik, D. Glazman, A. van
   Kesteren. W3C.</dd>
   -->
   <dt id="refsPORTERDUFF">[PORTERDUFF]</dt>
   <dd><cite><a href="http://keithp.com/~keithp/porterduff/p253-porter.pdf">Compositing
   Digital Images</a> (URL: <a href="http://keithp.com/~keithp/porterduff/p253-porter.pdf">http://keithp.com/~keithp/porterduff/p253-porter.pdf</a>)</cite>, T. Porter, T. Duff. В <cite>Компьютерной графике</cite>, том 18, номер 3, стр. 253-259. ACM Press, июль
   1984.</dd>

   <!-- for text/plain and
   "Internet Media type"; not for definition of "valid MIME type". -->

   <dt id="refsTYPEDARRAY">[TYPEDARRAY]</dt>
   <dd><cite><a href="https://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a> (URL: <a href="https://www.khronos.org/registry/typedarray/specs/latest/">https://www.khronos.org/registry/typedarray/specs/latest/</a>)</cite>, D. Herman, K. Russell. Khronos.</dd>

   <dt id="refsWEBIDL">[WEBIDL]</dt>
   <dd><a href="http://www.w3.org/TR/WebIDL-1/"><cite>Web IDL</cite></a> (URL: <a href="http://www.w3.org/TR/WebIDL-1/">http://www.w3.org/TR/WebIDL-1/</a>), Cameron McCormack, Boris Zbarsky, Yves Lafon, Travis Leithead. W3C.

   <!--
   <dd><cite><a href="http://www.w3.org/TR/XMLHttpRequest/">The XMLHttpRequest
   Object</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!--(once XSLTProcessor is defined somewhere, update this and the place that references this)
   <dt id="refsXSLTP">[XSLTP]</dt>
   <dd>(Non-normative) <cite><a href=""></a></cite>, . .</dd>
-->


   <!--REFERENCES OFF-->
  </dl>


</body></html>

