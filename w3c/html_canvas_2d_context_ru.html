<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <title>HTML Canvas 2D Context — W3C</title>
    <style type="text/css">

     .applies thead th > * { display: block; }
     .applies thead code { display: block; }
     .applies tbody th { white-space: nowrap; }
     .applies td { text-align: center; }
     .applies .yes { background: yellow; }

     .matrix, .matrix td { border: hidden; text-align: right; }
     .matrix { margin-left: 2em; }

     .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
     .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
     .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

     td.eg { border-width: thin; text-align: center; }

     .details-example img { vertical-align: top; }

     .glyph.control { color: red; }

     @font-face {
       font-family: 'Essays1743';
       src: url('fonts/Essays1743.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-weight: bold;
       src: url('fonts/Essays1743-Bold.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       src: url('fonts/Essays1743-Italic.ttf');
     }
     @font-face {
       font-family: 'Essays1743';
       font-style: italic;
       font-weight: bold;
       src: url('fonts/Essays1743-BoldItalic.ttf');
     }

    </style>
    <style type="text/css">
       pre { margin-left: 2em; white-space: pre-wrap; }
       h2 { margin: 3em 0 1em 0; }
       h3 { margin: 2.5em 0 1em 0; }
       h4 { margin: 2.5em 0 0.75em 0; }
       h5, h6 { margin: 2.5em 0 1em; }
       h1 + h2, h1 + h2 + h2, h1 + p, h1 + p + h2 { margin: 0.75em 0 0.75em; }
       h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 0.5em; }
       p { margin: 1em 0; }
       hr:not(.top) { display: block; background: none; border: none; padding: 0; margin: 2em 0; height: auto; }
       .element dd,  .element dl { margin-top: 0em; margin-bottom: 0.25em;}
       dt { margin-top: 0.75em; margin-bottom: 0.5em; clear: left; }
        .element dt { margin-top: 0.5em; margin-bottom: 0.5em;  }
       dt + dt { margin-top: 0; }
       dd dt { margin-top: 0.25em; margin-bottom: 0; }
       dd p { margin-top: 0; }
       dd dl + p { margin-top: 1em; }
       dd table + p { margin-top: 1em; }
       p + * > li, dd li { margin: 1em 0; }
       dt, dfn { font-weight: bold; font-style: normal; }
       i, em { font-style: italic; }
       dt dfn { font-style: italic; }
       pre, code { font-size: inherit; font-family: monospace; font-variant: normal; }
       pre strong { color: black; font: inherit; font-weight: bold; background: yellow; }
       pre em { font-weight: bolder; font-style: normal; }
       @media screen { code { color: #D93B00; } code :link, code :visited { color: inherit; } }
       var { background-color: #f9f9f9; border: 1px solid #eee; padding: 0 2px; }
       var sub { vertical-align: bottom; font-size: smaller; position: relative; top: 0.1em; }
       table { border-collapse: collapse; border-style: hidden hidden none hidden; }
       table thead, table tbody { border-bottom: solid; }
       table tbody th:first-child { border-left: solid; }
       table tbody th { text-align: left; }
       table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
       blockquote { margin: 0 0 0 2em; border: 0; padding: 0; font-style: italic; }

       .bad, .bad *:not(.XXX) { color: #5F6D7A; border-color: gray; background: transparent; }
       .matrix, .matrix td { border: none; text-align: right; }
       .matrix { margin-left: 2em; }
       .dice-example { border-collapse: collapse; border-style: hidden solid solid hidden; border-width: thin; margin-left: 3em; }
       .dice-example caption { width: 30em; font-size: smaller; font-style: italic; padding: 0.75em 0; text-align: left; }
       .dice-example td, .dice-example th { border: solid thin; width: 1.35em; height: 1.05em; text-align: center; padding: 0; }

       .toc dfn, h1 dfn, h2 dfn, h3 dfn, h4 dfn, h5 dfn, h6 dfn { font: inherit; }
       img.extra, p.overview { float: right; }
       pre.idl { border: solid thin #d3d3d3; background: #FCFCFC; color: black; padding: 0.5em 1em; position: relative; }
       pre.idl :link, pre.idl :visited { color: inherit; background: transparent; }
       pre.idl::before { content: "IDL"; font: bold small sans-serif; padding: 0.5em; background: white; position: absolute; top: 0; margin: -1px 0 0 -4em; width: 1.5em; border: thin solid; border-radius: 0 0 0 0.5em }
       pre.css { border: solid thin; background: #FFFFEE; color: black; padding: 0.5em 1em; }
       pre.css:first-line { color: #AAAA50; }
       dl.domintro {padding: 0.5em 1em; border: none; background:#E9FBE9; border: 1px solid lightgray; }
       hr + dl.domintro, div.impl + dl.domintro { margin-top: 2.5em; margin-bottom: 1.5em; }
       dl.domintro dt, dl.domintro dt * { color: black; text-decoration: none; }
       dl.domintro dd { margin: 0.5em 0 1em 2em; padding: 0; }
       dl.domintro dd p { margin: 0.5em 0; }
       dl.domintro:before { display: block; content: 'Заметка:'; font-weight: bold;padding-bottom: 1em;}
       dl.switch { padding-left: 2em; }
       dl.switch > dt { text-indent: -1.5em; }
       dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }
       dl.triple { padding: 0 0 0 1em; }
       dl.triple dt, dl.triple dd { margin: 0; display: inline }
       dl.triple dt:after { content: ':'; }
       dl.triple dd:after { content: '\A'; white-space: pre; }
       .diff-old { text-decoration: line-through; color: silver; background: transparent; }
       .diff-chg, .diff-new { text-decoration: underline; color: green; background: transparent; }
       a .diff-new { border-bottom: 1px blue solid; }

       figure.diagrams { border: double black; background: white; padding: 1em; }
       figure.diagrams img { display: block; margin: 1em auto; }

       h2 { page-break-before: always; }
       h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
       h1 + h2, hr + h2.no-toc { page-break-before: auto; }

       p  > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang]),
       li > span:not([title=""]):not([class="XXX"]):not([class="impl"]):not([class="note"]):not([class="t2"]):not([id]):not([lang])
       { border-bottom: solid #9999CC; }

       div.head { margin: 0 0 1em; padding: 1em 0 0 0; }
       div.head p { margin: 0; }
       div.head h1 { margin: 0; }
       div.head .logo { float: right; margin: 0 1em; }
       div.head .logo img { border: none } /* remove border from top image */
       div.head dl { margin: 1em 0; }
       div.head p.copyright, div.head p.alt { font-size: x-small; font-style: oblique; margin: 0; }

       body > .toc > li { margin-top: 1em; margin-bottom: 1em; }
       body > .toc.brief > li { margin-top: 0.35em; margin-bottom: 0.35em; }
       body > .toc > li > * { margin-bottom: 0.5em; }
       body > .toc > li > * > li > * { margin-bottom: 0.25em; }
       .toc, .toc li { list-style: none; }

       .brief { margin-top: 1em; margin-bottom: 1em; line-height: 1.1; }
       .brief li { margin: 0; padding: 0; }
       .brief li p { margin: 0; padding: 0; }

       .category-list { margin-top: -0.75em; margin-bottom: 1em; line-height: 1.5; }
       .category-list::before { content: '\21D2\A0'; font-size: 1.2em; font-weight: 900; }
       .category-list li { display: inline; }
       .category-list li:not(:last-child)::after { content: ', '; }
       .category-list li > span, .category-list li > a { text-transform: lowercase; }
       .category-list li * { text-transform: none; } /* don't affect <code> nested in <a> */

       .XXX { color: #E50000; background: white; border: solid red; padding: 0.5em; margin: 1em 0; }
       .XXX > :first-child { margin-top: 0; }
       p .XXX { line-height: 3em; }
       .annotation { border: solid thin black; background: #0C479D; color: white; position: relative; margin: 8px 0 20px 0; }
       .annotation:before { position: absolute; left: 0; top: 0; width: 100%; height: 100%; margin: 6px -6px -6px 6px; background: #333333; z-index: -1; content: ''; }
       .annotation :link, .annotation :visited { color: inherit; }
       .annotation :link:hover, .annotation :visited:hover { background: transparent; }
       .annotation span { border: none ! important; }
       .note { border-left-style: solid; border-left-width: 0.25em; background: none repeat scroll 0 0 #E9FBE9; border-color: #52E052; }
       .warning { background-color: #F9F0D4; border: medium double #FF0000; margin: 1em; padding: 1em; }
       .note em, .warning em, .note i, .warning i { font-style: normal; }
       p.note, div.note { padding: 0.5em 2em; }
       span.note { padding: 0 2em; }
       .note p:first-child, .warning p:first-child { margin-top: 0; }
       .note p:last-child, .warning p:last-child { margin-bottom: 0; }
       .warning:before { font-style: normal; }
       p.note:before { content: 'Заметка: '; font-weight: bolder;}
       p.warning:before { content: '\26A0 Warning! '; font-weight:bolder;}
       .critical {margin:1em; border:double red; padding:1em; background-color:#F9F0D4;}

       .bookkeeping:before { display: block; content: 'Bookkeeping details'; font-weight: bolder; font-style: italic; }
       .bookkeeping { font-size: 0.8em; margin: 2em 0; }
       .bookkeeping p { margin: 0.5em 2em; display: list-item; list-style: square; }
       .bookkeeping dt { margin: 0.5em 2em 0; }
       .bookkeeping dd { margin: 0 3em 0.5em; }

       h4 { position: relative; z-index: 3; }
       h4 + .element, h4 + div + .element { margin-top: -2.5em; padding-top: 2em; }
       .element {
         background: #F4F4FA;
         color: black;
         margin: 0 0 1em 0.15em;
         padding: 0 1em 0.25em 0.75em;
         border-left: solid #9999FF 0.25em;
         position: relative;
         z-index: 1;
       }
       .element:before {
         position: absolute;
         z-index: 2;
         top: 0;
         left: -1.15em;
         height: 2em;
         width: 0.9em;
         background: #F4F4FA;
         content: ' ';
         border-style: none none solid solid;
         border-color: #9999FF;
         border-width: 0.25em;
       }

       .example { display: block; color: #222222; background: #FCFCFC; border-left-style: solid;border-color:#c0c0c0; border-left-width: 0.25em; margin-left: 1em; padding-left: 1em;padding-bottom: 0.5em;}
       div.example:before { content: 'Пример кода: '; font-weight: bolder;}
       td > .example:only-child { margin: 0 0 0 0.1em; }

       ul.domTree, ul.domTree ul { padding: 0 0 0 1em; margin: 0; }
       ul.domTree li { padding: 0; margin: 0; list-style: none; position: relative; }
       ul.domTree li li { list-style: none; }
       ul.domTree li:first-child::before { position: absolute; top: 0; height: 0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree li:not(:last-child)::after { position: absolute; top: 0; bottom: -0.6em; left: -0.75em; width: 0.5em; border-style: none none solid solid; content: ''; border-width: 0.1em; }
       ul.domTree span { font-style: italic; font-family: serif; }
       ul.domTree .t1 code { color: purple; font-weight: bold; }
       ul.domTree .t2 { font-style: normal; font-family: monospace; }
       ul.domTree .t2 .name { color: black; font-weight: bold; }
       ul.domTree .t2 .value { color: blue; font-weight: normal; }
       ul.domTree .t3 code, .domTree .t4 code, .domTree .t5 code { color: gray; }
       ul.domTree .t7 code, .domTree .t8 code { color: green; }
       ul.domTree .t10 code { color: teal; }

       body.dfnEnabled dfn { cursor: pointer; }
       .dfnPanel {
         display: inline;
         position: absolute;
         z-index: 10;
         height: auto;
         width: auto;
         padding: 0.5em 0.75em;
         font: small sans-serif, Droid Sans Fallback;
         background: #DDDDDD;
         color: black;
         border: outset 0.2em;
       }
       .dfnPanel * { margin: 0; padding: 0; font: inherit; text-indent: 0; }
       .dfnPanel :link, .dfnPanel :visited { color: black; }
       .dfnPanel p { font-weight: bolder; }
       .dfnPanel * + p { margin-top: 0.25em; }
       .dfnPanel li { list-style-position: inside; }

       #configUI { position: absolute; z-index: 20; top: 10em; right: 1em; width: 11em; font-size: small; }
       #configUI p { margin: 0.5em 0; padding: 0.3em; background: #EEEEEE; color: black; border: inset thin; }
       #configUI p label { display: block; }
       #configUI #updateUI, #configUI .loginUI { text-align: center; }
       #configUI input[type=button] { display: block; margin: auto; }

       fieldset { margin: 1em; padding: 0.5em 1em; }
       fieldset > legend + * { margin-top: 0; }
       fieldset > :last-child { margin-bottom: 0; }
       fieldset p { margin: 0.5em 0; }
       header p.subline {color:#005A9C; font: 140% sans-serif;margin: 0.75em 0;}
       #authorButton {overflow: visible; padding: 0.1em 0.3em; position: fixed; right: 2em; top: 6em; width: auto;}

       @media print {#authorButton { display:none;}}

       .translator { border: solid 2px black; background-color: #EEE9E9; padding: 5px; font-size: 15px; }

  </style>
  <link href="https://www.w3.org/StyleSheets/TR/W3C-REC" rel="stylesheet" type="text/css">

   </head>

  <!-- Yandex.Metrika counter --> <script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter36816840 = new Ya.Metrika({ id:36816840, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/36816840" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->

 <body>

<p class="translator">
Этот документ является неофициальным переводом исходной английской версии <a href="https://www.w3.org/TR/2dcontext/" target="_blank" rel="nofollow">HTML Canvas 2D Context</a>. Обратите внимание на то, что оригинальная версия документа существует <ins>только</ins> на английском языке. Данный перевод может содержать неточности и ошибки. Перевод выполнил <strong><a href="http://topolyan.com/" target="_blank">Кирилл Топольян</a></strong>, 2016.</p>

  <div class="head" id="head">
<header>

   <p><a href="http://www.w3.org/"><img alt="W3C" height="48" src="http://www.w3.org/Icons/w3c_home" width="72"></a></p>

    <h1>HTML Canvas 2D Context</h1>
   <h2 class="no-num no-toc subline">Рекомендация W3C от 19 ноября 2015</h2>
   </header>
<dl>
    <dt>Эта версия:</dt>
    <dd><a href="http://www.w3.org/TR/2015/REC-2dcontext-20151119/">http://www.w3.org/TR/2015/REC-2dcontext-20151119/</a></dd>
    <dt>Последняя опубликованная версия:</dt>
    <dd><a href="http://www.w3.org/TR/2dcontext/">http://www.w3.org/TR/2dcontext/</a></dd>
    <dt>Предыдущая версия:</dt>
    <dd><a href="http://www.w3.org/TR/2015/PR-2dcontext-20150924/">http://www.w3.org/TR/2015/PR-2dcontext-20150924/</a></dd>
    <dt>
      <dt id="specification-editors">Редакторы:</dt>
      <dd>W3C:</dd>
      <dd><a href="mailto:cabanier@adobe.com">Rik Cabanier</a>, Adobe Systems, Inc.</dd>
      <dd><a href="mailto:jmann@microsoft.com">Jatinder Mann</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:jaymunro@microsoft.com">Jay Munro</a>, Microsoft Corporation</dd>
      <dd><a href="mailto:wiltzius@google.com">Tom Wiltzius</a>, Google, Inc.</dd>
      <dd>WHATWG:</dd>
      <dd><a href="mailto:ian@hixie.ch">Ian Hickson</a>, Google, Inc.</dd>
   </dl>
   <p>Посмотрите <a href="http://www.w3.org/2015/11/2dcontext-errata.html"><strong>страницу исправлений</strong></a> этого документа, которая может включать в себя изменения после публикации.</p>

   <p>Также смотрите <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=2dcontext"> <strong>переводы</strong></a>.</p>

   <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2015 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C придерживается правил <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">ответственности</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">торговой марки</a> и <a href="http://www.w3.org/Consortium/Legal/copyright-documents">использования документов</a>.</p>

</div>


  <hr class="top">


  <h2 class="no-num no-toc" id="abstract">Аннотация</h2>

  <p>Эта спецификация определяет 2D Context для HTML элемента
  <a href='http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element'><code>canvas</code></a>. 2D Context предоставляет
   объекты, методы и свойства для рисования и управления
   графиками на поверхности рисования <code>canvas</code>.</p>

  <h2 class="no-num no-toc" id="status-of-this-document">Статус этого документа</h2>

<p><em>Этот раздел описывает статус данного документа на момент его публикации. Другие документы могут заменять этот документ. Со списком текущих публикаций W3C и последней ревизией этого технического доклада можно ознакомиться в <a href="http://www.w3.org/TR/">индексе технических докладов W3C</a>, http://www.w3.org/TR/.</em></p>

    <p>
      Эта спецификация для 2D Context для HTML элемента canvas опубликована <a href='http://www.w3.org/html/wg/'>Рабочей группой HTML</a>.
    </p>


    <p>Если вы хотите оставить комментарии к этому документу в порядке
    который отслеживается W3C, пожалуйста добавьте их с помощью <a href="https://github.com/w3c/2dcontext/issues" target="_blank" rel="nofollow">нашего публичного списка вопросов</a>. Если вы не можете сделать это, вы можете отправить e-mail на <a href="mailto:public-canvas-api@w3.org">public-canvas-api@w3.org</a>
    (<a href="mailto:public-canvas-api-request@w3.org?subject=subscribe">подписка</a>,
    <a href="http://lists.w3.org/Archives/Public/public-canvas-api/" target="_blank" rel="nofollow">архивы</a>),
    и мы примем меры чтобы перенести комментарии в нашу
    публичную базу данных багов. Любая обратная связь приветствуется.</p>
    <p>
      Публикуя эту рекомендацию, W3C ожидает что функциональность описанная в этой рекомендации не будет зависеть от изменений Web IDL, CSS Object Model, CSS Images Values, или CSS Fonts так как эти спецификации прошли Рекомендацию.
    </p>
    <p>
      Работа по расширению этой спецификации, как правило, проходит через
      <a href="http://www.w3.org/html/wg/wiki/ExtensionSpecifications">расширение спецификаций</a>
      к которым следует обращаться, чтобы увидеть, какие новые возможности будут рассмотрены.
    </p>
               <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->
       <p class="alt">Основная часть текста данной спецификации также доступна в WHATWG <a href="https://html.spec.whatwg.org/#2dcontext">HTML Living Standard</a>, в соответствии с лицензией, которая разрешает повторное использование текста спецификации.</p>
       <!-- UNDER NO CIRCUMSTANCES IS THE PRECEDING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->

  <!-- UNDER NO CIRCUMSTANCES IS THE FOLLOWING PARAGRAPH TO BE REMOVED OR EDITED WITHOUT TALKING TO IAN FIRST -->

  <!-- relationship to other work (required) -->

    <p>Работа по данной спецификации также сделана в <a href="https://whatwg.org/">WHATWG</a>. Рабочая группа W3C HTML активно следит за сходимостью
  HTML спецификации с рабочими стандартами WHATWG, в рамках <a href="http://www.w3.org/2013/09/html-charter.html">устава рабочей группы W3C HTML</a>. Есть разные способы следить за этой работой в WHATWG:</p>
  <ul>
      <li>Наблюдать за почтовым коммит-листом (полное исходное сравнение): <a href="http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org">http://lists.whatwg.org/listinfo.cgi/commit-watchers-whatwg.org</a></li>
      <li>Коммиты на Github: <a href="https://github.com/whatwg/html/commits" target="_blank" rel="nofollow">https://github.com/whatwg/html/commits</a></li>
  </ul>


  <p>Этот документ был рассмотрен членами W3C, разработчиками программного обеспечения, а также другими группами W3C и заинтересованными лицами, и одобрен Директором в качестве Рекомендации W3C. Это стабильный документ и может быть использован в качестве справочного материала или цитироваться из другого документа. Роль W3C в создании Рекомендации заключается в привлечении внимания к спецификации и способствовании ее широкому распространению. Это повышает функциональность и совместимость Сети.</p>

  <p>
    <a href='https://www.w3.org/Bugs/Public/buglist.cgi?bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED&amp;bug_status=VERIFIED&amp;bug_status=CLOSED&amp;component=CR%20HTML%20Canvas%202D%20Context&amp;list_id=57536&amp;product=HTML%20WG&amp;query_format=advanced'>Старый список вопросов</a> по-прежнему доступен. Никаких изменений не было сделано с момента предыдущей публикации.
  </p>

 <p>
    В период кандидатов в рекомендации, группа сделала доступный <a href="http://w3c.github.io/test-results/2dcontext/all.html">отчет о реализации</a> также как и <a href="https://www.w3.org/wiki/HTML/Canvas_Task_Force/CR-Test">дополнительный отчет для <code>drawFocusIfNeeded</code> и <code>addHitRegion</code></a>.
  </p>

  <p>Эта спецификация является расширением для языка HTML5. Все нормативное содержание в спецификации HTML5, если оно не было перезаписано в данной спецификации, предназначено стать основой для нее.</p>

<p>Этот документ был подготовлен группой действующей под <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">Патентной политикой W3C от 5 февраля 2004</a>. W3C поддерживает публичный <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">список открытых патентов</a>, сделанных в связи с результатами деятельности группы; эта страница также включает в себя инструкции по раскрытию патента. Человек, который имеет фактическое знание патента, который удовлетворяет <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">основным требованиям</a>, должен раскрывать информацию в соответствии с разделом 6 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">патентной политики W3C</a>.</p>

<p>Этот документ регулируется <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">W3C Process Document от 14 октября 2005 </a>. </p>

  <h2 class="no-num no-toc" id="contents">Содержание</h2>

<!--begin-toc-->
<ol class="toc">
 <li><a href="#conformance-requirements"><span class="secno">1 </span>Требования к соответствию</a></li>
 <li><a href="#the-canvas-state"><span class="secno">2 </span>Состояние canvas</a></li>
 <li><a href="#line-styles"><span class="secno">3 </span>Стили линий</a></li>
 <li><a href="#text-styles"><span class="secno">4 </span>Стили текста</a></li>
 <li><a href="#building-paths"><span class="secno">5 </span>Построение пути</a></li>
 <li><a href="#transformations"><span class="secno">6 </span>Преобразования</a></li>
 <li><a href="#image-sources-for-2d-rendering-contexts"><span class="secno">7 </span>Источники изображений для 2D рендеринга</a></li>
 <li><a href="#fill-and-stroke-styles"><span class="secno">8 </span>Стили заполнения и обводки</a></li>
 <li><a href="#drawing-rectangles-to-the-canvas"><span class="secno">9 </span>Рисование прямоугольников на холсте</a></li>
 <li><a href="#drawing-text-to-the-canvas"><span class="secno">10 </span>Рисование текста на холсте</a></li>
 <li><a href="#drawing-paths-to-the-canvas"><span class="secno">11 </span>Рисование пути на холсте</a></li>
 <li><a href="#drawing-images-to-the-canvas"><span class="secno">12 </span>Рисование изображений на холсте</a></li>
 <li><a href="#hit-regions"><span class="secno">13 </span>Hit области</a></li>
 <li><a href="#pixel-manipulation"><span class="secno">14 </span>Пиксельная манипуляция</a></li>
 <li><a href="#compositing"><span class="secno">15 </span>Совмещение</a></li>
 <li><a href="#shadows"><span class="secno">16 </span>Тени</a></li>
 <li><a href="#drawing-model"><span class="secno">17 </span>Модель рисования</a></li>
 <li><a href="#best-practices"><span class="secno">18 </span>Лучшая практика</a></li>
 <li><a href="#examples"><span class="secno">19 </span>Примеры</a></li>
 <li><a class="no-num" href="#references">Ссылки</a></li></ol>
<!--end-toc-->
  <hr>


  <h2 id="conformance-requirements"><span class="secno">1 </span>Требования к соответствию</h2>

  <p>Эта спецификация является спецификацией HTML. Все требования на соответствие, соответствие классов, определения, зависимости, терминология и типографские конвенции, описанные в спецификации ядра HTML5, применимы к данной спецификации. <a href="#refsHTML">[HTML]</a></p>

  <p>Интерфейсы определяются в терминах Web IDL. <a href="#refsWEBIDL">[WEBIDL]</a></p>

  <p>Эта спецификация определяет тип <dfn id="canvas-context-2d" title="canvas-context-2d"><code>2d</code></dfn> context, чей API реализован с использованием интерфейса <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>.</p>

  <div class="impl">

  <p>Когда метод <a href='http://www.w3.org/TR/html5/scripting-1.html#dom-canvas-getcontext'><code title="dom-canvas-getContext">getContext()</code></a> элемента <a href='http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element'><code>canvas</code></a> <span title="getContext-return">возвращает новый объект для <var>contextId</var></span> <code title="canvas-context-2d"><a href="#canvas-context-2d">2d</a></code>, пользовательский агент должен вернуть новый объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>. Любые дополнительные аргументы игнорируются.</p>

  </div>

  <p>2D context представляет собой плоскую декартову поверхность начало которой
  (0,0) находится в верхнем левом углу, с координатами пространства, где
  <var>x</var> значения идут вправо и <var>y</var> значения увеличиваются при движении вниз.</p>

  <pre class="idl">
typedef (<span>HTMLImageElement</span> or
         <span>HTMLVideoElement</span> or
         <span>HTMLCanvasElement</span>) <dfn id="canvasimagesource">CanvasImageSource</dfn>;

interface <dfn id="canvasrenderingcontext2d">CanvasRenderingContext2D</dfn> {

  // back-reference to the canvas
  readonly attribute <a href='http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement'><span>HTMLCanvasElement</span></a> <a href="#dom-context-2d-canvas" title="dom-context-2d-canvas">canvas</a>;

  // state
  void <a href="#dom-context-2d-save" title="dom-context-2d-save">save</a>(); // push state on state stack
  void <a href="#dom-context-2d-restore" title="dom-context-2d-restore">restore</a>(); // pop state stack and restore state
<!--
  // v7 we've also received requests for:
          attribute boolean <span title="dom-context-2d-forceHighQuality">forceHighQuality</span> // (default false)
  // when enabled, it would prevent the UA from falling back on lower-quality but faster rendering routines
  // useful e.g. for when an image manipulation app uses <canvas> both for UI previews and the actual work

-->
  // transformations (default: transform is the identity matrix)
  void <a href="#dom-context-2d-scale" title="dom-context-2d-scale">scale</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-rotate" title="dom-context-2d-rotate">rotate</a>(unrestricted double angle);
  void <a href="#dom-context-2d-translate" title="dom-context-2d-translate">translate</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-transform" title="dom-context-2d-transform">transform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
  void <a href="#dom-context-2d-settransform" title="dom-context-2d-setTransform">setTransform</a>(unrestricted double a, unrestricted double b, unrestricted double c, unrestricted double d, unrestricted double e, unrestricted double f);
<!--
  // v7 we've also received requests (though not many so far) for:
  void skew(...);                             // is this common enough that one can't just use setTransform()?
  void reflect(...);  and  void mirror(...);  // aren't negative values in scale() sufficient for these?

-->
  // compositing
           attribute unrestricted double <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">globalAlpha</a>; // (default: 1.0)
           attribute DOMString <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">globalCompositeOperation</a>; // (default: "source-over")
<!--
  // v7 we've also received requests for:
  - turning off antialiasing to avoid seams when patterns are painted next to each other
    - might be better to overdraw?
    - might be better to just draw at a higher res then downsample, like for 3d?
  - nested layers
    - the ability to composite an entire set of drawing operations with one shadow all at once
      http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2008-August/015567.html

-->
  // colors and styles (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
           attribute (DOMString or CanvasGradient or CanvasPattern) <a href="#dom-context-2d-strokestyle" title="dom-context-2d-strokeStyle">strokeStyle</a>; // (default: "black")
           attribute (DOMString or CanvasGradient or CanvasPattern) <a href="#dom-context-2d-fillstyle" title="dom-context-2d-fillStyle">fillStyle</a>; // (default: "black")
  <a href="#canvasgradient">CanvasGradient</a> <a href="#dom-context-2d-createlineargradient" title="dom-context-2d-createLinearGradient">createLinearGradient</a>(double x0, double y0, double x1, double y1);
  <a href="#canvasgradient">CanvasGradient</a> <a href="#dom-context-2d-createradialgradient" title="dom-context-2d-createRadialGradient">createRadialGradient</a>(double x0, double y0, double r0, double x1, double y1, double r1);
  <a href="#canvaspattern">CanvasPattern</a> <a href="#dom-context-2d-createpattern" title="dom-context-2d-createPattern">createPattern</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, [TreatNullAs=EmptyString] DOMString repetition);

  // shadows
           attribute unrestricted double <a href="#dom-context-2d-shadowoffsetx" title="dom-context-2d-shadowOffsetX">shadowOffsetX</a>; // (default: 0)
           attribute unrestricted double <a href="#dom-context-2d-shadowoffsety" title="dom-context-2d-shadowOffsetY">shadowOffsetY</a>; // (default: 0)
           attribute unrestricted double <a href="#dom-context-2d-shadowblur" title="dom-context-2d-shadowBlur">shadowBlur</a>; // (default: 0)
           attribute DOMString <a href="#dom-context-2d-shadowcolor" title="dom-context-2d-shadowColor">shadowColor</a>; // (default: "transparent black")

  // rects
  void <a href="#dom-context-2d-clearrect" title="dom-context-2d-clearRect">clearRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-fillrect" title="dom-context-2d-fillRect">fillRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-strokerect" title="dom-context-2d-strokeRect">strokeRect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);

  // path API (see also <a href="#canvaspathmethods">CanvasPathMethods</a>)
  void <a href="#dom-context-2d-beginpath" title="dom-context-2d-beginPath">beginPath</a>();
  void <a href="#dom-context-2d-fill" title="dom-context-2d-fill">fill</a>();
  void <a href="#dom-context-2d-stroke" title="dom-context-2d-stroke">stroke</a>();
  void <a href="#dom-context-2d-drawfocusifneeded" title="dom-context-2d-drawFocusIfNeeded">drawFocusIfNeeded</a>(<span>Element</span> element);
  void <a href="#dom-context-2d-clip" title="dom-context-2d-clip">clip</a>();
  boolean <a href="#dom-context-2d-ispointinpath" title="dom-context-2d-isPointInPath">isPointInPath</a>(unrestricted double x, unrestricted double y);

  // text (see also the <a href="#canvasdrawingstyles">CanvasDrawingStyles</a> interface)
  void <a href="#dom-context-2d-filltext" title="dom-context-2d-fillText">fillText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);
  void <a href="#dom-context-2d-stroketext" title="dom-context-2d-strokeText">strokeText</a>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxWidth);<!-- v6DVT
  void <span title="dom-context-2d-fillVerticalText">fillVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight);
  void <span title="dom-context-2d-strokeVerticalText">strokeVerticalText</span>(DOMString text, unrestricted double x, unrestricted double y, optional unrestricted double maxHeight); -->
  <a href="#textmetrics">TextMetrics</a> <a href="#dom-context-2d-measuretext" title="dom-context-2d-measureText">measureText</a>(DOMString text);

  // drawing images
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy);
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);
  void <a href="#dom-context-2d-drawimage" title="dom-context-2d-drawImage">drawImage</a>(<a href="#canvasimagesource">CanvasImageSource</a> image, unrestricted double sx, unrestricted double sy, unrestricted double sw, unrestricted double sh, unrestricted double dx, unrestricted double dy, unrestricted double dw, unrestricted double dh);

  // hit regions
  void <a href="#dom-context-2d-addhitregion" title="dom-context-2d-addHitRegion">addHitRegion</a>(<a href="#hitregionoptions">HitRegionOptions</a> options);
  void <a href="#dom-context-2d-removehitregion" title="dom-context-2d-removeHitRegion">removeHitRegion</a>(DOMString id);
  void <a href="#dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions">clearHitRegions</a>();

  // pixel manipulation
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-createimagedata" title="dom-context-2d-createImageData">createImageData</a>(unrestricted double sw, unrestricted double sh);
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-createimagedata" title="dom-context-2d-createImageData">createImageData</a>(<a href="#imagedata">ImageData</a> imagedata);
  <a href="#imagedata">ImageData</a> <a href="#dom-context-2d-getimagedata" title="dom-context-2d-getImageData">getImageData</a>(double sx, double sy, double sw, double sh);
  void <a href="#dom-context-2d-putimagedata" title="dom-context-2d-putImageData">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy);
  void <a href="#dom-context-2d-putimagedata" title="dom-context-2d-putImageData">putImageData</a>(<a href="#imagedata">ImageData</a> imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);
};
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvasdrawingstyles">CanvasDrawingStyles</a>;
<a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a> implements <a href="#canvaspathmethods">CanvasPathMethods</a>;

[NoInterfaceObject]
interface <dfn id="canvasdrawingstyles">CanvasDrawingStyles</dfn> {
  // line caps/joins
           attribute unrestricted double <a href="#dom-context-2d-linewidth" title="dom-context-2d-lineWidth">lineWidth</a>; // (default: 1)
           attribute DOMString <a href="#dom-context-2d-linecap" title="dom-context-2d-lineCap">lineCap</a>; // "butt", "round", "square" (default: "butt")
           attribute DOMString <a href="#dom-context-2d-linejoin" title="dom-context-2d-lineJoin">lineJoin</a>; // "round", "bevel", "miter" (default: "miter")
           attribute unrestricted double <a href="#dom-context-2d-miterlimit" title="dom-context-2d-miterLimit">miterLimit</a>; // (default: 10)

  // dashed lines
  void <a href="#dom-context-2d-setlinedash" title="dom-context-2d-setLineDash">setLineDash</a>(sequence&lt;unrestricted double&gt; segments); // (default: empty)
  sequence&lt;unrestricted double&gt; <a href="#dom-context-2d-getlinedash" title="dom-context-2d-getLineDash">getLineDash</a>();
           attribute unrestricted double <a href="#dom-context-2d-linedashoffset" title="dom-context-2d-lineDashOffset">lineDashOffset</a>;


  // text
           attribute DOMString <a href="#dom-context-2d-font" title="dom-context-2d-font">font</a>; // (default: "10px sans-serif")
           attribute DOMString <a href="#dom-context-2d-textalign" title="dom-context-2d-textAlign">textAlign</a>; // "start", "end", "left", "right", "center" (default: "start")
           attribute DOMString <a href="#dom-context-2d-textbaseline" title="dom-context-2d-textBaseline">textBaseline</a>; // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
};

[NoInterfaceObject]
interface <dfn id="canvaspathmethods">CanvasPathMethods</dfn> {
  // shared path API methods
  void <a href="#dom-context-2d-closepath" title="dom-context-2d-closePath">closePath</a>();
  void <a href="#dom-context-2d-moveto" title="dom-context-2d-moveTo">moveTo</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-lineto" title="dom-context-2d-lineTo">lineTo</a>(unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-quadraticcurveto" title="dom-context-2d-quadraticCurveTo">quadraticCurveTo</a>(unrestricted double cpx, unrestricted double cpy, unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-beziercurveto" title="dom-context-2d-bezierCurveTo">bezierCurveTo</a>(unrestricted double cp1x, unrestricted double cp1y, unrestricted double cp2x, unrestricted double cp2y, unrestricted double x, unrestricted double y);
  void <a href="#dom-context-2d-arcto" title="dom-context-2d-arcTo">arcTo</a>(unrestricted double x1, unrestricted double y1, unrestricted double x2, unrestricted double y2, unrestricted double radius); <!-- see ARC-ORDER note below -->
  void <a href="#dom-context-2d-rect" title="dom-context-2d-rect">rect</a>(unrestricted double x, unrestricted double y, unrestricted double w, unrestricted double h);
  void <a href="#dom-context-2d-arc" title="dom-context-2d-arc">arc</a>(unrestricted double x, unrestricted double y, unrestricted double radius, unrestricted double startAngle, unrestricted double endAngle, optional boolean counterclockwise = false); <!-- see ARC-ORDER note below -->

  };

interface <dfn id="canvasgradient">CanvasGradient</dfn> {
  // opaque object
  void <a href="#dom-canvasgradient-addcolorstop" title="dom-canvasgradient-addColorStop">addColorStop</a>(double offset, DOMString color);
};

interface <dfn id="canvaspattern">CanvasPattern</dfn> {
  // opaque object
};

interface <dfn id="textmetrics">TextMetrics</dfn> {
  readonly attribute double <a href="#dom-textmetrics-width-0" title="dom-textmetrics-width">width</a>;
};

dictionary <dfn id="hitregionoptions">HitRegionOptions</dfn> {
  // dictionary to allow expansion on Hit Regions in Canvas Context 2D Level 2
  <span>DOMString</span> <span title="dom-HitRegionOptions-id">id</span> = "";
  // for control-backed regions:
  <span>Element?</span> <span title="dom-HitRegionOptions-control">control</span> = null;
};

interface <dfn id="imagedata">ImageData</dfn> {
  readonly attribute unsigned long <a href="#dom-imagedata-width" title="dom-imagedata-width">width</a>;
  readonly attribute unsigned long <a href="#dom-imagedata-height" title="dom-imagedata-height">height</a>;
  readonly attribute <span>Uint8ClampedArray</span> <a href="#dom-imagedata-data" title="dom-imagedata-data">data</a>;
};

</pre>

 <!-- ARC-ORDER note (see above):
      some demos rely on the precise order of the arc() and arcTo()
      methods, see https://bugzilla.mozilla.org/show_bug.cgi?id=623437
      for an example, and its duplicates for more -->

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-canvas"><a href="#dom-context-2d-canvas">canvas</a></code></dt>

   <dd>

    <p>Возвращает элемент <code>canvas</code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-context-2d-canvas" title="dom-context-2d-canvas"><code>canvas</code></dfn>
  должен возвращать элемент <code>canvas</code>, нарисованный контекстом.</p>

  <p>За исключением случаев когда указано иное, для 2D context интерфейса,
  <strong>любой вызов метода с числовым аргументом, значение которого бесконечно либо NaN, должен быть проигнорирован</strong>.</p>

  <!--
   Philip Taylor wrote:
   > My experience with some 3d canvas code is that infinities come up in
   > naturally harmless places, e.g. having a function that scales by x then
   > translates by 1/x and wanting it to work when x=0 (which ought to draw
   > nothing, since anything it draws is zero pixels wide), and it's a bit
   > annoying to track down and fix those issues, so I'd probably like it if
   > they were harmless in canvas methods. Opera appears to silently not draw
   > anything if the transformation matrix is not finite, but Firefox <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">throws</a>
   > exceptions when passing in non-finite arguments.
  -->

  <p>Всякий раз, когда значение CSS <code>currentColor</code> используется в качестве цвета в этом API, вычисленное значения свойства 'color'
  для целей определения вычисленного значения <code>currentColor</code>, ключевым словом является вычисленное значение
  'color' элемента о котором идет речь, когда цвет задан (например когда соответствующий атрибут установлен или когда вызван метод; не тогда когда цвет визуализируется или в другом случае). Если вычисленное значение свойства 'color' не определено для конкретного случая (например, потому что элемент находится не
  <span>в <code>Document</code></span>), то для определения вычисленного значения свойства 'color' определяется значением <code>currentColor</code>, ключевое слово полностью непрозрачный черный. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p>В случае с <code title="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop()</a></code> на
  <code><a href="#canvasgradient">CanvasGradient</a></code>, для целей определения вычисленного значения
  <code>currentColor</code> ключевое слово всегда полностью непрозрачный черный (нет связанного с ним элемента). <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p class="note">Это потому что объекты <code><a href="#canvasgradient">CanvasGradient</a></code> <code>canvas</code>-нейтральные —
  объект <code><a href="#canvasgradient">CanvasGradient</a></code> созданный одним <code>canvas</code> может использоваться другим, и поэтому
  нет способа узнать "элемент в деле" в то время как цвет определен.</p>

  <p class="note">Схожие проблемы существуют и со шрифтами, правила для них подробно описаны в разделе ниже.</p>

  </div>



<!--FIXUP 2dcontext +4-->
  <h2 id="the-canvas-state"><span class="secno">2 </span>Состояние canvas</h2>

  <p>Каждый контекст поддерживает стек из состояний рисования. <dfn id="drawing-state" title="drawing state">Состояние рисования</dfn> состоит из:</p>

  <ul class="brief">
   <li>Текущая <a href="#transformations" title="dom-context-2d-transformation">матрица преобразования</a>.</li>
   <li>Текущая <a href="#clipping-region">область отсечения</a>.</li>
   <li>Текущие значения следующих атрибутов: <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>, <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>, <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>, <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>, <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>, <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code>, <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code>, <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code>, <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>, <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>, <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>, <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code>, <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>.</li>
  </ul>

  <p class="note">Текущий путь и текущий битмап не являются частью состояния рисования. <span>Текущий путь</span> постоянен и может быть сброшен только с помощью
  метода <code title="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath()</a></code>.
  Текущий битмап является свойством холста, а не контекста.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-save"><a href="#dom-context-2d-save">save</a></code>()</dt>

   <dd>

    <p>Сохраняет текущее состояние в стек.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-restore"><a href="#dom-context-2d-restore">restore</a></code>()</dt>

   <dd>

    <p>Убирает верхнее состояние в стеке, восстанавливая контекст к этому состоянию.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-save" title="dom-context-2d-save"><code>save()</code></dfn>
  должен поместить копию текущего состояния на стек состояния рисования.</p>

  <p>Метод <dfn id="dom-context-2d-restore" title="dom-context-2d-restore"><code>restore()</code></dfn> должен взять верхний элемент в стеке состояния, и сбросить состояние которое он описывает. Если нет сохраненного состояния, метод не должен делать ничего.</p>

  <!-- v7
idea from Mihai:
> 5. Drawing states should be saveable with IDs, and for easier restoring.
>
> save(id)
> restore(id)
>
> If id is not provided, then save() works as defined now. The same for
> restore().
>
> Currently, it's not trivial to save and restore a specific state.
...and from Philip:
> I think a more convenient syntax would be:
>   var state = ctx.save();
>   ctx.restore(state);
> But how would it interact with normal calls to ctx.restore()?
  -->

  </div>


  <h2 id="line-styles"><span class="secno">3 </span>Стили линий</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущую ширину линии.</p>

    <p>Может быть установлен, чтобы изменить ширину линии. Дробные значения больше нуля игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает стиль окончания линии.</p>

    <p>Может быть установлен для изменения стиля линии.</p>

    <p>Возможные значения: "<code>butt</code>",
    "<code>round</code>", и "<code>square</code>". Другие значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль соединения линии.</p>

    <p>Может быть установлен для изменения стиля соединения.</p>

    <p>Возможные стили "<code>bevel</code>",
    "<code>round</code>", и "<code>miter</code>". Другие значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущее значение miter limit.</p>

    <p>Может быть установлен для изменения значения miter limit. Дробные значения кроме нуля игнорируются.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-setLineDash"><a href="#dom-context-2d-setlinedash">setLineDash</a></code>(<var>segments</var>)</dt>

   <dd>

    <p>Устанавливает текущий шаблон линии пунктирной линии (используется при сглаживании). Аргумент представляет собой массив расстояний.</p>

   </dd>


   <dt><var>segments</var> = <var>context</var> . <code title="dom-context-2d-getLineDash"><a href="#dom-context-2d-getlinedash">getLineDash</a></code>()</dt>

   <dd>

    <p>Возвращает копию текущего шаблона пунктирной линии. Возвращаемый массив всегда будет иметь четное количество записей (т.е. картина нормализуется).</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает смещение фазы (в тех же единицах, что и линии штриха).</p>

    <p>Может быть установлен для изменения смещение фазы. Дробные значения игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Объекты, которые реализуют интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  имеют атрибуты и методы (определенные в этом разделе), которые контролируют как линии обрабатываются объектом.</p>

  <p>Атрибут <dfn id="dom-context-2d-linewidth" title="dom-context-2d-lineWidth"><code>lineWidth</code></dfn>
  дает ширину линий в координатном пространстве единиц. При получении, он должен вернуть текущее значение. При установке нулевого,
  негативного, бесконечного и NaN, значения должны быть проигнорированы, оставляя значение без изменений; другие значения должны изменить его на текущее значение.</p>

  <p>Когда создается реализующий интерфейс объект <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>, атрибут <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> должен изначально иметь значение <code>1.0</code>.</p>

  <hr>

  <p>Атрибут <dfn id="dom-context-2d-linecap" title="dom-context-2d-lineCap"><code>lineCap</code></dfn> определяет тип окончаний которые ПА (пользовательский агент) поместит на конец линий.
  Три валидных значения: "<code>butt</code>", "<code>round</code>",
  и "<code>square</code>".</p>

  <p>При получении, он должен вернуть текущее значение. При настройке, если новое значение является одной из строк "<code>butt</code>",
  "<code>round</code>", и "<code>square</code>", текущее значение
  должно быть изменено на новое значение; другие значения должны игнорироваться и ничего не менять.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code> должен изначально иметь значение "<code>butt</code>".</p>

  <hr>

  <p>Атрибут <dfn id="dom-context-2d-linejoin" title="dom-context-2d-lineJoin"><code>lineJoin</code></dfn>
  определяет тип соединения, которое пользовательский агент поместит туда где две линии встречаются. Есть три валидных значения: "<code>bevel</code>",
  "<code>round</code>", и "<code>miter</code>".</p>

  <p>При получении, он должен вернуть текущее значение. При настройке, если новое значение буквально "<code>bevel</code>",
  "<code>round</code>", и "<code>miter</code>", текущее значение изменится на новое; другие значения будут проигнорированы и ничего не изменят.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code> должен изначально иметь значение "<code>miter</code>".</p>

  <hr>

  <p>Когда атрибут <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>
  имеет значение "<code>miter</code>", штрихи используют значение miter
  limit чтобы решить как соединиться. Значение miter limit ratio can
  может быть задано атрибутом <dfn id="dom-context-2d-miterlimit" title="dom-context-2d-miterLimit"><code>miterLimit</code></dfn>. При получении, он должен вернуть текущее значение. При настройке,
  zero, negative, infinite, и NaN значения должны игнорироваться, не меняя значение; другие значения должны изменять текущее на новое значение.</p>
  <!-- values less than 1.0 are equivalent to 1.0, since it's compared
       against a ratio that can't be less than 1.0 -->

  <p>Когда объект, реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-miterLimit"><a href="#dom-context-2d-miterlimit">miterLimit</a></code> должен изначально иметь значение <code>10.0</code>.</p>

  <hr>

  <hr><p>Каждый объект <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> имеет <dfn id="dash-list">dash list</dfn>, который либо пуст, либо состоит из четного числа и положительных ненулевых чисел. Изначально, <a href="#dash-list">dash list</a>
  должен быть пуст.</p>

  <p>Когда вызывается метод <dfn id="dom-context-2d-setlinedash" title="dom-context-2d-setLineDash"><code>setLineDash()</code></dfn>
  он должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать <var>a</var> копией массива предоставленного в качестве аргумента.</p></li>

   <li><p>Если какое-либо значение в массиве не является конечным числом (например бесконечное или NaN), или значение негативное (меньше ноля), то прервать эти шаги (без исключений; пользовательский агент может показать сообщение на консоли разработчика, это может помочь для отладки).</p></li>

   <li><p>Если число элементов в <var>a</var> нечетное,
   то сделать <var>a</var> результатом сложения двух копий <var>a</var>.</p></li>

   <li><p>Позволить объекту <a href="#dash-list">dash list</a> быть <var>a</var>.</p></li>

  </ol>

  <p>Когда вызывается метод <dfn id="dom-context-2d-getlinedash" title="dom-context-2d-getLineDash"><code>getLineDash()</code></dfn>, он должен вернуть вновь созданный массив, значения которого являются значениями объекта <a href="#dash-list">dash list</a>, в том же порядке.</p>

  <p>Иногда полезно изменить "фазу" паттерна пунктира, например для достижения эффекта "бегущих муравьев". Фаза может быть установлена с  помощью атрибута <dfn id="dom-context-2d-linedashoffset" title="dom-context-2d-lineDashOffset"><code>lineDashOffset</code></dfn>. При получении, он должен возвратить текущее значение. При настройке,
  бесконечные и NaN значения должны быть проигнорированы, оставив значение без изменений; другие значения должны изменить текущее значение на новое.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>
  создан, атрибут <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>
  должен изначально иметь значение <code>0.0</code>.</p>

   <hr>

  <p>Когда пользовательский агент <dfn id="trace-a-path">чертит <span title="concept-path">путь</span></dfn>, <!-- <dfn>trace a path</dfn> -->
  заданный объектом <var data-anolis-xref="">style</var>, который реализует интерфейс <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code>, он должен выполнить следующий алгоритм. Этот алгоритм возвращает новый <a href="#concept-path" title="concept-path">путь</a>.</p>

  <ol>

   <li><p>Сделать <var data-anolis-xref="">path</var> пути который чертится.</p></li>

   <!-- PATH SANITIZATION -->

   <li><p>Сократить все элементы нулевой длины строки с <var data-anolis-xref="">path</var>.</p></li>

   <li><p>Удалить с <var data-anolis-xref="">path</var> любые подпути без линий (т.е. подпути только с одной точкой).</p></li>

   <li><p>Заменить каждую точку в каждом подпути <var data-anolis-xref="">path</var>, кроме первой и последней точки каждого подпути с помощью <i>join</i>, который соединяет линию ведущую к этой точке на линии ведущей из этой точки, таким образом все подпути состоят из двух точек (стартовая и конечная), одной или более линий (соединяющих точки), и ноля или более соединений (каждое соединяет одну линию с другой), соединенных друг с другом таким образом, что каждый подпуть представляет собой серию из одной или нескольких линий с соединениями между каждой из точек на каждом конце.</p></li>

   <li><p>Добавить прямую линию закрытия каждого замкнутого подпути в <var data-anolis-xref="">path</var> соединяющую последнюю точку и первую точку этого подпути; изменить последнюю точку в соединение (от предыдущей последней строки к новой добавленной закрывающей линии), и изменить первую точку в соединение (от предыдущей последней строки к новой добавленной закрывающей линии).</p>

   </li><li><p>Если <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a> пуст, перейти к шагу помеченному как <i>convert</i>.</p></li>

   <!-- DASHING -->

   <li><p>Сделать <var data-anolis-xref="">pattern width</var> суммой всех записей <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, в координатном пространстве единиц.</p>

   </li><li><p>Для каждого подпути <var data-anolis-xref="">subpath</var> в <var data-anolis-xref="">path</var>, запустить следующие подэтапы. Эти подэтапы превратятся в подпути <var data-anolis-xref="">path</var> <i>сами собой</i>.</p>

    <ol>

     <li><p>Сделать <var data-anolis-xref="">subpath width</var> длиной всех линий от <var data-anolis-xref="">subpath</var>, в координатном пространстве единиц.</p>

     </li><li><p>Сделать <var data-anolis-xref="">offset</var> значением <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineDashOffset"><a href="#dom-context-2d-linedashoffset">lineDashOffset</a></code>, в координатном пространстве единиц.</p></li>

     <li>

      <p>Если <var data-anolis-xref="">offset</var> больше чем <var data-anolis-xref="">pattern width</var>,
      уменьшить его до <var data-anolis-xref="">pattern width</var>.</p>

      <p>Если <var data-anolis-xref="">offset</var> меньше ноля, реализовать его с помощью <var data-anolis-xref="">pattern
      width</var>.</p>

     </li>

     <li><p>Определить <var data-anolis-xref="">L</var> линией в линейных координатах в <var data-anolis-xref="">subpath</var>, таким образом, что начало первой строки подпути определяется как координата 0, и конец последней строки в подпути определяется как координата <var data-anolis-xref="">subpath width</var>.</p></li>

     <li><p>Сделать <var data-anolis-xref="">position</var> нулем минус <var data-anolis-xref="">offset</var>.</p></li>

     <li><p>Сделать <var data-anolis-xref="">index</var> равным 0.</p></li>

     <li><p>Сделать <var data-anolis-xref="">current state</var> равным <i>off</i> (другие состояния являются <i>on</i>
     и <i>zero-on</i>).</p></li>

     <li><p><i id='step-dash-on'>Dash on</i>: Сделать <var data-anolis-xref="">segment length</var> равным значению <var data-anolis-xref="">styles</var> <a href="#dash-list">dash
     list</a>'s <var data-anolis-xref="">index</var>-й записью.</p></li>

     <li><p>Инкрементировать <var data-anolis-xref="">position</var> по <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда закончить эти подэтапы для этих подпутей и начать их снова для следующего подпути; если больше нет подпутей, тогда перейти к шагу помеченному как <i>convert</i>.</p></li>

     <li><p>Если <var data-anolis-xref="">segment length</var> не нулевая, сделать <var data-anolis-xref="">current state</var> равной <i>on</i>.</p></li>

     <li><p>Инкрементировать <var data-anolis-xref="">index</var> на единицу.</p></li>

     <li><p><i>Dash off<!-- labeled for consistency only --></i>: Сделать <var data-anolis-xref="">segment
     length</var> значением <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a> <var data-anolis-xref="">index</var>-й записи.</p></li>

     <li><p>Сделать <var data-anolis-xref="">start</var> смещением <var data-anolis-xref="">position</var> на <var data-anolis-xref="">L</var>.</p></li>

     <li><p>Инкрементировать <var data-anolis-xref="">position</var> на <var data-anolis-xref="">segment length</var>.</p></li>

     <li><p>Если <var data-anolis-xref="">position</var> меньше ноля, тогда перейти к шагу помеченному как
     <i>post-cut</i>.</p></li> <!-- start and end both before zero -->

     <li><p>Если <var data-anolis-xref="">start</var> меньше ноля, тогда сделать <var data-anolis-xref="">start</var> равным нолю.</p></li> <!-- end will be (at or) after zero -->

     <li><p>Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда сделать <var data-anolis-xref="">end</var> смещением <var data-anolis-xref="">subpath width</var> на <var data-anolis-xref="">L</var>. В другом случае, сделать <var data-anolis-xref="">end</var> смещением <var data-anolis-xref="">position</var> на <var data-anolis-xref="">L</var>.</p></li>

     <li>

      <p>Выполнить один из следующих подэтапов, в зависимости от обстоятельств:</p>

      <dl class="switch">

       <dt>Если <var data-anolis-xref="">segment length</var>  равен нулю и <var data-anolis-xref="">current state</var> равно <i>off</i></dt>

       <dd>

        <p>Ничего не делать, перейти к следующему шагу.</p>

       </dd>


       <dt>Если <var data-anolis-xref="">current state</var> равен <i>off</i></dt>

       <dd>

        <p>Обрезать линию на которой <var data-anolis-xref="">end</var> оказывается коротким <var data-anolis-xref="">end</var> и поместить точку там, сокращая ее содержащий подпуть до двух;
        удалить все сегменты линий, соединения, точки и подпути которые между <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var>; и наконец-то разместить одну точку на <var data-anolis-xref="">start</var> без линий соединенных с ней.</p>

        <p>Точка имеет <i>направленность</i> для целей рисования шапки линии (смотрите ниже).
        Направленность является направлением, которое исходная линия имела в этой точке (т.е. когда <var data-anolis-xref="">L</var> был определен выше).</p>
       </dd>


       <dt>В другом случае</dt>

       <dd>

        <p>Обрезать линию на которой <var data-anolis-xref="">start</var> находят себя в двух на <var data-anolis-xref="">start</var> и поместить точку там, обрезать подпуть в котором их было двое, а также обрезать линию на которой <var data-anolis-xref="">end</var> оказывается коротким на <var data-anolis-xref="">end</var> и поместить точку там, обрезать подпуть <em>в котором</em> их было двое, и затем удалить все отрезки, соединения, точки и подпути которые были между <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var>.</p>

        <p>Если <var data-anolis-xref="">start</var> и <var data-anolis-xref="">end</var> в одной точке, в результате линии сокращаются и две точки вставляется там без удаления чего-либо, если только соединение не происходит в этой точке, тогда соединение тоже удаляется.</p>
       </dd>

      </dl>

     </li>

     <li><p><i>Post-cut</i>: Если <var data-anolis-xref="">position</var> больше чем <var data-anolis-xref="">subpath width</var>, тогда перейти к шагу помеченному как <i>convert</i>.</p></li>

     <li><p>Если <var data-anolis-xref="">segment length</var> больше нуля, определить <var data-anolis-xref="">positioned-at-on-dash</var> как false.</p></li>

     <li><p>Инкрементировать <var data-anolis-xref="">index</var> на единицу. Если он равен количеству записей в
     <var data-anolis-xref="">styles</var> <a href="#dash-list">dash list</a>, тогда определить <var data-anolis-xref="">index</var> как
     0.</p></li>

     <li><p>Перейти к шагу помеченному как <i><a href='#step-dash-on'>dash on</a></i>.</p></li>

    </ol>

   </li>

   <!-- STROKING -->

   <li>

    <p><i>Convert</i>: Это шаг, который преобразует путь к новому пути, который представляет свой ход.</p>

    <p>Создается новый <a href="#concept-path" title="concept-path">path</a>, который описывает края областей которые будут покрыты, если прямая линия длиной равная <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> была охвачена вдоль каждого пути в <var data-anolis-xref="">path</var> в то время как была под углом таким образом, что линия перпендикулярна к пути
    была охвачена, заменив каждую точку с end cap, необходимой для удовлетворения атрибута <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>, как описано выше и подробно рассмотрена ниже, и замена каждого соединения на соединение необходимое, чтобы удовлетворить тип <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineJoin"><a href="#dom-context-2d-linejoin">lineJoin</a></code>, как определено ниже.</p>

    <p><strong>Окончания</strong>: Каждая точка имеет плоский край, перпендикулярной к направлению линии выходящей из нее. Это их дополнение в соответствии со значением из <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineCap"><a href="#dom-context-2d-linecap">lineCap</a></code>. Значение "<code>butt</code>"
    означает, что никакое дополнительное окончание не задано. Значение "<code>round</code>" означает что
    полукруг с диаметром, равным <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, ширина должна быть дополнительно размещена на линии, выходящей из каждой точки. Значение "<code>square</code>" означает что прямоугольник с длинной с <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code> и шириной половины <var data-anolis-xref="">styles</var> <code title="dom-context-2d-lineWidth"><a href="#dom-context-2d-linewidth">lineWidth</a></code>, поверхностью плотно прилегает к краю, перпендикулярной к направлению линии, выходящей из точки, должен быть добавлен в каждой точке.</p>

    <p>Точки без линий выходящих из них должны иметь два окончания расположенные спина-к-спине как если бы это были две точки соединенные друг с другом бесконечно короткой прямой линией.</p>

    <p><strong>Соединения</strong>: В дополнение к точке где происходит соединение, две дополнительные точки
    присоединяются к каждой, одна для каждой линии: одна перпендикулярная для каждой линии, линия на каждой стороне наиболее удаленной от другой линии.</p>

    <p>Значение "<code>bevel</code>" означает что это всё отображено в соединениях.</p>

    <p>Значение "<code>round</code>" означает, что заполненная дуга, соединяющая два вышеупомянутых угла соединения, примыкает (а не перекрывает) к вышеупомянутому треугольнику, с диаметром, равным ширине линии и началом координат в точке соединения, должна быть добавлена в соединения.</p>

    <p>Значение "<code>miter</code>" означает что второй заполненный треугольник должен (если он может с учетом длины скоса) быть добавлен в соединение, с одной линией, будучи линией между двумя вышеупомянутыми углами.</p>

<!-- the actual ratio can't possibly be less than 1.0 -->

<div class="example">
<br>
<p>Ниже неплохой пример miter:</p>
<pre>
  c.clearRect(0, 0, 640, 480);
  c.beginPath();

  c.moveTo((new Date()/100) % 600, 100);
  c.lineTo(300, 300);
  c.lineTo(500, 300);

  c.lineWidth = 50;
  c.miterLimit = 10000;
  c.strokeStyle = 'silver'
  c.stroke();

  c.miterLimit = 0.0001;
  c.strokeStyle = 'black'
  c.stroke();

  c.lineWidth = 1;
  c.strokeStyle = 'red'
  c.stroke();
</pre>
</div>


    <p>Подпути во вновь созданном пути должны проходить по часовой стрелке, независимо от направления путей в <var data-anolis-xref="">path</var>.</p>

    <!-- ...because both of these examples result in two lines (assuming non-zero winding rules,
    things are different under even/odd), there's no "hole" where the lines overlap:

            c.beginPath();
            c.lineWidth=30;
            c.moveTo(200,200); // subpath 1
            c.lineTo(400,200);
            c.moveTo(400,210); // subpath 2
            c.lineTo(200,190);
            c.stroke();

            c.beginPath();
            c.lineWidth=30;
            c.moveTo(200,200); // subpath 1
            c.lineTo(400,200);
            c.lineTo(300,300);
            c.closePath();
            c.moveTo(400,210); // subpath 2
            c.lineTo(200,190);
            c.lineTo(300,300);
            c.closePath();
            c.stroke();

     ...and we want the same result when you create the two subpaths in each example above as two
     Paths, stroke them onto a third Path, and then fill that Path on the context.
    -->

   </li>

   <li><p>Вернуть созданный путь.</p></li>

  </ol>

<!--v6: Another request has been for hairline width lines, that remain hairline width with
transform. ack Shaun Morris. -->


  </div>


  <h2 id="text-styles"><span class="secno">4 </span>Стили текста</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие настройки шрифта.</p>

    <p>Может быть настроен, чтобы изменить шрифт. Синтаксис тот же как и для свойства 'font' в CSS; значения которые не могут прочитаться как значения шрифта в CSS, игнорируются.</p>

    <p>Относящиеся ключевые слова и размеры вычисляются относящимися к шрифту элемента <code>canvas</code>.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие параметры выравнивания текста.</p>

    <p>Может быть настроен, чтобы изменить выравнивание. Возможные значения:
    "<code>start</code>", "<code>end</code>", "<code>left</code>", "<code>right</code>", и "<code>center</code>". Другие значения игнорируются. По умолчанию:
    "<code>start</code>".</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущие настройки выравнивания базовой линии.</p>

    <p>Может быть настроен, чтобы изменить выравнивание базовой линии. Возможные значения и что они означают - написано ниже. Другие значения игнорируются. По умолчанию: "<code>alphabetic</code>".</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Атрибут <dfn id="dom-context-2d-font" title="dom-context-2d-font"><code>font</code></dfn> IDL, при настройке, должен читаться тем же образом что и свойство 'font'
  в CSS (но без поддержки синтаксиса независимых свойств стилей типа 'inherit'), и полученный шрифт должен быть назначен к контексту, с компонентом 'line-height' принужденным к
  'normal', с компонентом 'font-size' конвертированным в пиксели CSS,
  и с системными шрифтами вычисляемыми до явных значений. Если новое значение синтаксически некорректно (включая использование синтаксиса
  независимых свойств стилей типа 'inherit' или
  'initial'), они должны быть игнорированы, без назначения нового значения шрифта. <a href="#refsCSS">[CSS]</a></p>

  <p>Имена шрифтов должны интерпретироваться в контексте <span>font
  style source node</span> таблицы стилей, когда шрифт будет использовать <code>@font-face</code>, поэтому таким образом шрифты должны быть доступны после того как однажды загружены. (Если отсылка к шрифту используется раньше чем он полностью загрузился, либо если <span>font style source node</span> не имеет данного шрифта, то он должен рассматриваться как если бы это был неизвестный шрифт, как это описано в соответствующих спецификациях CSS.) <a href="#refsCSSFONTS">[CSSFONTS]</a></p>

  <p>Только векторные шрифты должны использоваться агентом пользователя; если бы пользовательский агент использовал растровые шрифты, после преобразования, скорее всего, шрифты выглядели бы очень некрасиво.</p>

  <p>При получении, атрибут <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>
  должен возвращать <span title="serializing a CSS
  value">последовательную форму</span> текущего шрифта контекста
  (без компонента 'line-height'). <a href="#refsCSSOM">[CSSOM]</a></p>

  <div class="example">

   <p>Например, после следующего утверждения:</p>

   <pre>context.font = 'italic 400 12px/2 Unknown Font, sans-serif';</pre>

   <p>...выражение <code>context.font</code> будет оценивать строку "<code>italic 12px "Unknown Font", sans-serif</code>". Значение
   "400" font-weight не появляется, потому что это значение по умолчанию. Высота линии не появляется, потому что она приравнивается к "normal" по умолчанию.</p>

  </div>

  <p>Когда контекст создается, шрифт контекста должен быть установлен в 10px
  sans-serif. Когда компонент 'font-size' установлен в длину с помощью процентов, 'em' или 'ex' единицами, или ключевыми словами 'larger' / 'smaller', они должны быть интерпретированы по отношению к расчетному значению свойства 'font-size' от <span>font style source
  node</span> в то время как атрибут установлен, если это элемент. Когда компонент 'font-weight' установлен на относительные значение 'bolder' и 'lighter', они должны быть интерпретированы по отношению к вычисленному значению значению свойства 'font-weight' от <span>font
  style source node</span> в то время как атрибут установлен, если это элемент. Если вычисленные значения не определены для конкретного случая (например потому что <span>font style source
  node</span> не элемент или он не <span>в
  <code>Документе</code></span>), тогда относящиеся ключевые слова должны быть интерпретированы по отношению к normal-weight 10px sans-serif
  по умолчанию.</p>

  <p>Атрибут IDL <dfn id="dom-context-2d-textalign" title="dom-context-2d-textAlign"><code>textAlign</code></dfn>, при получении, должен возвращать текущее значение. При настройке, если значение одно из "<code>start</code>", "<code>end</code>", "<code>left</code>", "<code>right</code>", или "<code>center</code>", то значение должно быть изменено на новое значение. В другом случае, новое значение должно быть проигнорировано. Когда контекст создан, атрибут <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> должен изначально иметь значение "<code>start</code>".</p>

  <p>Атрибут IDL <dfn id="dom-context-2d-textbaseline" title="dom-context-2d-textBaseline"><code>textBaseline</code></dfn>, при получении, должен возвращать текущее значение. При настройке, если значение одно из "<code title="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code>", "<code title="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code>", "<code title="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code>", "<code title="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code>",
  "<code title="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code>",
  или "<code title="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code>",
  то значение должно быть изменено на новое значение. В другом случае, новое значение должно быть проигнорировано. Когда объект реализующий интерфейс
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> создан, атрибут <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> должен изначально иметь значение "<code>alphabetic</code>".</p>

  </div>

  <p>Атрибут <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>
  дает ключевым словам соответствие точкам выравнивания шрифта:</p>

  <!-- this is filler to make sure the TCP packet boundary doesn't fall in the middle of one of the NCRs below -->
  <!-- (because otherwise the parser in anolis screws it up) -->
  <p><img alt="The top of the em square is roughly at the top of the glyphs in a font, the hanging baseline is where some glyphs like आ are anchored, the middle is half-way between the top of the em square and the bottom of the em square, the alphabetic baseline is where characters like Á, ÿ, f, and Ω are anchored, the ideographic baseline is where glyphs like 私 and 達 are anchored, and the bottom of the em square is roughly at the bottom of the glyphs in a font. The top and bottom of the bounding box can be far from these baselines, due to glyphs extending far outside the em square." height="300" src="./baselines.png" width="738"></p>

  <p>Ключевые слова карты по этим точкам выравнивания следующие:</p>

  <dl>

   <dt><dfn id="dom-context-2d-textbaseline-top" title="dom-context-2d-textBaseline-top"><code>top</code></dfn>
   </dt><dd>Верх от em square</dd>

   <dt><dfn id="dom-context-2d-textbaseline-hanging" title="dom-context-2d-textBaseline-hanging"><code>hanging</code></dfn>
   </dt><dd>Висящий на baseline</dd>

   <dt><dfn id="dom-context-2d-textbaseline-middle" title="dom-context-2d-textBaseline-middle"><code>middle</code></dfn>
   </dt><dd>Середина от em square</dd>

   <dt><dfn id="dom-context-2d-textbaseline-alphabetic" title="dom-context-2d-textBaseline-alphabetic"><code>alphabetic</code></dfn>
   </dt><dd>Базовая линия alphabetic</dd>

   <dt><dfn id="dom-context-2d-textbaseline-ideographic" title="dom-context-2d-textBaseline-ideographic"><code>ideographic</code></dfn>
   </dt><dd>Базовая линия ideographic</dd>

   <dt><dfn id="dom-context-2d-textbaseline-bottom" title="dom-context-2d-textBaseline-bottom"><code>bottom</code></dfn>
   </dt><dd>Низ от em square</dd>

  </dl>

  <p><dfn id="text-preparation-algorithm">Алгоритм подготовки текста</dfn> выглядит следующим образом. Он принимает в качестве входной строки <var>text</var>, объект
  <code><a href="#canvasdrawingstyles">CanvasDrawingStyles</a></code> <var>target</var>,
  и опционально длину <var>maxWidth</var>. Он возвращает массив форм глифов, каждый из которых расположен на общем координатном пространстве,
  и <var>physical alignment</var> который имеет значение из:
  <i>left</i>, <i>right</i> и <i title="">center</i>. (Большинство вызывающих этот алгоритм игнорируют <var>physical alignment</var>.)</p>

  <ol>

   <li><p>Если <var>maxWidth</var> был обеспечен но равен нулю или меньше него, возвращается пустой массив.</p></li>

   <li><p>Заменить все <span title="space character">символы пробела</span> в <var>text</var> с U+0020 символами.</p></li>

   <li><p>Сделать <var>font</var> текущим шрифтом <var>target</var>, как дано для объекта атрибута <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>.</p></li>

   <li>

    <p>Применить соответствующий пункт из следующего списка, чтобы определить значение <var>direction</var>:</p>

    <dl class="switch">

     <dt>Если <var>target</var> объекта <span>font style
     source node</span> является элементом</dt>

     <dd>Сделать <var>direction</var> <span>the
     directionality</span> от <var>target</var> объекта
     <span>font style source node</span>.</dd>

     <dt>Если <var>target</var> объекта <span>font style
     source node</span> является <code>Document</code> и этот
     <code>Документ</code> является корневым элементом вложенного</dt>

     <dd>Сделать <var>direction</var> <span>the
     directionality</span> от <var>target</var> объекта
     <span>font style source node</span> вложенного корневого элемента.</dd>

     <dt>Если <var>target</var> объект <span>font style
     source node</span> является <code>Document</code> и этот
     <code>Документ</code> не имеет вложенного элемента корневого</dt>

     <dd>Сделать <var>direction</var> '<span title="concept-ltr">ltr</span>'.</dd>

    </dl>

   </li>

   <li><p>Форма гипотетического бесконечно широкого CSS лайн-бокса, содержащая единственный инлайн-блок, содержащий текст <var>text</var>,
   со всеми свойствами в их изначальных значениях кроме свойства 'font',
   в инлайн-боксе устанавливается <var>font</var>, свойство
   'direction' инлайн-бокса устанавливается <var>direction</var>, и свойство 'white-space' устанавливается к
   'pre'. <a href="#refsCSS">[CSS]</a></p></li>

   <!-- if you insert a step here, make sure to adjust the next step's
   final words -->

   <li><p>Если <var>maxWidth</var> предоставлено и гипотетическая ширина инлайн-бокса в гипотетическом лайн-боксе больше чем <var>maxWidth</var> CSS пикселей, тогда изменить <var>font</var> чтобы иметь более обобщенный шрифт (если он доступен или достаточно читаемый, можно синтезировать с помощью горизонтального коэффициента для шрифта) или меньший шрифт, и вернуться к предыдущему шагу.</p></li>

   <li>

    <p><var>anchor point</var> является точкой на инлайн-боксе, а <var>physical alignment</var> является одним из значений <i>left</i>, <i>right</i>, and <i title="">center</i>. Эти вариации значений <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> и <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> определяются как следующие:</p>

    <p>Горизонтальная позиция:</p>

    <dl>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>left</code></dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>start</code> и <var>direction</var> равняется
     'ltr'</dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>end</code> и <var>direction</var> равняется
     'rtl'</dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> левым краем от инлайн-бокса, и сделать <var>physical alignment</var> равным <i>left</i>.</dd>


     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>right</code></dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>end</code> и <var>direction</var> равняется
     'ltr'</dt>

     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>start</code> и <var>direction</var> равняется
     'rtl'</dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> правым краем инлайн-бокса, и сделать <var>physical alignment</var> равным <i>right</i>.</dd>


     <dt>Если <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> равняется
     <code>center</code></dt>

     <dd>Сделать горизонтальную позицию <var>anchor point</var> ровно посередине между левым и правым краями инлайн-бокса, и сделать <var>physical alignment</var> равной
     <i title="">center</i>.</dd>

    </dl>

    <p>Вертикальная позиция:</p>

    <dl>

     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-top"><a href="#dom-context-2d-textbaseline-top">top</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> верхом от em box первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-hanging"><a href="#dom-context-2d-textbaseline-hanging">hanging</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var>
     висящей на baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-middle"><a href="#dom-context-2d-textbaseline-middle">middle</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> ровно посередине верха и низа от em box первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-alphabetic"><a href="#dom-context-2d-textbaseline-alphabetic">alphabetic</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> the alphabetic baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-ideographic"><a href="#dom-context-2d-textbaseline-ideographic">ideographic</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var> ideographic baseline первого доступного шрифта в инлайн-боксе.</dd>


     <dt>Если <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code> равняется <code title="dom-context-2d-textBaseline-bottom"><a href="#dom-context-2d-textbaseline-bottom">bottom</a></code></dt>

     <dd>Сделать вертикальную позицию <var>anchor point</var>низом от em box первого доступного шрифта в инлайн-боксе.</dd>

    </dl>

   </li>

   <li>

    <p>Сделать <var>result</var> массивом построенным перебиранием каждого глифа в инлайн-боксе от левого до правого (если есть), добавить в массив, для каждого глифа, форму глифа как в инлайн-боксе, расположенную в координатном пространстве с помощью
    CSS пикселей с его началом в <var>anchor
    point</var>.</p>

   </li>

   <li><p>Возвратить <var>result</var> и, для тех кто вызывает его, <var>physical alignment</var> как значение выравнивания.</p></li>

  </ol>


  <h2 id="building-paths"><span class="secno">5 </span>Построение пути</h2>

  <p>Каждый объект реализующий интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>
  имеет <a href="#concept-path" title="concept-path">путь</a> (path). <dfn id="concept-path" title="concept-path">Путь</dfn> имеет список из нуля или больше подпутей.
  Каждый подпуть содержит список из одной или более точек, соединенных прямыми или изогнутыми линиями, и флаг-индикатор является ли подпуть закрытым или нет. Закрытый путь это когда последняя точка подпути соединена с первой точкой подпути прямой линией. Подпути с меньше чем двумя точками игнорируются при рисовании пути.</p>

  <p>Когда объект реализующий интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>
  создан, его <a href="#concept-path" title="concept-path">path</a>
  должен быть инициализирован в ноль подпутей.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Создает новый подпуть с заданной точкой.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-closePath"><a href="#dom-context-2d-closepath">closePath</a></code>()</dt>

   <dd>

    <p>Помечает текущий подпуть как закрытый, и начинает новый подпуть с той же точки что начало и конец только что закрытого подпути.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-lineTo"><a href="#dom-context-2d-lineto">lineTo</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, соединенную с предыдущей прямой линией.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-quadraticCurveTo"><a href="#dom-context-2d-quadraticcurveto">quadraticCurveTo</a></code>(<var>cpx</var>, <var>cpy</var>, <var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, с помощью одной квадратичной кривой Безье с заданной контрольной точкой.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-bezierCurveTo"><a href="#dom-context-2d-beziercurveto">bezierCurveTo</a></code>(<var>cp1x</var>, <var>cp1y</var>, <var>cp2x</var>, <var>cp2y</var>, <var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Добавляет заданную точку в текущий подпуть, соединенную с предыдущей с помощью кубической кривой Безье с заданными контрольными точками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-arcTo"><a href="#dom-context-2d-arcto">arcTo</a></code>(<var>x1</var>, <var>y1</var>, <var>x2</var>, <var>y2</var>, <var>radius</var>)</dt>

   <dd>

    <p>Добавляет дугу с заданными контрольными точками и радиусом к текущему подпути, соединенную с прошлой точкой прямой линией.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если заданный радиус является отрицательным.</p>

    <figure class="diagrams">
     <!-- if anyone wants to try writing alternative text for this, be my guest. I can't work out how to describe it. -->
     <img alt="" src="./arc1.png">
    </figure>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-arc"><a href="#dom-context-2d-arc">arc</a></code>(<var>x</var>, <var>y</var>, <var>radius</var>, <var>startAngle</var>, <var>endAngle</var> [, <var>counterclockwise</var> ] )</dt>

   <dd>

    <p>Добавляет точки в подпуть таким образом что дуга описана окружностями круга описанного аргументами, начиная с заданного стартового угла и заканчивая на заданном конечном угле, идущего в заданном направлении (по умолчанию по часовой стрелке), добавленному в пути, соединенному с предыдущей точкой прямой линией.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если заданный радиус является отрицательным.</p>

<!--
c.clearRect(0, 0, 640, 480);
c.save();
try {
  var x0 = 50;
  var y0 = 200;
  var x = 255;
  var y = 150;
  var radius = 100;
  var startAngle = 2.4
  var endAngle = 0.7;
  var direction = false;

  var bottom = 280;
  var center = 50;

  var fontSize = 16;
  var margin = 50;
  var dotHalfSize = 5;
  var arrowHead = 5;

  // (also update the label positions at the bottom)

  // ========

  function dot(x,y,s) {
    c.beginPath();
    c.arc(x,y,dotHalfSize,0,Math.PI*2);
    c.fill();
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillText(s,x,y+dotHalfSize);
  }

  function arc(x, y, r, sA, eA, d, fr, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'red';
    c.beginPath();
    c.arc(x, y, r, sA, eA, d);
    c.stroke();

    c.save();
    c.translate(x, y);
    c.rotate(eA);
    c.beginPath();
    c.moveTo(r-arrowHead, arrowHead);
    c.lineTo(r, 0);
    c.lineTo(r+arrowHead, arrowHead);
    c.stroke();

    c.strokeStyle = 'silver';
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(fr, 0);
    c.stroke();
    c.restore();

    c.textAlign = 'right';
    c.textBaseline = 'middle';
    c.fillStyle = 'black';
    c.fillText(s + ' ',x-r,y);
  }

  function radial(x, y, length, rotation, s) {
    c.lineWidth = 1;
    c.strokeStyle = 'blue';
    c.save();
    c.translate(x, y);
    c.rotate(rotation);
    c.beginPath();
    c.moveTo(0, 0);
    c.lineTo(length, 0);
    c.stroke();
    c.textAlign = 'center';
    c.textBaseline = 'top';
    c.fillStyle = 'black';
    c.fillText(s,length/2,0);
    c.restore();
  }

  c.font = fontSize + 'px Gill Sans';

  // construction lines
  c.lineWidth = 1;
  c.strokeStyle = 'silver';
  // circle
  c.beginPath();
  c.arc(x, y, radius, 0, 2*Math.PI);
  c.stroke();
  // angles
  arc(x, y, 2*radius/3, 0, startAngle, true, radius, '\u03B1');
  arc(x, y, radius/3, 0, endAngle, true, radius, '\u03B2');
  // radii
  radial(x, y, radius, 0, 'radius');

  // the line
  c.lineWidth = 15;
  c.lineCap = 'round';
  c.strokeStyle = 'rgba(20,200,40,0.8)';
  c.beginPath();
  c.moveTo(x0,y0);
  c.arc(x,y,radius,startAngle,endAngle,direction);
  c.stroke();

  dot(x0,y0, "x\u2080,y\u2080");
  dot(x,y, "x,y");

  c.textAlign = 'left';
  c.textBaseline = 'alphabetic';
  var L = 0;

  function print(s) {
    c.fillText(s, center, bottom+L*fontSize*1.3);
    L += 1;
  }
  print('// the thick line corresponds to:');
  print('context.moveTo(x\u2080, y\u2080)');
  print('context.arc(x, y, radius, \u03B1, \u03B2)');
  print('context.stroke()');

  c.fillStyle = 'green';
  c.fillText("\u25be initial line", x0, y0-fontSize);
  c.textAlign = 'center';
  c.fillText("\u25be arc", x, y-radius-fontSize);

} finally {
  c.restore();
}
-->

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-rect"><a href="#dom-context-2d-rect">rect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Добавляет новый закрытый подпуть в путь, представляющий заданный прямоугольник.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Следующие методы позволяют авторам манипулировать <a href="#concept-path" title="concept-path">путями</a> объектов, реализующих интерфейс <code><a href="#canvaspathmethods">CanvasPathMethods</a></code>.</p>

  <p>Для объектов <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>, точки и линии добавленные к <a href="#current-default-path">current default path</a> с помощью этих методов должны быть преобразованы в соответствии с <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей трансформации</a> перед тем как быть добавлены к пути.</p>


  <p>Метод <dfn id="dom-context-2d-moveto" title="dom-context-2d-moveTo"><code>moveTo(<var>x</var>, <var>y</var>)</code></dfn> должен создать новый подпуть с заданной точкой в качестве первой (и единственной) точки.</p>

  <p>Когда пользовательский агент должен <dfn id="ensure-there-is-a-subpath">обеспечить там подпуть</dfn> для координат (<var>x</var>, <var>y</var>) на
  <a href="#concept-path" title="concept-path">path</a>, агент пользователя должен проверить, чтобы убедиться, что <a href="#concept-path" title="concept-path">path</a> имеет любые подпути,
  и если нет, пользовательский агент должен создать новый подпуть с точкой (<var>x</var>, <var>y</var>) как его первой (и единственной) точкой, как если метод <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code> был вызван.</p>


  <p>Метод <dfn id="dom-context-2d-closepath" title="dom-context-2d-closePath"><code>closePath()</code></dfn>
  не должен ничего делать если путь объекта не имеет подпутей.
  В другом случае, он должен пометить последний подпуть как закрытый, создать новый подпуть первая точка которого та же что и первая точка предыдущего подпути, и наконец довабить этот подпуть к path.</p>

  <p class="note">Если последний подпуть имел больше чем одну точку в своем списке точек, то это эквивалентно добавлению прямой линии, соединяющей последнюю точку с первой точкой, таким образом "закрывает" форму, и потом повторяет последний (возможно подразумеваемый) вызов <code title="dom-context-2d-moveTo"><a href="#dom-context-2d-moveto">moveTo()</a></code>.</p>


  <p>Новые точки и линии соединяющие их добавлены в подпути, с помощью методов описанных ниже. Во всех случаях, методы изменяют только последний подпуть в пути объекта.</p>


  <p>Метод <dfn id="dom-context-2d-lineto" title="dom-context-2d-lineTo"><code>lineTo(<var>x</var>, <var>y</var>)</code></dfn> должен
  <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>x</var>, <var>y</var>)</span> если путь объекта не имеет подпутей. В другом случае, он должен соединить последнюю точку в подпути с заданной точкой (<var>x</var>, <var>y</var>) используя прямую линию, и должен затем добавить заданную точку (<var>x</var>, <var>y</var>) в подпуть.</p>


  <p>Метод <dfn id="dom-context-2d-quadraticcurveto" title="dom-context-2d-quadraticCurveTo"><code>quadraticCurveTo(<var>cpx</var>, <var>cpy</var>, <var>x</var>,
  <var>y</var>)</code></dfn> должен <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>cpx</var>,
  <var>cpy</var>)</span>, и затем должен соединить последнюю точку в подпути с заданной точной (<var>x</var>, <var>y</var>) используя квадратичную кривую Безье с контрольной точкой (<var>cpx</var>, <var>cpy</var>), и должен затем добавить заданную точку (<var>x</var>, <var>y</var>) в подпуть. <a href="#refsBEZIER">[BEZIER]</a></p>


  <p>Метод <dfn id="dom-context-2d-beziercurveto" title="dom-context-2d-bezierCurveTo"><code>bezierCurveTo(<var>cp1x</var>, <var>cp1y</var>, <var>cp2x</var>, <var>cp2y</var>, <var>x</var>, <var>y</var>)</code></dfn> должен
  <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>cp1x</var>, <var>cp1y</var>)</span>, и затем должен соединить последнюю точку в подпути с заданной точкой (<var>x</var>, <var>y</var>) используя кубическую кривую Безье с контрольными точками (<var>cp1x</var>, <var>cp1y</var>) и (<var>cp2x</var>, <var>cp2y</var>). Затем, он должен добавить точку (<var>x</var>, <var>y</var>) в подпуть. <a href="#refsBEZIER">[BEZIER]</a></p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-arcto" title="dom-context-2d-arcTo"><code>arcTo(<var>x1</var>, <var>y1</var>, <var>x2</var>,
  <var>y2</var>, <var>radius</var>)</code></dfn>
  должен сначала <a href="#ensure-there-is-a-subpath">обеспечить там подпуть</a> для <span>(<var>x1</var>, <var>y1</var>)</span>.
  Затем поведение основывается на аргументах и последней точке подпути, как указано ниже.</p>

  <p>Отрицательные значения для <var>radius</var> должны вызвать показ <code>IndexSizeError</code> исключения.

  </p><p>Сделать точку (<var>x0</var>, <var>y0</var>) последней точкой в подпути.</p>

  <p>Если точка (<var>x0</var>, <var>y0</var>) равняется точке (<var>x1</var>, <var>y1</var>),
  или если точка (<var>x1</var>, <var>y1</var>) равняется точке (<var>x2</var>, <var>y2</var>),
  или если радиус <var>radius</var> равен нолю, тогда метод должен добавить точку (<var>x1</var>, <var>y1</var>)
  в подпуть и соединить эту точку с предыдущей точкой (<var>x0</var>, <var>y0</var>) прямой линией.</p>

  <p>В другом случае, если точки (<var>x0</var>, <var>y0</var>), (<var>x1</var>, <var>y1</var>), и (<var>x2</var>, <var>y2</var>) все лежат на одной прямой линии, метод должен добавить точку (<var>x1</var>, <var>y1</var>) в подпуть и соединить эту точку с предыдущей точкой (<var>x0</var>, <var>y0</var>) прямой линией.</p>

  <p>В другом случае, сделать <var>The Arc</var> самой короткой дугой
  заданной окружностью имеющей радиус <var>radius</var> и которая имеет одну точку касательной к полубесконечной линии, которая пересекает точку (<var>x0</var>, <var>y0</var>) и заканчивает в точке (<var>x1</var>,
  <var>y1</var>), и которая имеет другую точку касательную к полубесконечной линии, которая заканчивается в точке (<var>x1</var>, <var>y1</var>), и пересекает точку
  (<var>x2</var>, <var>y2</var>). В точках, в которых этот круг прикасается, эти две называются началом и концом точки касания соответственно. Метод должен соединять точку
  (<var>x0</var>, <var>y0</var>) с точкой касательной старта по прямой линии, добавляя начальную касательную точку в подпуть, затем должен соединить начальную касательную линию с конечной касательной линией к <var>The Arc</var>, добавляя конечную касательную точку в подпуть.</p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-arc" title="dom-context-2d-arc"><code>arc(<var>x</var>, <var>y</var>, <var>radius</var>,
  <var>startAngle</var>, <var>endAngle</var>, <var>counterclockwise</var>)</code></dfn> рисует арку.</p>

  <p> Если контекст имеет какие-либо подпути, то этот метод должен добавить прямую линию от последней точки в подпути к начальной точке дуги.
  В любом случае, он должен нарисовать дугу между начальной точкой дуги и конечной точкой дуги, и добавить эти точки в подпуть. Дуга и ее начальная/конечная точки определяются как следующие:</p>

  <p>Рассмотрим круг, который имеет свое происхождение в (<var>x</var>, <var>y</var>)
  и его радиус <var>radius</var>.
  Точки в <var>startAngle</var> и <var>endAngle</var> окружности этого круга, измеренные в радианах по часовой стрелке от положительной оси х, являются начальной и конечной точкой соответственно.</p>

  <p>Если аргумент <var>counterclockwise</var> ложный и <span><var>endAngle</var>-<var>startAngle</var></span> равняются или более чем <span>2π</span>, или если аргумент <var>counterclockwise</var>
  является <em>true</em> и <span><var>startAngle</var>-<var>endAngle</var></span> равняются или более чем <span>2π</span>, то дуга это вся окружность этого круга.</p>

  <p>В другом случае, дуга это путь по окружности круга от начальной до конечной точки, идущая против часовой стрелки если аргумент <var>counterclockwise</var> равен true, и по часовой стрелке если нет. Так как точки на окружности, а не просто углы от нуля, дуга никогда не может покрыть угол больше чем <span>2π</span> радиус. Если две точки одинаковы или радиус равен нулю, то дуга определяется нулевой длины в обоих направлениях.</p>

  <p>Негативные значение для <var>radius</var> должны вызывать показ
  <code>IndexSizeError</code> исключения.</p>

  <hr>



  <p>Метод <dfn id="dom-context-2d-rect" title="dom-context-2d-rect"><code>rect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен создавать новый подпуть
  содержащий только 4 точки (<var>x</var>, <var>y</var>), (<var>x</var>+<var>w</var>,
  <var>y</var>), (<var>x</var>+<var>w</var>, <var>y</var>+<var>h</var>),
  (<var>x</var>, <var>y</var>+<var>h</var>), с этими четырьмя точками соединенными прямыми линиями, и затем должен пометить подпуть закрытым. Затем он должен создать новый подпуть с точкой (<var>x</var>, <var>y</var>) как единственной.</p>


  <!-- v6 feature request:
        * points as a primitive shape
          http://home.comcast.net/~urbanjost/canvas/vogle4.html
  -->

  </div>


  <h2 id="transformations"><span class="secno">6 </span><dfn title="dom-context-2d-transformation">Преобразования</dfn></h2>

  <p>Каждый объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> имеет
  <i>текущую матрицу преобразования</i>, как и методы (описанные в этом разделе) для управления им. Когда объект
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> создан, его матрица преобразования должна быть инициализирована к идентичности преобразования.</p>

  <p>Матрица преобразования применяется к координатам при создании текущего пути и когда рисуется текст,
  формы, пути на объектах
  <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>.</p> <!-- conformance
  criteria for actual drawing are described in the various sections
  below -->

  <p class="note">Большая часть API использует объекты <code>SVGMatrix</code>, а не этого API. Этот API остается в основном по историческим причинам.</p>

  <div class="impl">

  <p>Преобразования должны быть выполнены в обратном порядке.</p>

  <p class="note">Например, если преобразование масштабированием, которое удваивает ширину, идет перед преобразованием поворотом, при рисовании прямоугольника ширина которого в два раза меньше высоты, фактически выйдет квадрат.</p> <!-- q.v.
  http://goo.gl/5RLrN -->

  </div>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-scale"><a href="#dom-context-2d-scale">scale</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование масштабированием с заданными характеристиками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-rotate"><a href="#dom-context-2d-rotate">rotate</a></code>(<var>angle</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование поворотом с заданными характеристиками. Угол в радианах.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-translate"><a href="#dom-context-2d-translate">translate</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить преобразование перемещения с заданными характеристиками.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-transform"><a href="#dom-context-2d-transform">transform</a></code>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования, чтобы применить матрицу с заданными аргументами, как описано ниже.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-setTransform"><a href="#dom-context-2d-settransform">setTransform</a></code>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</dt>

   <dd>

    <p>Меняет матрицу преобразования <em>на</em> матрицу с заданными аргументами, как описано ниже.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-scale" title="dom-context-2d-scale"><code>scale(<var>x</var>, <var>y</var>)</code></dfn> должен добавить масштабирующее преобразование, описанное аргументами в матрице преобразования. Аргумент <var>x</var> представляет собой масштабный коэффициент в горизонтальном направлении, и аргумент <var>y</var> представляет собой масштабный коэффициент в вертикальном направлении. Факторы являются кратными.</p>

  <p>Метод <dfn id="dom-context-2d-rotate" title="dom-context-2d-rotate"><code>rotate(<var>angle</var>)</code></dfn> должен добавить поворотное преобразование, описанное аргументами в матрице преобразования. Аргумент <var>angle</var> представляет собой
  угол поворота по часовой стрелке выраженный в радианах.</p>

  <p>Метод <dfn id="dom-context-2d-translate" title="dom-context-2d-translate"><code>translate(<var>x</var>, <var>y</var>)</code></dfn> должен добавить преобразование перемещения, описанное аргументами в матрице преобразования. Аргумент <var>x</var> представляет собой
  дистанцию перемещение в горизонтальном направлении, и аргумент <var>y</var> представляет собой дистанцию перемещения в вертикальном направлении. Аргументы в координатном пространстве единиц.</p>

  <p>Метод <dfn id="dom-context-2d-transform" title="dom-context-2d-transform"><code>transform(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, <var>f</var>)</code></dfn> должен заместить текущую матрицу преобразования результатом умножения текущей матрицы и матрицы описанной с помощью:</p>

  </div>

  <table class="matrix">
   <tbody><tr>
    <td><var>a</var></td>
    <td><var>c</var></td>
    <td><var>e</var></td>
   </tr>
   <tr>
    <td><var>b</var></td>
    <td><var>d</var></td>
    <td><var>f</var></td>
   </tr>
   <tr>
    <td>0</td>
    <td>0</td>
    <td>1</td>
   </tr>
  </tbody></table>

  <p class="note">Аргументы <var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>, и <var>f</var> иногда называются
  <var>m11</var>, <var>m12</var>, <var>m21</var>, <var>m22</var>, <var>dx</var>,
  и <var>dy</var> или <var>m11</var>, <var>m21</var>, <var>m12</var>, <var>m22</var>, <var>dx</var>, и <var>dy</var>. Следует проявлять осторожность, в частности, с порядком второго и третьего аргументов (<var>b</var> and <var>c</var>), поскольку их порядок варьируется от API к API и они иногда используют обозначения <var>m12</var>/<var>m21</var> и иногда <var>m21</var>/<var>m12</var> для этих позиций.</p>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-settransform" title="dom-context-2d-setTransform"><code>setTransform(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>,
  <var>f</var>)</code></dfn> должен сбросить текущее преобразование к единичной матрице, затем вызвать метод <code><a href="#dom-context-2d-transform" title="dom-context-2d-transform">transform</a>(<var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>e</var>,
  <var>f</var>)</code> с теми же аргументами.</p>

  </div>

  <h2 id="image-sources-for-2d-rendering-contexts"><span class="secno">7 </span>Источники изображений для 2D рендеринга</h2>

<p>Этот объединенный тип позволяет объектам реализовать любой из следующих интерфейсов как источник изображения:</p>

  <ul><li><code id="image-sources-for-2d-rendering-contexts:htmlimageelement"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-img-element"><a href="http://www.w3.org/TR/html/embedded-content-0.html#the-img-element">img</a></code> элементы)</li><li><code id="image-sources-for-2d-rendering-contexts:htmlvideoelement"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-video-element"><a href="http://www.w3.org/TR/html/embedded-content-0.html#the-video-element">video</a></code> элементы)</li><li><code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> (<code id="image-sources-for-2d-rendering-contexts:the-canvas-element"><a href="http://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">canvas</a></code> элементы)</li></ul>

  <p>Когда агент пользователя должен <dfn id="check-the-usability-of-the-image-argument">проверить пригодность аргумента <var>image</var></dfn>, где <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-2"><a href="#canvasimagesource">CanvasImageSource</a></code>, агент пользователя должен следовать следующим шагам, которые возвращают <i>good</i>, <i>bad</i> или
  <i>aborted</i>:</p>

  <ol><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-2"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> в <a href="http://www.w3.org/TR/html/embedded-content-0.html#img-error" id="image-sources-for-2d-rendering-contexts:img-error">битом</a> состоянии, тогда показать
   <code id="image-sources-for-2d-rendering-contexts:invalidstateerror"><a href="http://www.w3.org/TR/WebIDL-1/#invalidstateerror">InvalidStateError</a></code> исключение, возвратить <i>aborted</i> и прервать эти шаги.</p>

   </li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-3"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> который не <a href="http://www.w3.org/TR/html/embedded-content-0.html#img-good" id="image-sources-for-2d-rendering-contexts:img-good">полностью декодируемый</a> или если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-2"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> который <code id="image-sources-for-2d-rendering-contexts:dom-media-readystate"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-readystate">readyState</a></code> атрибут либо <code id="image-sources-for-2d-rendering-contexts:dom-media-have_nothing"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-have_nothing">ничего не содержит</a></code> или <code id="image-sources-for-2d-rendering-contexts:dom-media-have_metadata"><a href="http://www.w3.org/TR/html/embedded-content-0.html#dom-media-have_metadata">имеет метаданные</a></code>, тогда возвратить <i>bad</i> и прервать эти шаги.</p></li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-4"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> с
   шириной или высотой (или обоими) равными нулю, тогда возвратить <i>bad</i> и прервать эти шаги.</p>

   </li><li><p>Если аргумент <var>image</var> является объектом <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-2"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> с горизонтальной или вертикальной размерностью равными нулю, тогда возвратить <i>bad</i> и прервать эти шаги.</p>

   </li><li><p>Возвратить <i>good</i>.</p></li></ol>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-3"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-5"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code>, изображение элемента должно использоваться как исходное изображение.</p>

  <p>В частности, когда обект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-4"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой анимированное изображение в
  <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-6"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code>, агент пользователя должен использовать дефолтное изображение анимации (то которое формат определяет быть использованным когда анимация не поддерживается или отключена), или если там нет такого изображения, первый кадр анимации при визуализации изображения для
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-3"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API.</p>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-5"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-3"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code>, тогда кадр в <a id="image-sources-for-2d-rendering-contexts:current-playback-position" href="http://www.w3.org/TR/html/embedded-content-0.html#current-playback-position">текущей playback позиции</a>. Когда метод с аргументом вызваны, должно быть использовано исходное изображение при визуализации изображения для
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-4"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> API, и размеры исходного изображения должны быть <a href="http://www.w3.org/TR/html/embedded-content-0.html#concept-video-intrinsic-width" id="image-sources-for-2d-rendering-contexts:concept-video-intrinsic-width">внутренней ширины</a> и <a href="http://www.w3.org/TR/html/embedded-content-0.html#concept-video-intrinsic-height" id="image-sources-for-2d-rendering-contexts:concept-video-intrinsic-height">внутренней высоты</a> от <a id="image-sources-for-2d-rendering-contexts:media-resource" href="http://www.w3.org/TR/html/embedded-content-0.html#media-resource">источника медиа</a>
  (т.е. после того как любая коррекция соотношения была применена).</p>

  <p>Когда объект <code id="image-sources-for-2d-rendering-contexts:canvasimagesource-6"><a href="#canvasimagesource">CanvasImageSource</a></code> представляет собой <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-3"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code>, растровое изображение элемента (bitmap) должно быть использовано как исходное изображение.</p>

  <p><dfn id="the-image-argument-is-not-origin-clean"><var>Аргумент image</var> не изначально чист</dfn> если это
  <code id="image-sources-for-2d-rendering-contexts:htmlimageelement-7"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlimageelement">HTMLImageElement</a></code> или <code id="image-sources-for-2d-rendering-contexts:htmlvideoelement-4"><a href="http://www.w3.org/TR/html/embedded-content-0.html#htmlvideoelement">HTMLVideoElement</a></code> чье <a id="image-sources-for-2d-rendering-contexts:origin-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">начало</a> не <a href="http://www.w3.org/TR/html/browsers.html#same-origin" id="image-sources-for-2d-rendering-contexts:same-origin">то же</a> как <a id="image-sources-for-2d-rendering-contexts:origin-2-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">начало</a> заданное в <a id="image-sources-for-2d-rendering-contexts:entry-settings-object" href="http://www.w3.org/TR/html/webappapis.html#entry-settings-object">объекте настройки</a>, или если это <code id="image-sources-for-2d-rendering-contexts:htmlcanvaselement-4"><a href="http://www.w3.org/TR/html5/scripting-1.html#htmlcanvaselement">HTMLCanvasElement</a></code> битмап которого с ложным флагом <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="image-sources-for-2d-rendering-contexts:concept-canvas-origin-clean">origin-clean</a>, или если это объект
  <code id="image-sources-for-2d-rendering-contexts:canvasrenderingcontext2d-7"><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> битмап которого с ложным флагом <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="image-sources-for-2d-rendering-contexts:concept-canvas-origin-clean-2">origin-clean</a>.</p>

  <h2 id="fill-and-stroke-styles"><span class="secno">8 </span>Стили заполнения и обводки</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль используемый для заполнения форм.</p>

    <p>Может быть установлен, чтобы изменить стиль заполнения.</p>

    <p>Стиль может быть строкой, содержащей цвет CSS, либо
    <code><a href="#canvasgradient">CanvasGradient</a></code> или объект <code><a href="#canvaspattern">CanvasPattern</a></code>. Неверные значения игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий стиль используемый для сглаживания форм.</p>

    <p>Может быть установлен, чтобы изменить стиль сглаживания.</p>

    <p>Стиль может быть строкой содержащей цвет CSS, либо
    <code><a href="#canvasgradient">CanvasGradient</a></code> или объект <code><a href="#canvaspattern">CanvasPattern</a></code>. Неверные значения игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <!-- v6 feature requests:

   * Getting and setting colours by component to bypass the CSS value parsing.

     Either:
        context.fillStyle.red += 1;

     Or:
        var array = context.fillStyle;
        array[1] += 1;
        context.fillStyle = array;

   * A more performant way of setting colours in general, e.g.:

       context.setFillColor(r,g,b,a) // already supported by webkit

     Or:

       context.fillStyle = 0xRRGGBBAA; // set a 32bit int directly

   * fill rule for deciding between winding and even-odd algorithms.
     SVG has fill-rule: nonzero | evenodd
       http://www.w3.org/TR/SVG/painting.html#FillProperties
     see also mozFillRule: http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-June/032002.html

  -->

  <p>Атрибут <dfn id="dom-context-2d-fillstyle" title="dom-context-2d-fillStyle"><code>fillStyle</code></dfn>
  представляет собой цвет или стиль используемый внутри форм, и атрибут <dfn id="dom-context-2d-strokestyle" title="dom-context-2d-strokeStyle"><code>strokeStyle</code></dfn>
  представляет собой цвет или стиль используемый для линий вокруг форм.</p>

  <p>Оба атрибута могут быть строки или
  <code><a href="#canvasgradient">CanvasGradient</a></code>, или <code><a href="#canvaspattern">CanvasPattern</a></code>. При настройке, строки должны быть <span title="parsed as a CSS <color>
  value">прочитаны как значения цвета CSS</span>. Объекты <code><a href="#canvasgradient">CanvasGradient</a></code> и
  <code><a href="#canvaspattern">CanvasPattern</a></code> должны назначать сами себя <a href="#refsCSSCOLOR">[CSSCOLOR]</a>. Если значение строчное, но не может быть <span>прочитано как значение цвета CSS</span>, не является строкой <code><a href="#canvasgradient">CanvasGradient</a></code> или
  <code><a href="#canvaspattern">CanvasPattern</a></code>, тогда должно быть проигнорировано и атрибут должен возвратиться к предыдущему значению. Если новое значение это объект <code id="fill-and-stroke-styles:canvaspattern-5"><a href="#canvaspattern">CanvasPattern</a></code> помеченный как <a style="" href="#concept-canvas-pattern-not-origin-clean" id="fill-and-stroke-styles:concept-canvas-pattern-not-origin-clean">not origin-clean</a>, тогда флаг битмапа <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="fill-and-stroke-styles:concept-canvas-origin-clean">origin-clean</a> должен быть поставлен ложный.</p>

  <p>Когда контекст создан, атрибуты <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> и <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> должны изначально иметь строчное значение <code>#000000</code>.</p>

  <p>Если значение является цветом, на него не должна влиять матрица преобразования.</p> <!-- so
  singular matrices don't affect solid color fillStyles -->

  </div>

  <hr>

  <p>Существует два типа градиентов, линейный градиент и радиальный, оба представлены объектами реализующими непрозрачный интерфейс <code><a href="#canvasgradient">CanvasGradient</a></code>.</p>

  <p id="interpolation">Когда градиент был создан (смотрите выше),
  остановки (stops) расположены вдоль него, чтобы определить, как цвета распределены вдоль градиента. <span class="impl">Цвет градиента на
  каждой остановке это цвет указанный для нее. Между каждой такой остановкой цвета и альфа-компонент должны быть линейно интерполированы над RGBA пространством без умножения альфа значения, чтобы найти цвет используемый на этом смещении. Перед первой остановкой, цвет должен быть цветом первой остановки. После последней остановки, цвет должен быть цветом последней остановки. Когда нет остановок, градиент является прозрачным черным.</span></p>

  <dl class="domintro">

   <dt><var>gradient</var> . <code title="dom-canvasgradient-addColorStop"><a href="#dom-canvasgradient-addcolorstop">addColorStop</a></code>(<var>offset</var>, <var>color</var>)</dt>

   <dd>

    <p>Добавляет цвет остановки с заданным цветом градиента на заданное смещение. 0.0 это смещение на одном конце градиента, 1.0 - на другом.</p>

    <p>Выдает исключение <code>IndexSizeError</code> если смещение не в диапазоне. Выдает исключение <code>SyntaxError</code> если цвет не может быть прочитан.</p>

   </dd>

   <dt><var>gradient</var> = <var>context</var> . <code title="dom-context-2d-createLinearGradient"><a href="#dom-context-2d-createlineargradient">createLinearGradient</a></code>(<var>x0</var>, <var>y0</var>, <var>x1</var>, <var>y1</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvasgradient">CanvasGradient</a></code> который представляет линейный градиент, рисующий вдоль заданной линии с помощью координат.</p>

   </dd>

   <dt><var>gradient</var> = <var>context</var> . <code title="dom-context-2d-createRadialGradient"><a href="#dom-context-2d-createradialgradient">createRadialGradient</a></code>(<var>x0</var>, <var>y0</var>, <var>r0</var>, <var>x1</var>, <var>y1</var>, <var>r1</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvasgradient">CanvasGradient</a></code>, представляющий радиальный градиент, рисующий вдоль конуса с помощью кругов представленных в аргументах.</p>

    <p>Если какой-то из радиусов негативный, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдает</a> исключение <code>IndexSizeError</code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-canvasgradient-addcolorstop" title="dom-canvasgradient-addColorStop"><code>addColorStop(<var>offset</var>, <var>color</var>)</code></dfn>
  на интерфейсе <code><a href="#canvasgradient">CanvasGradient</a></code> добавляет новую остановку
  в градиент. Если <var>offset</var> меньше чем 0 или больше чем 1, тогда должно быть показано исключение <code>IndexSizeError</code>. Если <var>color</var> не может быть <span>прочитан как значение
  CSS &lt;color&gt;</span>, тогда показывается исключение <code>SyntaxError</code>. В другом случае, градиент должен иметь размещенную остановку на смещении <var>offset</var> по отношению ко всему градиенту и цветом полученным при чтении <var>color</var> как значения CSS &lt;color&gt;. Если множество остановок
  добавляются в одно и тоже смещение, они должны быть расположены в порядке добавления, с первой на начале градиента и каждой последующей на ничтожном растоянии от друг друга вдоль линии.</p>

  <p>Метод <dfn id="dom-context-2d-createlineargradient" title="dom-context-2d-createLinearGradient"><code>createLinearGradient(<var>x0</var>, <var>y0</var>, <var>x1</var>,
  <var>y1</var>)</code></dfn> принимает четыре аргумента, которые представляют собой начальную точку (<var>x0</var>, <var>y0</var>) и конечную точку (<var>x1</var>, <var>y1</var>) градиента. Метод должен возвратить линейный
  <code><a href="#canvasgradient">CanvasGradient</a></code> инициализируемый в указанной строке.</p>

  <p>Линейные градиенты должны визуализироваться таким образом, чтоб все точки на линии
  перпендикулярной к линии пересекающей начальную и конечную точку, имели
  цвет в точке где эти две линии пересекаются (с цветами исходящими от <a href="#interpolation">интерполяции и экстраполяции</a> описанных выше). Точки в линейном градиенте должны преобразоваться как описано <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей преобразования</a> при визуализации (рендеринге).</p>

  <p>Если <span><var>x0</var> = <var>x1</var></span> и <span><var>y0</var> = <var>y1</var></span>, то линейный градиент не должен рисовать ничего.</p>

  <p>Метод <dfn id="dom-context-2d-createradialgradient" title="dom-context-2d-createRadialGradient"><code>createRadialGradient(<var>x0</var>, <var>y0</var>, <var>r0</var>,
  <var>x1</var>, <var>y1</var>, <var>r1</var>)</code></dfn> принимает шесть аргументов, первые три представляют собой
  начало круга с началом (<var>x0</var>, <var>y0</var>) и радиусом <var>r0</var>, последние три представляют собой конец круга
  с началом (<var>x1</var>, <var>y1</var>) и радиусом <var>r1</var>. Значения в координатном пространстве единиц. Если что-то из <var>r0</var> или <var>r1</var>
  являются негативными, должно показаться исключение <code>IndexSizeError</code>. В другом случае, метод должен возвратить радиальный
  <code><a href="#canvasgradient">CanvasGradient</a></code> с двумя заданными кругами.</p>

  <p>Радиальные градиенты должны быть визуализированы при помощи следующих шагов:</p>

  <ol>

   <li><p>Если <span><var>x<sub>0</sub></var> = <var>x<sub>1</sub></var></span> и <span><var>y<sub>0</sub></var> = <var>y<sub>1</sub></var></span> и <span><var>r<sub>0</sub></var> = <var>r<sub>1</sub></var></span>, то радиальный градиент не должен рисовать ничего. Прервать эти шаги.</p></li>

   <li>

    <p>Сделать <span>x(<var>ω</var>) = (<var>x<sub>1</sub></var>-<var>x<sub>0</sub></var>)<var>ω</var> + <var>x<sub>0</sub></var></span></p>

    <p>Сделать <span>y(<var>ω</var>) = (<var>y<sub>1</sub></var>-<var>y<sub>0</sub></var>)<var>ω</var> + <var>y<sub>0</sub></var></span></p>

    <p>Сделать <span>r(<var>ω</var>) = (<var>r<sub>1</sub></var>-<var>r<sub>0</sub></var>)<var>ω</var> + <var>r<sub>0</sub></var></span></p>

    <p>Сделать цвет в <var>ω</var> цветом в позиции на градиенте (с цветами исходящими из <a href="#interpolation">интерполяции и экстраполяции</a>
    описанных выше).</p>

   </li>

   <li><p>Для всех значений <var>ω</var> где <span>r(<var>ω</var>) &gt; 0</span>,
   начинать со значения <var>ω</var> ближайшего к
   положительной бесконечности и заканчивать со значением <var>ω</var> ближайшим к негативной бесконечности, нарисовать окружность с радиусом <span>r(<var>ω</var>)</span> на позиции (<span>x(<var>ω</var>)</span>, <span>y(<var>ω</var>)</span>), с цветом в <var>ω</var>, но только рисовать на частях холста (canvas) которые еще не были зарисованы раннее на этом шаге.</p></li>

  </ol>

  <p class="note">Это фактически создает конус, затронутый двумя кругами определенными в создании градиента, с частью конуса перед началом круга (0.0) цвета первого смещения и частью конуса после конечного круга (1.0) цвета последнего смещения, а зоны за конусом не затронуты градиентом (прозрачный черный).</p>

  <p>Полученный в результате радиальный градиент должен затем быть преобразован как описано в <a href="#transformations" title="dom-context-2d-transformation">текущей матрице преобразования</a> когда визуализируется.</p>

  <p>Градиенты должны быть нарисованы только когда соответствующие сглаживания или
  эффекты заполнения требуют чтобы они были нарисованы.</p>

  </div>

  <hr>

  <p>Паттерны представлены объектами реализующими прозрачный
  <code><a href="#canvaspattern">CanvasPattern</a></code> интерфейс.</p>

  <dl class="domintro">

   <dt><var>pattern</var> = <var>context</var> . <code title="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern</a></code>(<var>image</var>, <var>repetition</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#canvaspattern">CanvasPattern</a></code> который использует данное изображение
    и повторяет в направлении заданном аргументом <var>repetition</var>.</p>

    <p>Допустимые значения <var>repetition</var>: "<code>repeat</code>" (оба направления), "<code>repeat-x</code>" (горизонтальное), "<code>repeat-y</code>" (вертикальное) и "<code>no-repeat</code>" (ни один). Если аргумент <var>repetition</var> пуст, значение <code>repeat</code> используется.</p>

    <p>Если изображение не имеет данных, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>InvalidStateError</code>. Если второй аргумент
    не один из допустимых, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение <code>SyntaxError</code>. Если изображение еще не полностью декодировано, то аргумент возвращает null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Для создания объектов этого типа используется метод <dfn id="dom-context-2d-createpattern" title="dom-context-2d-createPattern"><code>createPattern(<var>image</var>, <var>repetition</var>)</code></dfn>. Когда метод вызван, пользовательский агент должен выполнить следующие шаги:</p>

  <ol>
  <li>Сделать <var>image</var> первым аргументом и <var>repetition</var> — вторым.</li>
  <li><a href="#check-the-usability-of-the-image-argument">Проверить пригодность аргумента изображения</a>. Если это возвращает <var>aborted</var>, тогда показывается исключение и метод не возвращает ничего; прервать эти шаги. Если возвращает <var>bad</var>, тогда возвратить null прервать эти шаги. В другом случае это возвращает <var>good</var>; продолжить эти шаги.</li>
  <li>Если <var>repetition</var> пустая строка, сделать ее "<code>repeat</code>".</li>
  <li>Если <var>repetition</var> не один из: "<code>repeat</code>", "<code>repeat-x</code>", "<code>repeat-y</code>", or "<code>no-repeat</code>", выдать исключение <var>SyntaxError</var> и прервать эти шаги.</li>
  <li>Создать новый объект <code><a href="#canvaspattern">CanvasPattern</a></code> с изображением <var>image</var> и поведением повторения заданным <var>repetition</var>.</li>
  <li>Если <a href="#the-image-argument-is-not-origin-clean">если аргумент не origin-clean</a>, пометить объект <code><a href="#canvaspattern">CanvasPattern</a></code> как <dfn id="concept-canvas-pattern-not-origin-clean"><i>not origin-clean</i></dfn>.</li>
  <li>Возвратить объект <code><a href="#canvaspattern">CanvasPattern</a></code>.</li>
  </ol>
  <p>
  Изменения этого <var>изображения</var> после вызова метода <code title="dom-context-2d-createPattern"><a href="#dom-context-2d-createpattern">createPattern()</a></code> не должно влиять на паттерн. </p>

  <p>Паттерны должны быть нарисованы так что верхняя левая часть первого изображения
  закреплена в начале координатного пространства, затем изображения повторяются по горизонтали слева направо, если
  строка была задана строка <code>repeat-x</code>, или вертикально сверху
  вниз, если была задана строка <code>repeat-y</code>, или во всех четырех направлениях всего холста, если была задана строка <code>repeat</code>. Изображения не масштабируются в этом процессе; один CSS
  пиксель изображения должен быть нарисован на одной координатной единице. Когда отображено, однако, паттерны
  должны быть нарисованы только там где эффекты сглаживания или заполнения
  требуют этого, и паттерн повторения должен быть
  затронут <a href="#transformations" title="dom-context-2d-transformation">текущей матрицей преобразования</a>. Пиксели не охватываемые паттерном повторения (если строка <code>repeat</code> не задана) должны быть прозрачными черными.</p>

  <p>Если данные исходного изображения растровые, значение нарисованное
  в точке в зоне повторений вычисляются фильтрованием данных исходного изображения. Пользовательский агент может использовать любой алгоритм фильтрования (например, билинейной интерполяции или схожий).
  <!-- drawImage() has a similar paragraph with different rules -->

  </p>

  <!--
   Requests for v5 features:
    * apply transforms to patterns, so you don't have to create
      transformed patterns manually by rendering them to an off-screen
      canvas then using that canvas as the pattern.
  -->

  </div>

  <div class="impl">

  <hr>

  <p>Если радиальный градиент или паттерн повторения используется когда
  матрица преобразования сингулярна, в результате стиль должен быть
  прозрачный черный (в другом случае градиент или паттерн
  разрушились бы до точки или линии, оставив другие пиксели неопределенными).
  Линейные градиенты и цвета всегда определяют все точки даже с
  сингулярной матрицей преобразования.</p>

  </div>




  <h2 id="drawing-rectangles-to-the-canvas"><span class="secno">9 </span>Рисование прямоугольников на холсте</h2>

  <p>Есть три метода которые сразу рисуют прямоугольники на битмапе. Каждый из них принимает четыре аргумента; первые два задают координаты <var>x</var> и <var>y</var> верхнего левого угла, а вторые два задают ширину <var>w</var> и высоту <var>h</var> прямоугольника, соответственно.</p>

  <div class="impl">

  <p><a href="#transformations" title="dom-context-2d-transformation">Текущая матрица преобразования</a> должна быть применена к следующим четырем координатам, которые формируют путь который затем должен быть закрыт чтобы получился заданный прямоугольник: <span>(<var>x</var>, <var>y</var>)</span>, <span>(<span><var>x</var>+<var>w</var></span>, <var>y</var>)</span>,
  <span>(<span><var>x</var>+<var>w</var></span>,
  <span><var>y</var>+<var>h</var></span>)</span>,
  <span>(<var>x</var>, <span><var>y</var>+<var>h</var></span>)</span>.</p>

  <p>Фигуры рисуются без влияния <a href="#current-default-path">current default
  path</a> и подлежат <a href="#clipping-region" title="clipping
  region">clipping region</a>, за исключением <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code>, также <a href="#shadows" title="shadows">эффектов теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, and <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global операторов</a>.</p>

  </div>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Очищает все пиксели на холсте в заданном прямоугольнике к прозрачному черному.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-fillRect"><a href="#dom-context-2d-fillrect">fillRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Рисует заданный прямоугольник на холсте, используя текущий стиль заполнения.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-strokeRect"><a href="#dom-context-2d-strokerect">strokeRect</a></code>(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</dt>

   <dd>

    <p>Рисует прямоугольник на холст, используя текущий строчный стиль.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-clearrect" title="dom-context-2d-clearRect"><code>clearRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Сделать<var>pixels</var> сетом пикселей в заданном прямоугольнике, которые также пересекают текущий clipping
   region.</p></li>

   <li><p>Очистить пиксели в <var>pixels</var> к полностью прозрачному черному, удаляя любое предыдущее изображение.</p></li>

   <li><p><span>Очистить регионы которые покрывают пиксели</span> в <var>pixels</var> в элементе <code>canvas</code>.</p></li>

  </ol>

  <p class="note">Если высота или ширина равна нулю, этот метод не имеет эффекта, так как сет пикселей будет пустым.</p>

  <p>Метод <dfn id="dom-context-2d-fillrect" title="dom-context-2d-fillRect"><code>fillRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен нарисовать указанную прямоугольную область в <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>. Если ширина или высота равна нулю, этот метод не имеет эффекта.</p>

  <p>Метод <dfn id="dom-context-2d-strokerect" title="dom-context-2d-strokeRect"><code>strokeRect(<var>x</var>, <var>y</var>, <var>w</var>, <var>h</var>)</code></dfn> должен принять результат от <a href="#trace-a-path" title="trace a path">tracing the path</a> описанного ниже, используя стили линий объекта <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> и
  заполнить с <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>.</p>

  <p>Если оба <var>w</var> и <var>h</var> равны нулю,
  путь имеет один подпуть только с одной точкой (<var>x</var>, <var>y</var>), без линий, и этот метод не имеет эффекта (алгоритм <a href="#trace-a-path">trace a path</a> возвращает пустой путь в этом случае).</p>

  <p>Если только один из <var>w</var> и <var>h</var> равен нулю, тогда путь имеет один подпуть с двумя точками, с координатами (<span><var>x</var></span>, <span><var>y</var></span>) и (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>+<var>h</var>), в этом порядке,
  соединенные одной прямой линией.</p>

  <p>В другом случае, путь имеет один подпуть содержащий четыре точки с координатами (<span><var>x</var></span>, <span><var>y</var></span>), (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>), (<span><var>x</var>+<var>w</var></span>, <span><var>y</var></span>+<var>h</var>) и (<span><var>x</var></span>, <span><var>y</var>+<var>h</var></span>), соединенные друг с другом прямыми линиями.</p>

  </div>



  <h2 id="drawing-text-to-the-canvas"><span class="secno">10 </span>Рисование текста на холсте</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText</a></code>(<var>text</var>, <var>x</var>, <var>y</var> [, <var>maxWidth</var> ] )</dt>
   <dt><var>context</var> . <code title="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText</a></code>(<var>text</var>, <var>x</var>, <var>y</var> [, <var>maxWidth</var> ] )</dt>

   <dd>

    <p>Заполнения и обводки (соответственно) заданного текста на заданной позиции. Если максимальная ширина задана, при необходимости текст будет отрегулирован чтобы соответствовать ей.</p>

   </dd>

   <dt><var>metrics</var> = <var>context</var> . <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText</a></code>(<var>text</var>)</dt>

   <dd>

    <p>Возвращает объект <code><a href="#textmetrics">TextMetrics</a></code> с метрикой данного текста в текущем шрифте.</p>

   </dd>

   <dt><var>metrics</var> . <code title="dom-textmetrics-width"><a href="#dom-textmetrics-width-0">width</a></code></dt>

   <dd>

    <p>Возвращает ширину текста, который был передан методом
    <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Интерфейс <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> обеспечивает следующие методы для отображения текста непосредственно на холст.</p>

  <p>Методы <dfn id="dom-context-2d-filltext" title="dom-context-2d-fillText"><code>fillText()</code></dfn> и
  <dfn id="dom-context-2d-stroketext" title="dom-context-2d-strokeText"><code>strokeText()</code></dfn>
 принимают три или четыре аргумента: <var>text</var>, <var>x</var>, <var>y</var>, и опционально <var>maxWidth</var>, и отображают заданный <var>text</var> на заданных (<var>x</var>, <var>y</var>) координатах, обеспечивая текст не шире
  чем <var>maxWidth</var> если это задано, используя текущие значения
  <code title="dom-context-2d-font"><a href="#dom-context-2d-font">font</a></code>, <code title="dom-context-2d-textAlign"><a href="#dom-context-2d-textalign">textAlign</a></code> и <code title="dom-context-2d-textBaseline"><a href="#dom-context-2d-textbaseline">textBaseline</a></code>. А именно, когда методы вызываются, агент пользователя должен выполнить следующие шаги:</p>

  <ol>

   <li><p>Запустить <a href="#text-preparation-algorithm">алгоритм подготовки текста</a>, передавая ему
   <var>text</var>, объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>
   и, если аргумент <var>maxWidth</var> был задан, этот аргумент. Сделать <var>glyphs</var> результатом.</p>

   </li><li><p>Переместить все фигуры в <var>glyphs</var> вправо на <var>x</var> CSS пикселей и вниз на <var>y</var> CSS пикселей.</p></li>

   <li>

    <p>Нарисовать формы заданные в <var>glyphs</var>, как преобразованные с помощью <a href="#transformations" title="dom-context-2d-transformation">текущей матрицы преобразования</a>, с каждым CSS пикселем в координатном пространстве <var>glyphs</var>.</p>

    <p>Для <code title="dom-context-2d-fillText"><a href="#dom-context-2d-filltext">fillText()</a></code>,
    <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> должен применяться к формам и <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code> должен быть проигнорирован. Для <code title="dom-context-2d-strokeText"><a href="#dom-context-2d-stroketext">strokeText()</a></code> наоборот: <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>
    должен примениться к результату <a href="#trace-a-path" title="trace a
    path">начертания</a> с помощью объекта
    <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> для стилей линий,
    и <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code> должен быть проигнорирован.</p>

    <p>Эти формы рисуются без влияния текущего пути
    и подлежат <a href="#shadows" title="shadows">эффектам теней</a>,
    <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>,
    <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

   </li>

   <li><p>Если <a href="#text-preparation-algorithm" id="drawing-text-to-the-bitmap:text-preparation-algorithm-2">алгоритм подготовки текста</a> использует шрифт который имеет <a id="drawing-text-to-the-bitmap:origin-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">происхождение</a>,
   которое не <a href="http://www.w3.org/TR/html/browsers.html#same-origin" id="drawing-text-to-the-bitmap:same-origin">то же</a>, что <a id="drawing-text-to-the-bitmap:origin-2-2" href="http://www.w3.org/TR/html/browsers.html#origin-0">происхождение</a> описанное в <a id="drawing-text-to-the-bitmap:entry-settings-object" href="http://www.w3.org/TR/html/webappapis.html#entry-settings-object">entry settings object</a> (даже если "использование шрифта" означает просто проверку имеет ли этот шрифт особый глиф, перед переходом к другому шрифту), тогда установить флаг битмапа <a href="http://www.w3.org/TR/html/scripting-1.html#concept-canvas-origin-clean" id="drawing-text-to-the-bitmap:concept-canvas-origin-clean">origin-clean</a> ложным.</p></li>
  </ol>

<!--v6DVT - this is commented out until CSS can get its act together
enough to actual specify vertical text rendering (how long have we
been waiting now?)

WHEN EDITING THIS, FIX THE PARTS MARKED "&#x0058;&#x0058;&#x0058;" BELOW

ALSO NOTE THAT THIS PROBABLY NEEDS ENTIRELY REVISITING NOW THAT WE
HAVE REJIGGED HOW TEXT WORKS IN v5

  <p>The <dfn
  title="dom-context-2d-fillVerticalText"><code>fillVerticalText()</code></dfn>
  and <dfn
  title="dom-context-2d-strokeVerticalText"><code>strokeVerticalText()</code></dfn>
  methods take three or four arguments, <var>text</var>, <var
  title="">x</var>, <var>y</var>, and optionally <var
  title="">maxHeight</var>, and render the given <var
  title="">text</var> as vertical text at the given (<var
  title="">x</var>, <var>y</var>) coordinates ensuring that
  the text isn't taller than <var>maxHeight</var> if
  specified, using the current <code
  title="dom-context-2d-font">font</code> and <code
  title="dom-context-2d-textAlign">textAlign</code>
  values. Specifically, when the methods are called, the user agent
  must run the following steps:</p>

  <ol>

   <li><p>If <var>maxHeight</var> is present but less than or
   equal to zero, return without doing anything; abort these
   steps.</p></li>

   <li><p>Let <var>font</var> be the current font of the
   context, as given by the <code
   title="dom-context-2d-font">font</code> attribute.</p></li>

   <li><p>Replace all the <span title="space character">space
   characters</span> in <var>text</var> with U+0020 SPACE
   characters.</p></li>

   <li><p>Form a <em class="&#x0058;&#x0058;&#x0058;">whatever CSS ends up calling
   vertical line boxes and inline boxes</em> containing the text <var
   title="">text</var>, with all the properties at their initial
   values except the 'font' property of the inline box set to <var
   title="">font</var> and the 'direction' property of the inline
   box set to <span>the directionality</span> of the <code>canvas</code>
   element.</p></li>

   <!- - if you insert a step here, make sure to adjust the next step's
   final words - ->

   <li><p>If the <var>maxHeight</var> argument was specified
   and the hypothetical height of the <em class="&#x0058;&#x0058;&#x0058;">box</em>
   in the hypothetical line box is greater than <var
   title="">maxHeight</var> CSS pixels, then change <var
   title="">font</var> to have a more condensed font (if one is
   available or if a reasonably readable one can be synthesized by
   applying an appropriate scale factor to the font) or a smaller
   font, and return to the previous step.</p></li>

   <li>

    <p>Let the <var>anchor point</var> be a point on the <em
    class="&#x0058;&#x0058;&#x0058;">inline box</var>, determined by the <code
    title="dom-context-2d-textAlign">textAlign</code>, as follows:</p>

    <p>Vertical position:</p>

    <dl>

     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">start</code></dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">left</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'ltr'</dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">right</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var>anchor point</var>'s vertical
     position be the top edge of the <em class="&#x0058;&#x0058;&#x0058;">inline
     box</em>.</dd>

     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">end</code></dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">right</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'ltr'</dt>
     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">left</code> and <span>the directionality</span> of the
     <code>canvas</code> element is 'rtl'</dt>

     <dd>Let the <var>anchor point</var>'s vertical
     position be the bottom edge of the <em class="&#x0058;&#x0058;&#x0058;">inline
     box</em>.</dd>


     <dt>If <code
     title="dom-context-2d-textAlign">textAlign</code> is <code
     title="">center</code></dt>

     <dd>Let the <var>anchor point</var>'s vertical position
     be halfway between the top and bottom edges of the <em
     class="&#x0058;&#x0058;&#x0058;">inline box</em>.</dd>


    </dl>

    <p>Let the horizontal position be half way between the left and
    right edges of the em box of the first available font of the <em
    class="&#x0058;&#x0058;&#x0058;">inline box</em>.</p>

   </li>

   <li>

    <p>Paint the hypothetical inline box as the shape given by the
    text's glyphs, as transformed by the <span
    title="dom-context-2d-transformation">current transformation
    matrix</span>, and anchored and sized so that before applying the
    <span title="dom-context-2d-transformation">current transformation
    matrix</span>, the <var>anchor point</var> is at (<var
    title="">x</var>, <var>y</var>) and each CSS pixel is
    mapped to one coordinate space unit.</p>

    <p>For <code
    title="dom-context-2d-fillVerticalText">fillVerticalText()</code>
    <code title="dom-context-2d-fillStyle">fillStyle</code> must be
    applied and <code
    title="dom-context-2d-strokeStyle">strokeStyle</code> must be
    ignored. For <code
    title="dom-context-2d-strokeVerticalText">strokeVerticalText()</code>
    the reverse holds and <code
    title="dom-context-2d-strokeStyle">strokeStyle</code> must be
    applied and <code
    title="dom-context-2d-fillStyle">fillStyle</code> must be
    ignored.</p>

    <p>Text is painted without affecting the current path, and is
    subject to <span title="shadows">shadow effects</span>, <span
    title="dom-context-2d-globalAlpha">global alpha</span>, the <span
    title="clipping region">clipping region</span>, and <span
    title="dom-context-2d-globalCompositeOperation">global composition
    operators</span>.</p>

   </li>

   <li>
       <p>If the text preparation algorithm used a font that has an <span>origin</span> that is not the same
	   as the entry script's <span>origin</span> even if "using a font" means just checking if that font has a particular glyph in it before falling back to another font), then set the <i>origin-clean</i> flag to false.
	   </p>
   </li>
  </ol>

v6DVT (also check for '- -' bits in the part above) -->

  <p>Метод <dfn id="dom-context-2d-measuretext" title="dom-context-2d-measureText"><code>measureText()</code></dfn>
  принимает один аргумент, <var>text</var>. Когда метод
  вызван, пользовательский агент должен запустить алгоритм подготовки текста, передать
  новый объект TextMetrics с его атрибутами установленными как описано в следующем списке.
  Если при выполнении этих измерений необходимо использовать шрифт, который имеет
  <span>происхождение</span> которое не <span title="same
  origin">то же</span> что у объекта <code>Document</code> который
  содержит элемент <code>canvas</code> (даже если "использование шрифта" означает
  просто проверку имеет ли этот шрифт особый глиф, перед
  переходом к другому шрифту), тогда метод должен выдать исключение
  <code>SecurityError</code>.
  В другом случае, он должен возвратить новый объект <code><a href="#textmetrics">TextMetrics</a></code>.
  <a href="#refsCSS">[CSS]</a>

  </p>

  <dl>
  <dt>Атрибут <dfn id="dom-textmetrics-width" title="dom-textmetrics-width"><code>width</code></dfn></dt>

   <dd>
   <p>Ширина этого инлайн-бокса в CSS пикселях. (Расстояние между глифами в тексте.)</p>
   </dd>

  </dl>

<!--ADD-TOPIC:Security-->
  Если при выполнении этих измерений необходимо использовать шрифт, который имеет
  <span>происхождение</span> которое не <span title="same
  origin">то же</span> что у объекта <code>Document</code> который имеет
  содержит элемент <code>canvas</code> (даже если "использование шрифта" означает
  просто проверку имеет ли этот шрифт особый глиф, перед
  переходом к другому шрифту), тогда метод должен выдать исключение
  <code>SecurityError</code>.
<!--REMOVE-TOPIC:Security-->
  В другом случае, он должен возвратить новый объект <code><a href="#textmetrics">TextMetrics</a></code>.
  <a href="#refsCSS">[CSS]</a>

  <p></p>

  <p>Интерфейс <code><a href="#textmetrics">TextMetrics</a></code> используется для объектов
  возвращенных от <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>. Он имеет один атрибут, <dfn id="dom-textmetrics-width-0" title="dom-textmetrics-width"><code>width</code></dfn>, который устанавливается методом <code title="dom-context-2d-measureText"><a href="#dom-context-2d-measuretext">measureText()</a></code>.</p>

  </div>

  <p class="note">Будущая версия 2D context API может обеспечивать
  путь к отображению фрагментов документов с помощью CSS, прямо на холст.</p>



  <h2 id="drawing-paths-to-the-canvas"><span class="secno">11 </span>Рисование пути на холсте</h2>

  <p>Контекст всегда имеет <dfn id="current-default-path">текущий путь по умолчанию</dfn>. Есть только один текущий путь, это не часть
  <a href="#drawing-state">состояния рисования</a>. Текущий путь является <a href="#concept-path" title="concept-path">path</a>, как описано выше.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-beginPath"><a href="#dom-context-2d-beginpath">beginPath</a></code>()</dt>

   <dd>

    <p>Сбрасывает текущий путь.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-fill"><a href="#dom-context-2d-fill">fill</a></code>()</dt>

   <dd>

    <p>Заполняет подпути текущего пути или заданного пути текущим стилем заполнения.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-stroke"><a href="#dom-context-2d-stroke">stroke</a></code>()</dt>

   <dd>

    <p>Сглаживает подпути текущего или заданного пути текущим стилем сглаживания.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded</a></code>(<var>element</var>)</dt>

   <dd>

    <p>Информирует пользователя холста о месте запасного элемента, на основе текущего пути. Если заданный элемент имеет фокус, рисует обводку фокуса вокруг текущего пути, следуя правилам платформы или пользовательского агента.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-clip"><a href="#dom-context-2d-clip">clip</a></code>()</dt>

   <dd>

    <p>В дальнейшем ограничивает clipping region текущему пути.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-isPointInPath"><a href="#dom-context-2d-ispointinpath">isPointInPath</a></code>(<var>x</var>, <var>y</var>)</dt>

   <dd>

    <p>Возвращает true если заданная точка имеется в текущем пути.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>Метод <dfn id="dom-context-2d-beginpath" title="dom-context-2d-beginPath"><code>beginPath()</code></dfn>
  должен очистить список подпутей в текущем пути контекста, поэтому здесь в очередной раз ноль подпутей.</p>

   <p>Метод <dfn id="dom-context-2d-fill" title="dom-context-2d-fill"><code>fill()</code></dfn>
  должен заполнить все подпути текущего пути, используя <code title="dom-context-2d-fillStyle"><a href="#dom-context-2d-fillstyle">fillStyle</a></code>. Открытые подпути должны быть неявно
  закрыты при заполнении (без влияния на фактические
  подпути).</p>

  <p class="note">Таким образом, если пересекаются два подпути, имеющие разные витки, они компенсируются и не приводят к
  заполнению. Если они имеют одинаковый виток, эта область просто рисуется
  один раз.</p>

  <p>Метод <dfn id="dom-context-2d-stroke" title="dom-context-2d-stroke"><code>stroke()</code></dfn>
  должен <a href="#trace-a-path" title="trace a path">чертить</a> путь,
  используя объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> для стилей
  линий, а затем заполнить общую площадь сглаживания с помощью атрибута <code title="dom-context-2d-strokeStyle"><a href="#dom-context-2d-strokestyle">strokeStyle</a></code>.</p>

  <p class="note"><em>Стиль</em> сглаживания зависит от
  преобразования во время рисования, даже если путь это
  <a href="#current-default-path">текущий путь по умолчанию</a>.</p>

  <p>Пути, при заполнении или сглаживании, должны быть нарисованы без влияния
  текущего пути, но должны подвергаться <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global
  alpha</a>, <a href="#clipping-region" title="clipping region">clipping
  region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition
  операторов</a>.</p>

  <p>Сегменты линий нулевой длины убираются перед тем как сглаживать путь.
  Пустые подпути должны быть проигнорированы.</p>

  <hr>

  <p id="dom-context-2d-focusoutline">Метод <dfn id="dom-context-2d-drawfocusifneeded" title="dom-context-2d-drawFocusIfNeeded"><code>drawFocusIfNeeded(<var>element</var>)</code></dfn> при вызове должен выполнить следующие шаги:</p>

  <ol>
   <li>
   <p>
   Если текущий путь имееть ноль подпутей, тогда прервать эти шаги.
   </p>
   </li>
   <li><p>Если <var>element</var> не сфокусирован или не является
   вложенным элемента с которым контекст ассоциирован, прервать эти шаги.</p></li>

   <li>

    <p>Если пользователь запросил использование отдельных контуров фокуса
    (например высококонтрастных контуров) или <var>element</var> будет иметь контур нарисованный вокруг него,
    тогда нарисовать контур фокуса соответствующего стиля вдоль намеченного
    пути, следуя правилам платформы.</p>

    <p class="note">Некоторые платформы рисуют только линии фокуса вокруг
    элементов которые сфокусированы с помощью клавиатуры, а не с помощью
    мышки. Другие платформы вообще не рисуют линии фокуса вокруг некоторых элементов, если только соответствующая
    функция не включена. Этот API предназначен чтобы следовать данным правилам. Пользовательские агенты, которые реализуют это в зависимости от способа которым элемент был сфокусирован, поощраются делать это с помощью метода <code title="dom-focus">focus()</code>
    основанном на способе вызова (если он был).</p>

    <p>Контуры фокуса не должны подвергаться <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, или
    <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global
    composition операторам</a>, но <em>должны</em> подвергаться <a href="#clipping-region" title="clipping region">clipping region</a>.
    Когда зона фокуса обрезана с помощью элемента canvas, только визуальное представление контура фокуса вырезается в clipping region.

	</p>

	<p>
    Если зона фокуса не в пределах экрана, нужно прокрутить в видимую зону, тогда она получит фокус.
	</p>

   </li>

   <li>

    <p><a href="#inform">Проинформировать пользователя</a> о заданном расположении. Полное расположение
	соответствующего запасного элемента передается к
	доступному API, если оно поддерживается. Пользовательские агенты могут ждать до следующего
	раза, когда <span>цикл обработки</span> достигает своего шага "обновить рендеринг".
   </li>

  </ol>

  <p class="note" id="inform">"Проинформировать пользователя", используемое в этом разделе, может означать вызов доступного API системы, которое будет уведомлять вспомогательные технологии, такие как инструменты увеличения.</p>

  <hr>

  <p>Метод <dfn id="dom-context-2d-clip" title="dom-context-2d-clip"><code>clip()</code></dfn>
  должен создать новый <dfn id="clipping-region">clipping region</dfn> путем вычисления
  пересечения текущей вырезанной области и зоной
  описаной с помощью пути, используя правило ненулевого индекса. Открытые подпути должны быть неявно закрыты при вычислении (без влияния на фактические подпути). Новая вырезанная область
  (clipping region) заменяет текущую вырезанную область.</p>

  <p>При инициализации контекста, вырезанная область (clipping region) должна быть установлена
  прямоугольником с верхним левым углом на (0,0), с шириной и высотой координатного пространства.</p>

  <!-- v6
   Jordan OSETE suggests:
    * support ways of extending the clipping region (union instead of intersection)
       - also "add", "subtract", "replace", "intersect" and "xor"
       - maybe just support creating unions, intersections, and other -ions of paths
  -->
  <!-- v5
   Jordan OSETE suggests:
    * support ways of resetting the clipping region without save/restore
  -->

  <hr>

  <p>Метод <dfn id="dom-context-2d-ispointinpath" title="dom-context-2d-isPointInPath"><code>isPointInPath()</code></dfn>
  должен возвращать true если точка заданная с помощью координат <var>x</var> и <var>y</var> при обработке как координат в координатном пространстве холста,
  не зависимо от текущего преобразования, внутри предполагаемого
  пути как определено правилом ненулевого индекса; и должен возвратить false в другом случае. Точки на самом пути должны рассматриваться как внутри пути. Если какой-то из аргументов равен бесконечности или
  NaN, тогда метод должен возвратить false.</p>

  <hr>

  </div>

  <h2 id="drawing-images-to-the-canvas"><span class="secno">12 </span>Рисование изображений на холсте</h2>

  <p>Для того чтобы нарисовать изображение на холсте, используется метод <dfn id="dom-context-2d-drawimage" title="dom-context-2d-drawImage"><code>drawImage</code></dfn>.</p>

  <p>Этот метод может быть вызван с тремя различными наборами аргументов:</p>

  <ul class="brief">
   <li><code>drawImage(<var>image</var>, <var>dx</var>, <var>dy</var>)</code>
   </li><li><code>drawImage(<var>image</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</code>
   </li><li><code>drawImage(<var>image</var>, <var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</code>
  </li></ul>

  <!-- v3: drawImage() of an ImageData object might make sense (when resizing as well as filtering) - ack Charles Pritchard -->

  <p>Каждый из них может принять
  <code>HTMLImageElement</code>, <code>HTMLCanvasElement</code> или <code>HTMLVideoElement</code> для аргумента изображения <var>image</var>.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>dx</var>, <var>dy</var>)</dt>
   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</dt>
   <dt><var>context</var> . <code title="dom-context-2d-drawImage"><a href="#dom-context-2d-drawimage">drawImage</a></code>(<var>image</var>, <var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>, <var>dx</var>, <var>dy</var>, <var>dw</var>, <var>dh</var>)</dt>

   <dd>

    <p>Рисует заданное изображение на холст. Аргументы интерпретируются следующим образом:</p>

    <p><img alt="The sx and sy parameters give the x and y coordinates of the source rectangle; the sw and sh arguments give the width and height of the source rectangle; the dx and dy give the x and y coordinates of the destination rectangle; and the dw and dh arguments give the width and height of the destination rectangle." height="356" src="./drawImage.png" width="356"></p>

    <p>Если первый аргумент не является элементом <code>img</code>,
    <code>canvas</code> или <code>video</code>, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>TypeMismatchError</code>. Если изображение не содержит данных, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение <code>InvalidStateError</code>. Если
    один из размеров исходного прямоугольника равен нулю, <a href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдается</a> исключение
    <code>IndexSizeError</code>. Если изображение (еще) не полностью декодировано, ничего не рисуется.</p>

   </dd>

  </dl>

  <div class="impl">

<p>Когда метод <code id="drawing-images:dom-context-2d-drawimage-4"><a href="#dom-context-2d-drawimage">drawImage()</a></code> вызван, пользовательский агент должен выполнить шаги:</p>

  <ol><li><p><a href="#check-the-usability-of-the-image-argument" id="drawing-images:check-the-usability-of-the-image-argument">Проверить пригодность аргумента<var>image</var></a>. Если возвращается
   <i>aborted</i>, то исключение было выдано и метод не выдает ничего;
   прервать эти шаги. Если возвращается <i>bad</i>, то прервать эти шаги ничего не рисуя.
   В другом случае возвращается <i>good</i>; продолжить.</p></li><li>

    <p>Установить источник и назначение прямоугольников как:</p>

    <p>Если не задано, аргументы <var>dw</var> и <var>dh</var> должны по умолчанию быть
    <var>sw</var> и <var>sh</var>, интерпретируемые таким образом, что один CSS пиксель в изображении рассматривается как единица в координатном пространстве единиц битмапа. Если аргументы <var>sx</var>,
    <var>sy</var>, <var>sw</var> и <var>sh</var> не заданы, по умолчанию они равняются 0,
    0, внутренней ширине изображения в пикселях и внутренней высоте изображения в пикселях, соответственно. Если изображение не имеет внутренних размеров, должен быть использован <i>конкретный размер объекта</i>, как определено CSS алгоритмом "<a href="http://www.w3.org/TR/css3-images/#default-sizing">Concrete Object Size Resolution</a>". Если же <i>заданный размер</i> не имеет указанных ширины/высоты и прочих параметров, внутренние данные объекта будут взяты из аргумента <var>image</var>, и <a id="drawing-images:default-object-size" href="http://www.w3.org/TR/css3-images/#default-object-size">размером объекта по умолчанию</a> будет размер битмапа. <a href="#refsCSSIMAGES">[CSSIMAGES]</a></p>

    <p>Исходный прямоугольник — прямоугольник с углами в точках (<var>sx</var>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <span><var>sy</var>+<var>sh</var></span>),
    (<var>sx</var>, <span><var>sy</var>+<var>sh</var></span>).</p>

    <p>Конечный прямоугольник — с углами в точках (<var>dx</var>, <var>dy</var>), (<span><var>dx</var>+<var>dw</var></span>, <var>dy</var>), (<span><var>dx</var>+<var>dw</var></span>, <span><var>dy</var>+<var>dh</var></span>),
    (<var>dx</var>, <span><var>dy</var>+<var>dh</var></span>).</p>

    <p>Когда исходный прямоугольник за пределами исходного изображения, исходный прямоугольник должен быть обрезан под исходное изображение
    и конечный прямоугольник обрезан в той же пропорции.</p>

    <p class="note">Когда конечный прямоугольник за пределами конечного изображения (битмапа), пиксели которые за пределами отбрасываются.</p>

   </li><li><p>Если один из аргументов <var>sw</var> или <var>sh</var> равен нулю, прервать эти шаги. Ничего не рисуется.</p></li><li>

    <p>Нарисовать зону аргумента <var>image</var> заданную исходным прямоугольником
    на зоне растрового изображения (битмапа) контекста заданной конечным прямоугольником, после применения <a href="#transformations" id="drawing-images:transformations">текущей матрицы преобразования</a> на конечном прямоугольнике.</p>

    <p>Данные изображения должны быть обработаны в изначальном направлении, даже если указаны отрицательные размеры. </p>

  <p class="note">Данная спецификация не определяет алгоритм, используемый при масштабировании изображения.</p>

  <p class="note">Когда холст рисуется, <a href="#drawing-model">модель рисования</a> требует источник для копирования перед тем как изображение нарисуется на холсте, так что можно скопировать части холста на перекрывающие его части.</p>

    <p>Если исходное изображение является растровым изображением, значение нарисованное на месте конечного прямоугольника
    вычисляется с помощью фильтрации данных исходного изображения. Пользовательский агент может использовать любой алгоритм
    фильтрации (например, билинейной интерполяции или схожий). Когда алгоритм фильтрации
    требует значение пикселя за пределами оригинального изображения, он должен вместо этого использовать значение ближайшего пикселя с краю. Когда алгоритм фильтрации запрашивает значение пикселя извне исходного прямоугольника, но внутри оригинального изображения, следует использовать значение из оригинального изображения.</p>



    <p class="note">Таким образом, масштабирование изображения по частям или в целом будет иметь тот же эффект.</p>

    <p>Изображения рисуются без влияния текущего пути (current path), но подлежат <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

   </li><li><p>Если <a href="#the-image-argument-is-not-origin-clean" id="drawing-images:the-image-argument-is-not-origin-clean"><var>image argument</var> не origin-clean</a>, установить флаг <var>origin-clean</var> битмапа ложным.</p></li></ol>

  <p>Изображения рисуются без влияния текущего пути (current path), но подлежат <a href="#shadows" title="shadows">эффектам теней</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, <a href="#clipping-region" title="clipping region">clipping region</a> и <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition операторам</a>.</p>

  </div>

  <h2 id="hit-regions"><span class="secno">13 </span>Hit области</h2>

  <p>Каждый элемент <code>canvas</code> чей <span>основной контекст</span> это объект <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>,
  должен иметь <dfn id="hit-region-list">список hit областей</dfn> связанный с его битмапом.</p>

  <p><a href="#hit-region-list">Список hit областей</a> это список из <a href="#hit-region" title="hit
  region">hit областей</a>.</p>

  <p>Каждая <dfn id="hit-region">hit область</dfn> содержит следующую информацию:</p>

  <ul>

  <li><p><dfn id="hit-region's-path" title="hit region's path">Путь</dfn> на битмапе элемента <code>canvas</code> для которого он предназначен.</p></li>

  <li><p><dfn id="hit-region's-bounding-circumference" title="hit region's bounding circumference">Ограничивающую окружность</dfn> на битмапе элемента <code>canvas</code>, которая окружает <a href="#hit-region's-path">путь hit области</a> в том виде котором он создан.</p></li>

  <li><p>Опционально, непустая строка, представляющая <dfn id="hit-region's-id" title="hit region's ID">ID</dfn> для отличия этой области от других.</p></li>

   <li>
   <p>Опционально, элемент управления <a href="#hit-region's-control" title="hit region's control">control</a>.</p>

   <p><dfn id="hit-region's-control" title="hit region's control">Control</dfn> это ссылка на узел <code>Element</code>, к которому, в определенных условиях, пользовательский агент будет отправлять события, и из которого агент пользователя будет определять состояние hit области для целей доступных инструментов. (Control игнорируется когда он
   не является потомком элемента canvas.)</p>

   </li>
  </ul>

  <dl class="domintro">

  <dt><var>context</var> . <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion</a></code>(<var>options</var>)</dt>

  <dd>

   <p>Добавляет hit область на холст, на основе текущего пути по умолчанию. Аргумент это объект со следующими членами:</p>

   <dl>

    <dt><code title="dom-HitRegionOptions-id">id</code> (по умолчанию пустая строка)

	</dt><dd>ID используемый для этой области. Он используется в событиях
     <code>MouseEvent</code> на <code>canvas</code> (<code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">event.region</a></code>) и как путь
    к вызову этой области в последующих вызовах к <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</dd>
     <dt><code title="dom-HitRegionOptions-control">control</code> (по умолчанию null)

     </dt><dd>Элемент (потомок <code>canvas</code>)
     к которому события должны быть направлены, и который доступные инструменты
     используют как суррогат для описания и взаимодействия с этой областью.</dd>

    </dl>

   <p>Hit области могут быть использованы для различных целей:</p>

   <ul>
    <li>С ID, они могут сделать обнаружение hit проще с помощью
    проверки агентом пользователя на какую область наведена мышь и включить
    ID в события мыши.</li>

    <li>С control, они могут сделать передачу событий к DOM элементам
    автоматической, что позволяет, например, кликнуть на холст чтобы автоматически
    отправить форму с помощью <code>button</code> элемента.</li>

    </ul>

    <p class="note">В то время как ID и control не являются обязательными, при вызове
	addHitRegion, как минимум один из двух должен быть предоставлен
   чтобы создать hit область. </p>


	</dd>

	<dt><var>context</var> . <code title="dom-context-2d-removeHitRegion"><a href="#dom-context-2d-removehitregion">
	removeHitRegion</a></code>(<var>id</var>)</dt>

  <dd>

   <p>Удаляет hit область с битмапа холста. Аргумент это ID области заданный с помощью <code title="dom-context-2d-addHitRegion"><a href="#dom-context-2d-addhitregion">addHitRegion()</a></code>.</p>

  <p>Путь который был покрыт этой областью в результате этой операции очищается, оставляя область не-интерактивной. В частности, области которые занимали тот же путь
   перед тем как удаленные области были добавлены, не возобновляют свои прежние роли.</p>

   </dd>

   	<dt><var>context</var> . <code title="dom-context-2d-clearHitRegions"><a href="#dom-context-2d-clearhitregions">
	clearHitRegions</a></code>()</dt>

  <dd>

   <p>Удаляет все hit области с битмапа холста. </p>

  <p>Пути которые были покрыты этими областями в результате
   очищаются, оставляя все области не-интерактивными. </p>

   </dd>

   </dl>

   <div class="impl">

   <p><dfn id="the-region-identified-by-the-id">The region identified by the ID</dfn> <var>ID</var> in a bitmap <var>bitmap</var> is the value returned by the following
   algorithm (which can return a <a href="#hit-region">hit region</a> or
   nothing):</p>

   <ol>

   <li><p>If <var>ID</var> is null, return nothing and abort
   these steps.</p></li>

   <li><p>Let <var>list</var> be the <a href="#hit-region-list">hit region
   list</a> associated with <var>bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var>list</var> whose <a href="#hit-region's-id" title="hit region's ID">ID</a>
   is a <span>case-sensitive</span> match for <var>ID</var>,
   then return that <a href="#hit-region">hit region</a> and abort these
   steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>

  <p><dfn id="the-region-representing-the-control">The region representing the control</dfn> <var>control</var> for a bitmap <var>bitmap</var> is the value returned by the following
  algorithm (which can return a <a href="#hit-region">hit region</a> or
  nothing):</p>

  <ol>

   <li><p>If <var>control</var> is null, return
   nothing and abort these steps.</p></li>

   <li><p>Let <var>list</var> be the <a href="#hit-region-list">hit region
   list</a> associated with <var>bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var>list</var> whose <a href="#hit-region's-control" title="hit region's
   control">control</a> is <var>control</var>, then
   return that <a href="#hit-region">hit region</a> and abort these
   steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>

  <p><dfn id="the-control-represented-by-a-region">The control represented by a region</dfn> <var>region</var> for a <code>canvas</code> element <var>ancestor</var> is the value returned by the following
  algorithm (which can return an element or nothing):</p>

  <ol>

   <li><p>If <var>region</var> has no <a href="#hit-region's-control" title="hit
   region's control">control</a>, return nothing and abort these
   steps.</p></li>

   <li><p>Let <var>control</var> be <var>region</var>'s <a href="#hit-region's-control" title="hit region's
   control">control</a>.</p></li>

   <li><p>If <var>control</var> is not a descendant of <var>ancestor</var>, then return nothing and abort these
   steps.</p></li>

   <li><p>Otherwise, return <var>control</var>.</p></li>

  </ol>

  <p><dfn id="the-region-for-a-pixel">The region for a pixel</dfn> <var>pixel</var> on a bitmap
  <var>bitmap</var> is the value returned by the following
  algorithm (which can return a
  <a href="#hit-region">hit region</a> or nothing):</p>

  <ol>

   <li><p>Let <var>list</var> be the <a href="#hit-region-list">hit region
   list</a> associated with <var>bitmap</var>.</p></li>

   <li><p>If there is a <a href="#hit-region">hit region</a> in <var>list</var> whose <a href="#hit-region's-path">path</a> contains <var>pixel</var>,
   then return that <a href="#hit-region">hit region</a> and abort these
   steps.</p></li>

   <li><p>Otherwise, return nothing.</p></li>

  </ol>
<!--
  <p>To <dfn>clear regions that cover the pixels</dfn> <var
  title="">pixels</var> on a bitmap <var>bitmap</var>, the user agent must run the following
  steps:</p>

  <ol>

   <li><p>Let <var>list</var> be the <span>hit region
   list</span> associated with <var>bitmap</var>.</p></li>

   <li><p>Remove all pixels in <var>pixels</var> from the
   <span title="hit region's set of pixels">set of pixels</span> of
   each <span>hit region</span> in <var>list</var>.</p></li>



  </ol>
  -->



  <hr>

  <p>When the <dfn id="dom-context-2d-addhitregion" title="dom-context-2d-addHitRegion"><code>addHitRegion()</code></dfn>
  method is invoked, the user agent must run the following steps:</p>

  <ol>

   <li><p>Let <var>arguments</var> be the dictionary object
   provided as the method's argument.</p></li>

   <li><p>Let <var title="dom-HitRegionOptions-path">source path</var> be the <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code>
   object's <a href="#current-default-path">current default path</a>.</p></li>

   <li><p>Let <var>specified pixels</var> be the pixels
   contained in <var>source path</var>.

   </p></li><li><p>Remove from <var>specified pixels</var> any pixels not contained within the <a href='#clipping-region'>clipping
   region</a>.</p></li>

   <li><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-id">id</code> member is an
   empty string, let it be null instead.</p></li>

   <li><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-id">id</code> member is null and the <var>arguments</var>
   object's <code title="dom-HitRegionOptions-control">control</code> member is null,
   throw a <code>NotSupportedError</code> exception and abort these steps.</p></li>

   <li><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-id">id</code> member is not null, then
   let <var>previous region for this ID</var> be <a href="#the-region-identified-by-the-id">the
   region identified by the ID</a> given by the <code title="dom-HitRegionOptions-id">id</code> member's value in this
   <code>canvas</code> element. If the <code title="dom-HitRegionOptions-id">id</code> member is null or no such
   region currently exists, let <var>previous region for this
   ID</var> be null.</p></li>

   <li>
    <p>If the <var>specified pixels</var> has no pixels, throw a
    <code>NotSupportedError</code> exception and abort these
    steps.</p>

   </li>


   <li>

    <p>Let <var>region</var> be a newly created <a href="#hit-region">hit
    region</a>, with its information configured as follows:</p>

    <dl>

     <dt><a href="#hit-region's-path">Hit region's path</a>

     </dt><dd><p>The <var>specified pixels</var>.


     </p></dd><dt><a href="#hit-region's-bounding-circumference">Hit region's bounding circumference</a>

     </dt><dd><p>A user-agent-defined shape that wraps the pixels contained
     in <var>source path</var>. (In the simplest case, this
     can just be the bounding rectangle; this specification allows it
     to be any shape in order to allow other interfaces.)

     </p></dd><dt><a href="#hit-region's-id">Hit region's ID</a>

     </dt><dd><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-id">id</code> member is not null: the
     value of the <code title="dom-HitRegionOptions-id">id</code>
     member. Otherwise, <var>region</var> has no <a href="#hit-region's-id" title="hit region's id">id</a>.

     </p></dd><dt><a href="#hit-region's-control">Hit region's control</a>

     </dt><dd><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-control">control</code> member is not
     null: the value of the <code title="dom-HitRegionOptions-control">control</code> member.
     Otherwise, <var>region</var> has no <a href="#hit-region's-control" title="hit
     region's control">control</a>.

    </p></dd></dl>

   </li>

   <li><p>If the <var>arguments</var> object's <code title="dom-HitRegionOptions-control">control</code> member is not
   null, then let <var>previous region for the control</var>
   be <a href="#the-region-representing-the-control">the region representing the control</a> given by the
   <code title="dom-HitRegionOptions-control">control</code> member's
   value for this <code>canvas</code> element, if any. If the <code title="dom-HitRegionOptions-control">control</code> member is null
   or no such region currently exists, let <var>previous
   region for the control</var> be null.</p></li>


   <li><p>If there is a <var>previous region with this
   control</var>, remove it from the <code>canvas</code> element's
   <a href="#hit-region-list">hit region list</a>.</p></li>

   <li><p>If the arguments object's <code title="dom-HitRegionOptions-control">
   control</code> member is not null, <a href='#inform'>inform the user</a> of the location of the region
   representing the <code title="dom-HitRegionOptions-control">control</code>
   given by the control member's value for this <code>canvas</code> element, if any.
   The full location of the corresponding fallback element, pertaining
   to the <code title="dom-HitRegionOptions-control">control</code>,
   as represented by the region is passed to the  accessibility API, if supported.</p></li>

   <li><p>If there is a <var>previous region with this
   ID</var>, remove it from the <code>canvas</code> element's <a href="#hit-region-list">hit region
   list</a>.</p></li>

   <li><p>Add <var>region</var> to the <code>canvas</code>
   element's <a href="#hit-region-list">hit region list</a>.</p></li>

  </ol>

  <p>When the <dfn id="dom-context-2d-removehitregion" title="dom-context-2d-removeHitRegion"><code>removeHitRegion()</code></dfn>
  method is invoked, the user agent must run the following steps:</p>

  <ol>

   <li><p>Let <var>region</var> be <a href="#the-region-identified-by-the-id">the region
   identified by the ID</a> given by the method's argument in this
   <code>canvas</code> element, if any. If no such region currently
   exists, abort these steps.</p>

   <p class="note"> If the method's argument is an empty string, then no region will match.</p>

   </li><li><p>Remove <var>region</var> from the <code>canvas</code> element's
   <a href="#hit-region-list">hit region list</a>.</p></li>



  </ol>

    <p>When the <dfn id="dom-context-2d-clearhitregions" title="dom-context-2d-clearHitRegions"><code>clearHitRegions()</code></dfn>
  method is invoked, the user agent must run the following steps:</p>

  <ol>

   <li><p>Remove all <var>hit regions</var>
   from the <code>canvas</code> element and clear the element's <a href="#hit-region-list">hit region list</a>. If no regions currently
   exist, abort these steps.</p></li>

  </ol>

  <p class="note">Calling <code title="dom-context-2d-clearRect"><a href="#dom-context-2d-clearrect">clearRect()</a></code> is a way
  to clear all or some hit regions. Calling clearHitRegions()
  removes all hit regions and clears the hit region list. The <a href="#hit-region-list">hit region
  list</a> itself is also reset when the rendering context is reset.
  For example, when a <code><a href="#canvasrenderingcontext2d">CanvasRenderingContext2D</a></code> object is
  bound to or unbound from a <code>canvas</code>, or the dimensions of the bitmap are changed.</p>


  </div>

  <hr>

  <p>The <code>MouseEvent</code> interface is extended to support hit
  regions:</p>

  <pre class="idl">partial interface <span>MouseEvent</span> {
  readonly attribute DOMString? <a href="#dom-mouseevent-region" title="dom-MouseEvent-region">region</a>;
};

partial dictionary <span>MouseEventInit</span> {
  DOMString? region;
};</pre>

  <dl class="domintro">

   <dt><var>event</var> . <code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code></dt>

   <dd>

    <p>If the mouse was over a <a href="#hit-region">hit region</a>, then this returns the <a href="#hit-region's-id">hit region's ID</a> if it has one.</p>

    <p>Otherwise, returns null.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn id="dom-mouseevent-region" title="dom-MouseEvent-region"><code>region</code></dfn>
  attribute on <code>MouseEvent</code> objects must return the value
  it was initialized to. When the object is created, this attribute
  must be initialized to null. It represents the <a href="#hit-region's-id">hit region's
  ID</a> if the mouse was over a hit region when the event was
  fired.</p>

  <p>When a <code>MouseEvent</code> is to be fired at a
  <code>canvas</code> element by the user agent in response to a
  pointing device action, if the <code>canvas</code> element has a hit region list,
  the user agent must instead follow these
  steps. If these steps say to <i>act as normal</i>, that means that
  the event must be fired as it would have had these requirements not
  been applied.</p>

  <ol>

   <li><p>If the pointing device is not indicating a pixel on the
   canvas, <i>act as normal</i> and abort these steps.</p></li>

   <li><p>If the canvas element has no hit region list, act as
   normal and abort these steps.</p></li>

   <li><p>Let pixel be the pixel indicated by the pointing device.</p></li>

   <li><p>Let region be the hit region that is the region for the pixel <var>pixel</var> on this canvas element's bitmap, if any.</p></li>

   <li><p>Let <var>id</var> be the <var>region</var>'s <a href="#hit-region's-id" title="hit region's ID">ID</a>, if
   any.</p></li>

   <li><p>If there is an <var>id</var>, then initialize the
   event object's <code title="dom-MouseEvent-region"><a href="#dom-mouseevent-region">region</a></code>
   attribute to <var>id</var>.</p></li>

   <li><p>Dispatch the event, but with the updated event object as
   given in the above steps.</p></li>

  </ol>

  <p class="note">This approach simplifies event handling by not
  <a href="#dom-mouseevent-region">re-targeting
  the event</a>.  The event is dispatched as normal once the event.region
  attribute is initialized to the active hit region's ID.  The event is
  received by the canvas element allowing the author to define the
  behavior of the event.</p>
  <hr>

  <p>User agents are encouraged to make use of the information present
  in a <code>canvas</code> element's <a href="#hit-region-list">hit region list</a> to
  improve the accessibility of <code>canvas</code> elements.</p>

  <p>Each <a href="#hit-region">hit region</a> should be handled in a fashion
  equivalent to a node in a virtual DOM tree rooted at the
  <code>canvas</code> element. The hierarchy of this virtual DOM tree
  must match the hierarchy of the <a href="#hit-region" title="hit region">hit
  regions</a>. <!--, as described by the <span title="hit region's
  parent">parent</span> of each region. Regions without a <span
  title="hit region's parent">parent</span> must be treated as
  children of the <code>canvas</code> element for the purpose of this
  virtual DOM tree.--> For each node in such a DOM tree, the <a href="#hit-region's-bounding-circumference">hit
  region's bounding circumference</a> gives the region of the
  screen to use when representing the node (if appropriate).</p>

  <p>The semantics of a <a href="#hit-region">hit region</a> for the purposes of
  this virtual DOM tree are those of the <a href="#hit-region's-control">hit region's
  control</a>, if it has one.<!--, or else of a non-interactive element
  whose ARIA role, if any, is that given by the <span>hit region's
  ARIA role</span>, and whose textual representation, if any, is given
  by the <span>hit region's label</span>.--></p>

  <p>For the purposes of accessibility tools, when an element <var>C</var> is a descendant of a <code>canvas</code> element
  and there is <a href="#the-region-representing-the-control" title="the region representing the control">a
  region representing the control</a> <var>C</var> for that
  <code>canvas</code> element, then the element's position relative to
  the document should be presented as if it was that region in the
  <code>canvas</code> element's virtual DOM tree.</p>

  <hr>



  </div>


  <h2 id="pixel-manipulation"><span class="secno">14 </span><dfn>Пиксельная манипуляция</dfn></h2>

  <dl class="domintro">

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var>sw</var>, <var>sh</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object with the given
    dimensions in CSS pixels (which might map to a different number of
    actual device pixels exposed by the object itself). All the pixels
    in the returned object are transparent black.</p>

   </dd>

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData</a></code>(<var>imagedata</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object with the same
    dimensions as the argument. All the pixels in the returned object
    are transparent black.</p>

   </dd>

   <dt><var>imagedata</var> = <var>context</var> . <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData</a></code>(<var>sx</var>, <var>sy</var>, <var>sw</var>, <var>sh</var>)</dt>

   <dd>

    <p>Returns an <code><a href="#imagedata">ImageData</a></code> object containing the image
    data for the given rectangle of the canvas.</p>

    <p>Throws an <code>IndexSizeError</code> exception if the either
    of the width or height arguments are zero.</p>

    <p>The data will be returned with one pixel of image data for each
    coordinate space unit on the canvas (ignoring transforms).</p>

   </dd>

   <dt><var>imagedata</var> . <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code></dt>
   <dt><var>imagedata</var> . <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code></dt>

   <dd>

    <p>Returns the actual dimensions of the data in the <code><a href="#imagedata">ImageData</a></code> object, in device pixels.</p>

   </dd>

   <dt><var>imagedata</var> . <code title="dom-imagedata-data"><a href="#dom-imagedata-data">data</a></code></dt>

   <dd>

    <p>Returns the one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData</a></code>(<var>imagedata</var>, <var>dx</var>, <var>dy</var> [, <var>dirtyX</var>, <var>dirtyY</var>, <var>dirtyWidth</var>, <var>dirtyHeight</var> ])</dt>

   <dd>

    <p>Paints the data from the given <code><a href="#imagedata">ImageData</a></code> object
    onto the canvas. If a dirty rectangle is provided, only the pixels
    from that rectangle are painted.</p>

    <p>The <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>
    and <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>
    attributes, as well as the shadow attributes, are ignored for the
    purposes of this method call; pixels in the canvas are replaced
    wholesale, with no composition, alpha blending, no shadows,
    etc.</p>

    <p>Throws a <code>NotSupportedError</code> exception if any of the
    arguments are not finite.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn id="dom-context-2d-createimagedata" title="dom-context-2d-createImageData"><code>createImageData()</code></dfn>
  method is used to instantiate new blank <code><a href="#imagedata">ImageData</a></code>
  objects. When the method is invoked with two arguments <var>sw</var> and <var>sh</var>, it must return an
  <code><a href="#imagedata">ImageData</a></code> object representing a rectangle with a width
  in CSS pixels equal to the absolute magnitude of <var>sw</var> and a height in CSS pixels equal to the absolute
  magnitude of <var>sh</var>. When invoked with a single <var>imagedata</var> argument, it must return an
  <code><a href="#imagedata">ImageData</a></code> object representing a rectangle with the same
  dimensions as the <code><a href="#imagedata">ImageData</a></code> object passed as the
  argument. The <code><a href="#imagedata">ImageData</a></code> object returned must be filled
  with transparent black.</p>

  <p>The <dfn id="dom-context-2d-getimagedata" title="dom-context-2d-getImageData"><code>getImageData(<var>sx</var>, <var>sy</var>, <var>sw</var>,
  <var>sh</var>)</code></dfn> method must,
<!--ADD-TOPIC:Security-->
  if the bitmap of the <code>canvas</code> element's <i>origin-clean</i> flag is set
  to false, throw a <code>SecurityError</code> exception; otherwise, it
<!--REMOVE-TOPIC:Security-->
  must return an <code><a href="#imagedata">ImageData</a></code> object representing the
  underlying pixel data for the area of the canvas denoted by the
  rectangle whose corners are the four points (<var>sx</var>,
  <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <var>sy</var>), (<span><var>sx</var>+<var>sw</var></span>, <span><var>sy</var>+<var>sh</var></span>),
  (<var>sx</var>, <span><var>sy</var>+<var>sh</var></span>), in canvas coordinate space units. Pixels
  outside the canvas must be returned as transparent black. Pixels
  must be returned as non-premultiplied alpha values.</p>

  <p>If any of the arguments to <code title="dom-context-2d-createImageData"><a href="#dom-context-2d-createimagedata">createImageData()</a></code> or
  <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code>
  are infinite or NaN, the method must instead throw a
  <code>NotSupportedError</code> exception. If either the <var>sw</var> or <var>sh</var> arguments are zero,
  the method must instead throw an <code>IndexSizeError</code>
  exception.</p>

  <p><code><a href="#imagedata">ImageData</a></code> objects must be initialized so that their
  <dfn id="dom-imagedata-width" title="dom-imagedata-width"><code>width</code></dfn> attribute
  is set to <var>w</var>, the number of physical device
  pixels per row in the image data, their <dfn id="dom-imagedata-height" title="dom-imagedata-height"><code>height</code></dfn> attribute is
  set to <var>h</var>, the number of rows in the image data,
  and their <dfn id="dom-imagedata-data" title="dom-imagedata-data"><code>data</code></dfn>
  attribute is initialized to a <code>Uint8ClampedArray</code> object.
  The <code>Uint8ClampedArray</code> object must use a <a href="#canvas-pixel-arraybuffer">Canvas
  Pixel <code>ArrayBuffer</code></a> for its storage, and must have
  a zero start offset and a length equal to the length of its storage,
  in bytes. The <a href="#canvas-pixel-arraybuffer">Canvas Pixel <code>ArrayBuffer</code></a>
  must contain the image data. At least one pixel's worth of image
  data must be returned. <a href="#refsTYPEDARRAY">[TYPEDARRAY]</a></p>

  <p>A <dfn id="canvas-pixel-arraybuffer">Canvas Pixel <code>ArrayBuffer</code></dfn> is an
  <code>ArrayBuffer</code> that whose data is represented in
  left-to-right order, row by row top to bottom, starting with the top
  left, with each pixel's red, green, blue, and alpha components being
  given in that order for each pixel. Each component of each device
  pixel represented in this array must be in the range 0..255,
  representing the 8 bit value for that component. The components must
  be assigned consecutive indices starting with 0 for the top left
  pixel's red component. <a href="#refsTYPEDARRAY">[TYPEDARRAY]</a></p>

  <p>The <dfn id="dom-context-2d-putimagedata" title="dom-context-2d-putImageData"><code>putImageData(<var>imagedata</var>, <var>dx</var>, <var>dy</var>, <var>dirtyX</var>, <var>dirtyY</var>, <var>dirtyWidth</var>, <var>dirtyHeight</var>)</code></dfn> method writes data from
  <code><a href="#imagedata">ImageData</a></code> structures back to the canvas.</p>

  <p>If any of the arguments to the method are infinite or NaN, the
  method must throw a <code>NotSupportedError</code> exception.</p>

  <p>When the last four arguments are omitted, they must be assumed to
  have the values 0, 0, the <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> member of the <var>imagedata</var> structure, and the <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> member of the <var>imagedata</var> structure, respectively.</p>

  <p>When invoked with arguments that do not, per the last few
  paragraphs, cause an exception to be thrown, the <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> method
  must act as follows:</p>

  <ol>

   <li>

    <p>Let <var>dx<sub>device</sub></var> be the x-coordinate
    of the device pixel in the underlying pixel data of the canvas
    corresponding to the <var>dx</var> coordinate in the
    canvas coordinate space.</p>

    <p>Let <var>dy<sub>device</sub></var> be the y-coordinate
    of the device pixel in the underlying pixel data of the canvas
    corresponding to the <var>dy</var> coordinate in the
    canvas coordinate space.</p>

   </li>

   <li>

    <p>If <var>dirtyWidth</var> is negative, let <var>dirtyX</var> be <span><var>dirtyX</var>+<var>dirtyWidth</var></span>, and let <var>dirtyWidth</var> be equal to the absolute magnitude of
    <var>dirtyWidth</var>.</p>

    <p>If <var>dirtyHeight</var> is negative, let <var>dirtyY</var> be <span><var>dirtyY</var>+<var>dirtyHeight</var></span>, and let <var>dirtyHeight</var> be equal to the absolute magnitude of
    <var>dirtyHeight</var>.</p>

   </li>

   <li>

    <p>If <var>dirtyX</var> is negative, let <var>dirtyWidth</var> be <span><var>dirtyWidth</var>+<var>dirtyX</var></span>, and
    let <var>dirtyX</var> be zero.</p>

    <p>If <var>dirtyY</var> is negative, let <var>dirtyHeight</var> be <span><var>dirtyHeight</var>+<var>dirtyY</var></span>, and
    let <var>dirtyY</var> be zero.</p>

   </li>

   <li>

    <p>If <span><var>dirtyX</var>+<var>dirtyWidth</var></span> is greater than the <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> attribute of the <var>imagedata</var> argument, let <var>dirtyWidth</var> be the value of that <code title="dom-imagedata-width"><a href="#dom-imagedata-width">width</a></code> attribute, minus the
    value of <var>dirtyX</var>.</p>

    <p>If <span><var>dirtyY</var>+<var>dirtyHeight</var></span> is greater than the <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> attribute of the <var>imagedata</var> argument, let <var>dirtyHeight</var> be the value of that <code title="dom-imagedata-height"><a href="#dom-imagedata-height">height</a></code> attribute, minus the
    value of <var>dirtyY</var>.</p>

   </li>

   <li>

    <p>If, after those changes, either <var>dirtyWidth</var>
    or <var>dirtyHeight</var> is negative or zero, stop these
    steps without affecting the canvas.</p>

   </li>

   <li><p>Otherwise, for all integer values of <var>x</var>
   and <var>y</var> where <span><var>dirtyX</var> ≤ <var>x</var> &lt; <span><var>dirtyX</var>+<var>dirtyWidth</var></span></span>
   and <span><var>dirtyY</var> ≤ <var>y</var> &lt; <span><var>dirtyY</var>+<var>dirtyHeight</var></span></span>, copy the four channels of
   the pixel with coordinate (<var>x</var>, <var>y</var>) in the <var>imagedata</var> data
   structure to the pixel with coordinate (<span><var>dx<sub>device</sub></var>+<var>x</var></span>,
   <span><var>dy<sub>device</sub></var>+<var>y</var></span>) in the underlying pixel data of the
   canvas.</p></li>

  </ol>

  <p>The handling of pixel rounding when the specified coordinates do
  not exactly map to the device coordinate space is not defined by
  this specification, except that the following must result in no
  visible changes to the rendering:</p>

  <pre>context.putImageData(context.getImageData(x, y, w, h), p, q);</pre>

  <p>...for any value of <var>x</var>, <var>y</var>,
  <var>w</var>, and <var>h</var> and where <var>p</var> is the smaller of <var>x</var> and the sum
  of <var>x</var> and <var>w</var>, and <var>q</var> is the smaller of <var>y</var> and the sum
  of <var>y</var> and <var>h</var>; and except that
  the following two calls:</p>

  <pre>context.createImageData(w, h);
context.getImageData(0, 0, w, h);</pre>

  <p>...must return <code><a href="#imagedata">ImageData</a></code> objects with the same
  dimensions, for any value of <var>w</var> and <var>h</var>. In other words, while user agents may round the
  arguments of these methods so that they map to device pixel
  boundaries, any rounding performed must be performed consistently
  for all of the <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">createImageData()</a></code>, <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> and <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code>
  operations.</p>

  <p class="note">This implies that the data returned by <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> is at the
  resolution of the canvas backing store. This is likely to not be one
  device pixel to each CSS pixel if the display used is a high
  resolution display.</p>

  <p class="note">Due to the lossy nature of converting to and from
  premultiplied alpha color values, pixels that have just been set
  using <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> might be
  returned to an equivalent <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> as
  different values.</p>

  <p>The current path, <a href="#transformations" title="dom-context-2d-transformation">transformation matrix</a>,
  <a href="#shadows" title="shadows">shadow attributes</a>, <a href="#dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha">global alpha</a>, the <a href="#clipping-region" title="clipping region">clipping region</a>, and <a href="#dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation">global composition
  operator</a> must not affect the <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> and <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code>
  methods.</p>

  </div>

  <div class="example">

   <p>In the following example, the script generates an
   <code><a href="#imagedata">ImageData</a></code> object so that it can draw onto it.</p>

   <pre>// canvas is a reference to a &lt;canvas&gt; element
var context = canvas.getContext('2d');

// create a blank slate
var data = context.createImageData(canvas.width, canvas.height);

// create some plasma
FillPlasma(data, 'green'); // green plasma

// add a cloud to the plasma
AddCloud(data, data.width/2, data.height/2); // put a cloud in the middle

// paint the plasma+cloud on the canvas
context.putImageData(data, 0, 0);

// support methods
function FillPlasma(data, color) { ... }
function AddCloud(data, x, y) { ... }</pre>

  </div>

  <div class="example">

   <p>Here is an example of using <code title="dom-context-2d-getImageData"><a href="#dom-context-2d-getimagedata">getImageData()</a></code> and <code title="dom-context-2d-putImageData"><a href="#dom-context-2d-putimagedata">putImageData()</a></code> to
   implement an edge detection filter.</p>

   <pre>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Edge detection demo&lt;/title&gt;
  &lt;script&gt;
   var image = new Image();
   function init() {
     image.onload = demo;
     image.src = "image.jpeg";
   }
   function demo() {
     var canvas = document.getElementsByTagName('canvas')[0];
     var context = canvas.getContext('2d');

     // draw the image onto the canvas
     context.drawImage(image, 0, 0);

     // get the image data to manipulate
     var input = context.getImageData(0, 0, canvas.width, canvas.height);

     // get an empty slate to put the data into
     var output = context.createImageData(canvas.width, canvas.height);

     // alias some variables for convenience
     // notice that we are using input.width and input.height here
     // as they might not be the same as canvas.width and canvas.height
     // (in particular, they might be different on high-res displays)
     var w = input.width, h = input.height;
     var inputData = input.data;
     var outputData = output.data;

     // edge detection
     for (var y = 1; y &lt; h - 1; y += 1) {
       for (var x = 1; x &lt; w - 1; x += 1) {
         for (var c = 0; c &lt; 3; c += 1) {
           var i = (y*w + x)*4 + c;
           outputData[i] = 127 + -inputData[i - w*4 - 4] -   inputData[i - w*4] - inputData[i - w*4 + 4] +
                                 -inputData[i - 4]       + 8*inputData[i]       - inputData[i + 4] +
                                 -inputData[i + w*4 - 4] -   inputData[i + w*4] - inputData[i + w*4 + 4];
         }
         outputData[(y*w + x)*4 + 3] = 255; // alpha
       }
     }

     // put the image data back after manipulation
     context.putImageData(output, 0, 0);
   }
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body onload="init()"&gt;
  &lt;canvas&gt;&lt;/canvas&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre>

  </div>




  <h2 id="compositing"><span class="secno">15 </span>Совмещение</h2>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current alpha value applied to rendering operations.</p>

    <p>Can be set, to change the alpha value. Values outside of the
    range 0.0 .. 1.0 are ignored.</p>

   </dd>


   <dt><var>context</var> . <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Returns the current composition operation, from the list below.</p>

    <p>Can be set, to change the composition operation. Unknown values
    are ignored.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>All drawing operations are affected by the global compositing
  attributes, <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> and <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>.</p>

  <!-- conformance criteria for painting are described in the "drawing
  model" section below -->

  <p>The <dfn id="dom-context-2d-globalalpha" title="dom-context-2d-globalAlpha"><code>globalAlpha</code></dfn>
  attribute gives an alpha value that is applied to shapes and images
  before they are composited onto the canvas. The value must be in the
  range from 0.0 (fully transparent) to 1.0 (no additional
  transparency). If an attempt is made to set the attribute to a value
  outside this range, including Infinity and Not-a-Number (NaN)
  values, the attribute must retain its previous value. When the
  context is created, the <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> attribute must
  initially have the value 1.0.</p>

  <p>The <dfn id="dom-context-2d-globalcompositeoperation" title="dom-context-2d-globalCompositeOperation"><code>globalCompositeOperation</code></dfn>
  attribute sets how shapes and images are drawn onto the existing
  bitmap, once they have had <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code> and the
  current transformation matrix applied. It must be set to a value
  from the following list. In the descriptions below, the source
  image, <var>A</var>, is the shape or image being rendered,
  and the destination image, <var>B</var>, is the current
  state of the bitmap.</p>

  </div>

  <dl>

   <dt><dfn id="gcop-source-atop" title="gcop-source-atop"><code>source-atop</code></dfn></dt>

   <dd><var>A</var> atop <var>B</var>. <span class="note">Display the
   source image wherever both images are opaque. Display the
   destination image wherever the destination image is opaque but the
   source image is transparent. Display transparency elsewhere.</span></dd>

   <dt><dfn id="gcop-source-in" title="gcop-source-in"><code>source-in</code></dfn></dt>

   <dd><var>A</var> in <var>B</var>. <span class="note">Display the
   source image wherever both the source image and destination image
   are opaque. Display transparency elsewhere.</span></dd>

   <dt><dfn id="gcop-source-out" title="gcop-source-out"><code>source-out</code></dfn></dt>

   <dd><var>A</var> out <var>B</var>. <span class="note">Display the
   source image wherever the source image is opaque and the
   destination image is transparent. Display transparency
   elsewhere.</span></dd>

   <dt><dfn id="gcop-source-over" title="gcop-source-over"><code>source-over</code></dfn> (default)</dt>

   <dd><var>A</var> over <var>B</var>. <span class="note">Display the
   source image wherever the source image is opaque. Display the
   destination image elsewhere.</span></dd>


   <dt><dfn id="gcop-destination-atop" title="gcop-destination-atop"><code>destination-atop</code></dfn></dt>

   <dd><var>B</var> atop <var>A</var>. <span class="note">Same as <code title="gcop-source-atop"><a href="#gcop-source-atop">source-atop</a></code> but using the
   destination image instead of the source image and vice versa.</span></dd>

   <dt><dfn id="gcop-destination-in" title="gcop-destination-in"><code>destination-in</code></dfn></dt>

   <dd><var>B</var> in <var>A</var>. <span class="note">Same as <code title="gcop-source-in"><a href="#gcop-source-in">source-in</a></code> but using the destination
   image instead of the source image and vice versa.</span></dd>

   <dt><dfn id="gcop-destination-out" title="gcop-destination-out"><code>destination-out</code></dfn></dt>

   <dd><var>B</var> out <var>A</var>. <span class="note">Same as <code title="gcop-source-out"><a href="#gcop-source-out">source-out</a></code> but using the destination
   image instead of the source image and vice versa.</span></dd>

   <dt><dfn id="gcop-destination-over" title="gcop-destination-over"><code>destination-over</code></dfn></dt>

   <dd><var>B</var> over <var>A</var>. <span class="note">Same as <code title="gcop-source-over"><a href="#gcop-source-over">source-over</a></code> but using the
   destination image instead of the source image and vice versa.</span></dd>


<!-- no clear definition of this operator (doesn't correspond to a PorterDuff operator)
   <dt><dfn title="gcop-darker"><code>darker</code></dfn></dt>

   <dd><span class="note">Display the sum of the source image and destination image,
   with color values approaching 0 as a limit.</span></dd>
-->

   <dt><dfn id="gcop-lighter" title="gcop-lighter"><code>lighter</code></dfn></dt>

   <dd><var>A</var> plus <var>B</var>. <span class="note">Display the
   sum of the source image and destination image, with color values
   approaching 255 (100%) as a limit.</span></dd>


   <dt><dfn id="gcop-copy" title="gcop-copy"><code>copy</code></dfn></dt>

   <dd><var>A</var> (<var>B</var> is
   ignored). <span class="note">Display the source image instead of the destination
   image.</span></dd>


   <dt><dfn id="gcop-xor" title="gcop-xor"><code>xor</code></dfn></dt>

   <dd><var>A</var> xor <var>B</var>. <span class="note">Exclusive OR
   of the source image and destination image.</span></dd>


   <dt class="impl"><code><var>vendorName</var>-<var>operationName</var></code></dt>

   <dd class="impl">Vendor-specific extensions to the list of
   composition operators should use this syntax.</dd>

  </dl>

  <div class="impl">

  <p>The operators in the above list must be treated as described by
  the Porter-Duff operator given at the start of their description
  (e.g. <var>A</var> over <var>B</var>). They are to
  be applied as part of the <a href="#drawing-model">drawing model</a>, at which point the
  <a href="#clipping-region">clipping region</a> is also applied. (Without a clipping
  region, these operators act on the whole bitmap with every
  operation.) <a href="#refsPORTERDUFF">[PORTERDUFF]</a></p>

  <p>These values are all case-sensitive — they must be used
  exactly as shown. User agents must not recognize values that are not
  a <span>case-sensitive</span> match for one of the values given
  above.</p>

  <p>On setting, if the user agent does not recognize the specified
  value, it must be ignored, leaving the value of <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>
  unaffected.</p>

  <p>When the context is created, the <code title="dom-context-2d-globalCompositeOperation"><a href="#dom-context-2d-globalcompositeoperation">globalCompositeOperation</a></code>
  attribute must initially have the value
  <code>source-over</code>.</p>

  </div>




  <h2 id="shadows"><span class="secno">16 </span><dfn>Тени</dfn></h2>

  <p>Все операции рисования затронуты четырьмя глобальными теневыми атрибутами.</p>

  <dl class="domintro">

   <dt><var>context</var> . <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий цвет тени.</p>

    <p>Может быть настроен, чтобы изменить цвет тени. Значения которые не читаются как цвета CSS, игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> [ = <var>value</var> ]</dt>
   <dt><var>context</var> . <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущее смещение тени.</p>

    <p>Может быть настроен, чтобы изменить смешение тени. Значения отличные от конечных чисел, игнорируются.</p>

   </dd>

   <dt><var>context</var> . <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> [ = <var>value</var> ]</dt>

   <dd>

    <p>Возвращает текущий уровень размытия применяемый к теням.</p>

    <p>Может быть настроен, чтобы изменить уровень размытия. Значения (конечные числа) больше ноля или равные ему, игнорируются.</p>

   </dd>

  </dl>

  <div class="impl">

  <p>The <dfn id="dom-context-2d-shadowcolor" title="dom-context-2d-shadowColor"><code>shadowColor</code></dfn>
  attribute sets the color of the shadow.</p>

  <p>When the context is created, the <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> attribute
  initially must be fully-transparent black.</p>

  <p>On getting, the <a href="#serialization-of-a-color" title="serialization of a
  color">serialization of the color</a> must be returned.</p>

  <p>On setting, the new value must be <span>parsed as a CSS
  &lt;color&gt; value</span> and the color assigned. If the value
  cannot be parsed as a CSS &lt;color&gt; value then it must be
  ignored, and the attribute must retain its previous value. <a href="#refsCSSCOLOR">[CSSCOLOR]</a></p>

  <p>The <dfn id="dom-context-2d-shadowoffsetx" title="dom-context-2d-shadowOffsetX"><code>shadowOffsetX</code></dfn>
  and <dfn id="dom-context-2d-shadowoffsety" title="dom-context-2d-shadowOffsetY"><code>shadowOffsetY</code></dfn>
  attributes specify the distance that the shadow will be offset in
  the positive horizontal and positive vertical distance
  respectively. Their values are in coordinate space units. They are
  not affected by the current transformation matrix.</p>

  <p>When the context is created, the shadow offset attributes must
  initially have the value <code>0</code>.</p>

  <p>On getting, they must return their current value. On setting, the
  attribute being set must be set to the new value, except if the
  value is infinite or NaN, in which case the new value must be
  ignored.</p>

  <p>The <dfn id="dom-context-2d-shadowblur" title="dom-context-2d-shadowBlur"><code>shadowBlur</code></dfn>
  attribute specifies the level of the blurring effect. (The units do
  not map to coordinate space units, and are not affected by the
  current transformation matrix.)</p>

  <p>When the context is created, the <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> attribute must
  initially have the value <code>0</code>.</p>

  <p>On getting, the attribute must return its current value. On
  setting the attribute must be set to the new value, except if the
  value is negative, infinite or NaN, in which case the new value must
  be ignored.</p>

  <p><dfn id="when-shadows-are-drawn" title="when shadows are drawn">Shadows are only drawn
  if</dfn> the opacity component of the alpha component of the color
  of <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code> is
  non-zero and at leasty one of <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>, <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code>, or <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> is
  non-zero.</p>

  <p class="critical">It is likely that this will change: browser
  vendors have indicated an interest in changing the processing model
  for shadows such that they only draw when the composition operator
  is "source-over" (the default). <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-May/thread.html#31457">Read
  more...</a></p>

  <p><a href="#when-shadows-are-drawn">When shadows are drawn</a>, they must be rendered as follows:</p>

  <ol>

   <li> <p>Let <var>A</var> be an infinite transparent black
   bitmap on which the source image for which a shadow is being
   created has been rendered.</p> </li>

   <li> <p>Let <var>B</var> be an infinite transparent black
   bitmap, with a coordinate space and an origin identical to <var>A</var>.</p> </li>

   <li> <p>Copy the alpha channel of <var>A</var> to <var>B</var>, offset by <code title="dom-context-2d-shadowOffsetX"><a href="#dom-context-2d-shadowoffsetx">shadowOffsetX</a></code> in the
   positive <var>x</var> direction, and <code title="dom-context-2d-shadowOffsetY"><a href="#dom-context-2d-shadowoffsety">shadowOffsetY</a></code> in the
   positive <var>y</var> direction.</p> </li>

   <li> <p>If <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code> is greater than
   0:</p>

    <ol>

     <li> <p>Let <var>σ</var> be half the value of
     <code title="dom-context-2d-shadowBlur"><a href="#dom-context-2d-shadowblur">shadowBlur</a></code>.</p></li>

     <li> <p>Perform a 2D Gaussian Blur on <var>B</var>,
     using <var>σ</var> as the standard deviation.</p>
     <!-- wish i could find a reference for this --> </li>

    </ol>

    <p>User agents may limit values of <var>σ</var> to
    an implementation-specific maximum value to avoid exceeding
    hardware limitations during the Gaussian blur operation.</p>

   </li>

   <li> <p>Set the red, green, and blue components of every pixel in
   <var>B</var> to the red, green, and blue components
   (respectively) of the color of <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p> </li>

   <li> <p>Multiply the alpha component of every pixel in <var>B</var> by the alpha component of the color of <code title="dom-context-2d-shadowColor"><a href="#dom-context-2d-shadowcolor">shadowColor</a></code>.</p> </li>

   <li> <p>The shadow is in the bitmap <var>B</var>, and is
   rendered as part of the <a href="#drawing-model">drawing model</a> described below.</p> </li>

  </ol>

  </div>

  <p>If the current composition operation is <code title="gcop-copy"><a href="#gcop-copy">copy</a></code>, shadows effectively won't render
  (since the shape will overwrite the shadow).</p>



  <div class="impl">

  <h2 id="drawing-model"><span class="secno">17 </span><dfn>Модель рисования</dfn></h2>

  <p>Когда форма или изображение нарисованы, пользовательские агенты должны следовать этим шагам в указанном порядке (или действовать как будто следуют):</p>

  <ol>

   <li><p>Визуализировать форму или изображение на бесконечно прозрачное черное растровое изображение, создавая изображение <var>A</var>, как описано в предыдущих разделах. Для фигур текущее заполнение, обводки и стили должны быть выполнены, и сглаживание также должено быть подвергнуто текущей матрице преобразования.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, визуализировать тень с изображения <var>A</var>, используя текущие стили изображения, создавая изображение <var>B</var>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, умножать альфа-компонент каждого пикселя в <var>B</var> с помощью <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p><a href="#when-shadows-are-drawn">Когда тени нарисованы</a>, добавить <var>B</var> в пределах <a href="#clipping-region">clipping region</a> над текущим растровым изображением холста с помощью текущего оператора композиции.</p></li>

   <li><p>Умножить альфа-компонент каждого пикселя в <var>A</var> с помощью <code title="dom-context-2d-globalAlpha"><a href="#dom-context-2d-globalalpha">globalAlpha</a></code>.</p></li>

   <li><p>Добавить <var>A</var> в пределах <a href="#clipping-region">clipping
   region</a> над текущим растровым изображением холста с помощью текущего оператора композиции.</p></li>

  </ol>

  </div>


  <h2 id="best-practices"><span class="secno">18 </span>Лучшая практика</h2>

  <p><i>Этот раздел не является нормативным.</i></p>
  <p>Когда холст (canvas) является интерактивным, авторы должны включать фокусируемые элементы в содержание запасного элемента, соответствующие каждой фокусируемой части холста.</p>

  <p>To indicate which focusable part of the canvas is currently
  focused, authors should use the <code title="dom-context-2d-drawFocusIfNeeded"><a href="#dom-context-2d-drawfocusifneeded">drawFocusIfNeeded()</a></code>
  method, passing it the element for which an outline is being drawn. This
  method only draws the focus outline if the element is focused, so that
  it can simply be called whenever drawing the element, without
  checking whether the element is focused or not first.</p>

  <p>Authors should avoid implementing text editing controls using the
  <code>canvas</code> element. Doing so has a large number of
  disadvantages:</p>

  <ul>

   <li>Mouse placement of the caret has to be reimplemented.</li>

   <li>Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).</li>

   <li>Scrolling of the text field has to be implemented (horizontally for long lines, vertically for multiline input).</li>

   <li>Native features such as copy-and-paste have to be reimplemented.</li>

   <li>Native features such as spell-checking have to be reimplemented.</li>

   <li>Native features such as drag-and-drop have to be reimplemented.</li>

   <li>Native features such as page-wide text search have to be reimplemented.</li>

   <li>Native features specific to the user, for example custom text
   services, have to be reimplemented. This is close to impossible
   since each user might have different services installed, and there
   is an unbounded set of possible such services.</li>

   <li>Bidirectional text editing has to be reimplemented.</li>

   <li>For multiline text editing, line wrapping has to be implemented for all relevant languages.</li>

   <li>Text selection has to be reimplemented.</li>

   <li>Dragging of bidirectional text selections has to be reimplemented.</li>

   <li>Platform-native keyboard shortcuts have to be reimplemented.</li>

   <li>Platform-native input method editors (IMEs) have to be reimplemented.</li>

   <li>Undo and redo functionality has to be reimplemented.</li>

   <li>Accessibility features such as magnification following the
   caret or selection have to be reimplemented.</li>

  </ul>

  <p>This is a huge amount of work, and authors are most strongly
  encouraged to avoid doing any of it by instead using the
  <code>input</code> element, the <code>textarea</code> element, or
  the <code title="attr-contenteditable">contenteditable</code>
  attribute.</p>


  <h2 id="examples"><span class="secno">19 </span>Примеры</h2>

  <p><i>Этот раздел не является нормативным.</i></p>
  <div class="example">

  <p>Ниже приведен пример кода, который использует canvas, чтобы нарисовать <a href="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIEhUTUw%2BDQo8aHRtbCBsYW5nPSJlbiI%2BDQogPGhlYWQ%2BDQogIDx0aXRsZT5QcmV0dHkgR2xvd2luZyBMaW5lczwvdGl0bGU%2BDQogPC9oZWFkPg0KIDxib2R5Pg0KPGNhbnZhcyB3aWR0aD0iODAwIiBoZWlnaHQ9IjQ1MCI%2BPC9jYW52YXM%2BDQo8c2NyaXB0Pg0KDQogdmFyIGNvbnRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF0uZ2V0Q29udGV4dCgnMmQnKTsNCg0KIHZhciBsYXN0WCA9IGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKTsNCiB2YXIgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KIHZhciBodWUgPSAwOw0KIGZ1bmN0aW9uIGxpbmUoKSB7DQogICBjb250ZXh0LnNhdmUoKTsNCiAgIGNvbnRleHQudHJhbnNsYXRlKGNvbnRleHQuY2FudmFzLndpZHRoLzIsIGNvbnRleHQuY2FudmFzLmhlaWdodC8yKTsNCiAgIGNvbnRleHQuc2NhbGUoMC45LCAwLjkpOw0KICAgY29udGV4dC50cmFuc2xhdGUoLWNvbnRleHQuY2FudmFzLndpZHRoLzIsIC1jb250ZXh0LmNhbnZhcy5oZWlnaHQvMik7DQogICBjb250ZXh0LmJlZ2luUGF0aCgpOw0KICAgY29udGV4dC5saW5lV2lkdGggPSA1ICsgTWF0aC5yYW5kb20oKSAqIDEwOw0KICAgY29udGV4dC5tb3ZlVG8obGFzdFgsIGxhc3RZKTsNCiAgIGxhc3RYID0gY29udGV4dC5jYW52YXMud2lkdGggKiBNYXRoLnJhbmRvbSgpOw0KICAgbGFzdFkgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpOw0KICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoICogTWF0aC5yYW5kb20oKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgKiBNYXRoLnJhbmRvbSgpLA0KICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RYLCBsYXN0WSk7DQoNCiAgIGh1ZSA9IGh1ZSArIDEwICogTWF0aC5yYW5kb20oKTsNCiAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnaHNsKCcgKyBodWUgKyAnLCA1MCUsIDUwJSknOw0KICAgY29udGV4dC5zaGFkb3dDb2xvciA9ICd3aGl0ZSc7DQogICBjb250ZXh0LnNoYWRvd0JsdXIgPSAxMDsNCiAgIGNvbnRleHQuc3Ryb2tlKCk7DQogICBjb250ZXh0LnJlc3RvcmUoKTsNCiB9DQogc2V0SW50ZXJ2YWwobGluZSwgNTApOw0KDQogZnVuY3Rpb24gYmxhbmsoKSB7DQogICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuMSknOw0KICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTsNCiB9DQogc2V0SW50ZXJ2YWwoYmxhbmssIDQwKTsNCg0KPC9zY3JpcHQ%2BDQogPC9ib2R5Pg0KPC9odG1sPg0K">довольно яркие линии</a>.</p>

  <pre>&lt;canvas width="800" height="450"&gt;&lt;/canvas&gt;
&lt;script&gt;

 var context = document.getElementsByTagName('canvas')[0].getContext('2d');

 var lastX = context.canvas.width * Math.random();
 var lastY = context.canvas.height * Math.random();
 var hue = 0;
 function line() {
   context.save();
   context.translate(context.canvas.width/2, context.canvas.height/2);
   context.scale(0.9, 0.9);
   context.translate(-context.canvas.width/2, -context.canvas.height/2);
   context.beginPath();
   context.lineWidth = 5 + Math.random() * 10;
   context.moveTo(lastX, lastY);
   lastX = context.canvas.width * Math.random();
   lastY = context.canvas.height * Math.random();
   context.bezierCurveTo(context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         context.canvas.width * Math.random(),
                         context.canvas.height * Math.random(),
                         lastX, lastY);

   hue = hue + 10 * Math.random();
   context.strokeStyle = 'hsl(' + hue + ', 50%, 50%)';
   context.shadowColor = 'white';
   context.shadowBlur = 10;
   context.stroke();
   context.restore();
 }
 setInterval(line, 50);

 function blank() {
   context.fillStyle = 'rgba(0,0,0,0.1)';
   context.fillRect(0, 0, context.canvas.width, context.canvas.height);
 }
 setInterval(blank, 40);

&lt;/script&gt;</pre>

  </div>


<!--FIXUP 2dcontext -4-->
  <h2 class="no-num" id="references">Ссылки</h2><!--REFS-->

  <p>Все ссылки являются нормативными, если не указано "не нормативная".</p>

  <!-- Dates are only included for standards older than the Web, because the newer ones keep changing. -->

  <dl>
<!--REFERENCES ON-->

   <dt id="refsBEZIER">[BEZIER]</dt>
   <dd><cite>Courbes à poles</cite>, P. de Casteljau. INPI, 1959.</dd>

   <!--
   <dd><cite><a href="http://tools.ietf.org/html/rfc2109">HTTP State Management Mechanism</a></cite>, D. Kristol, L. Montulli. IETF.</dd>
   <dd><cite><a href="http://tools.ietf.org/html/rfc2965">HTTP State Management Mechanism</a></cite>, D. Kristol, L. Montulli. IETF.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/cors/">Cross-Origin
   Resource Sharing</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!-- really should be "NARUSE, Y." or some
   such, but there's a western bias to these references for
   consistency. sorry. -->

   <!-- really should be "NARUSE, Y." or some
   such, but there's a western bias to these references for
   consistency. sorry. -->

   <dt id="refsCSS">[CSS]</dt>
   <dd><cite><a href="http://www.w3.org/TR/CSS/">Cascading Style Sheets Level 2
   Revision 1</a> (URL: <a href="http://www.w3.org/TR/CSS/">http://www.w3.org/TR/CSS/</a>)</cite>, B. Bos, T. Çelik, I.
   Hickson, H. Lie. W3C.</dd>

   <dt id="refsCSSCOLOR">[CSSCOLOR]</dt>
   <!--
   <dd><cite><a href="http://www.w3.org/TR/css3-color/">CSS Color
   Module Level 3</a></cite>, T. &Ccedil;elik, C. Lilley, L.
   Baron. W3C.</dd>
   -->
   <dd><cite><a href="http://www.w3.org/TR/css3-color/">CSS Color
   Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-color/">http://www.w3.org/TR/css3-color/</a>)</cite>, T. Çelik, C. Lilley, L.
   Baron. 7 June 2011. Рекомендация W3C.</dd>

   <dt id="refsCSSFONTS">[CSSFONTS]</dt>
   <dd><cite><a href="http://www.w3.org/TR/css3-fonts/">CSS Fonts
   Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-fonts/">http://www.w3.org/TR/css3-fonts/</a>)</cite>, J. Daggett. W3C.</dd>

   <dt id="refsCSSIMAGES">[CSSIMAGES]</dt>
   <dd><cite><a href="http://www.w3.org/TR/css3-images/">CSS Image
   Values and Replaced Content Module Level 3</a> (URL: <a href="http://www.w3.org/TR/css3-images/">http://www.w3.org/TR/css3-images/</a>)</cite>, E. Etemad,
   T. Atkins. W3C.</dd>

   <dt id="refsCSSOM">[CSSOM]</dt>
   <dd><cite><a href="http://www.w3.org/TR/cssom/">Cascading Style Sheets
   Object Model (CSSOM)</a> (URL: <a href="http://www.w3.org/TR/cssom/">http://www.w3.org/TR/cssom/</a>)</cite>, S. Pieters, G. Adams. W3C.</dd>

   <!--
   <dd><cite><a
   href="http://www.w3.org/TR/DOM-Level-3-Events/">Document Object
   Model (DOM) Level 3 Events Specification</a></cite>,
   B. H&ouml;hrmann, P. Le Hegaret, T. Pixley. W3C.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/eventsource/">Server-Sent
   Events</a></cite>, I. Hickson. W3C.</dd>
   -->
   <!-- http://www.iana.org/assignments/charset-reg/GBK -->

   <!--
   This book ("Computer Graphics: Principles and Practice in C")
   apparently does not make any references to literature in the
   bibliographic section to define the "even-odd" rule for polygon
   filling and hit testing. In the absence of such a reference, I
   guess that this book is the most authoritative reference.
   -->

   <dt id="refsHTML">[HTML]</dt>
   <dd>Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Edward O'Connor; Silvia Pfeiffer. <a href="http://www.w3.org/TR/html5/"><cite>HTML5</cite></a>. 28 октября 2014. Рекомендация W3C. URL: <a href="http://www.w3.org/TR/html5/">http://www.w3.org/TR/html5/</a></dd>

   <!--
   <dd>(Non-normative) <cite><a
   href="http://www.w3.org/TR/html5-diff/">HTML5 differences from
   HTML4</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!--
   <dd><cite><a href="http://www.w3.org/TR/css3-mediaqueries/">Media
   Queries</a></cite>, H. Lie, T.  &Ccedil;elik, D. Glazman, A. van
   Kesteren. W3C.</dd>
   -->
   <dt id="refsPORTERDUFF">[PORTERDUFF]</dt>
   <dd><cite><a href="http://keithp.com/~keithp/porterduff/p253-porter.pdf">Compositing
   Digital Images</a> (URL: <a href="http://keithp.com/~keithp/porterduff/p253-porter.pdf">http://keithp.com/~keithp/porterduff/p253-porter.pdf</a>)</cite>, T. Porter, T. Duff. В <cite>Компьютерной графике</cite>, том 18, номер 3, стр. 253-259. ACM Press, июль
   1984.</dd>

   <!-- for text/plain and
   "Internet Media type"; not for definition of "valid MIME type". -->

   <dt id="refsTYPEDARRAY">[TYPEDARRAY]</dt>
   <dd><cite><a href="https://www.khronos.org/registry/typedarray/specs/latest/">Typed Array Specification</a> (URL: <a href="https://www.khronos.org/registry/typedarray/specs/latest/">https://www.khronos.org/registry/typedarray/specs/latest/</a>)</cite>, D. Herman, K. Russell. Khronos.</dd>

   <dt id="refsWEBIDL">[WEBIDL]</dt>
   <dd><a href="http://www.w3.org/TR/WebIDL-1/"><cite>Web IDL</cite></a> (URL: <a href="http://www.w3.org/TR/WebIDL-1/">http://www.w3.org/TR/WebIDL-1/</a>), Cameron McCormack, Boris Zbarsky, Yves Lafon, Travis Leithead. W3C.

   <!--
   <dd><cite><a href="http://www.w3.org/TR/XMLHttpRequest/">The XMLHttpRequest
   Object</a></cite>, A. van Kesteren. W3C.</dd>
   -->
   <!--(once XSLTProcessor is defined somewhere, update this and the place that references this)
   <dt id="refsXSLTP">[XSLTP]</dt>
   <dd>(Non-normative) <cite><a href=""></a></cite>, . .</dd>
-->


   <!--REFERENCES OFF-->
  </dl>


</body></html>

