<!DOCTYPE html>
<html lang="ru">
<head>
<meta lang="" property="dc:language" content="ru">
<meta charset="utf-8">
<title>W3C DOM4</title>

  <style>
/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title , div.ednote-title, div.warning-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title, div.ednote-title { color: #2b2; }
div.warning-title { color: #f22; }
div.issue-title span, div.note-title span, div.ednote-title span, div.warning-title span {
    text-transform: uppercase;
}
div.note, div.issue, div.ednote, div.warning {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .ednote > p:first-child, .issue > p:first-child, .warning > p:first-child { margin-top: 0 }
.issue, .note, .ednote, .warning {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note , div.ednote,  div.warning {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.ednote, span.issue, span.warning { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note, .ednote {
    border-color: #52e052;
    background: #e9fbe9;
}

.warning {
    border-color: #f11;
    border-right-width: .2em;
    border-top-width: .2em;
    border-bottom-width: .2em;
    border-style: solid;
    background: #fbe9e9;
}

.warning-title:before{
    content: "⚠"; /*U+26A0 WARNING SIGN*/
    font-size: 3em;
    float: left;
    height: 100%;
    padding-right: .3em;
    vertical-align: top;
    margin-top: -0.5em;
}

li.task-list-item {
    list-style: none;
}

input.task-list-item-checkbox {
    margin: 0 0.35em 0.25em -1.6em;
    vertical-align: middle;
}
</style>

  <link rel="stylesheet" href="https://www.w3.org/TR/dom/style.css">
  <link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/W3C-REC"><!--[if lt IE 9]><![endif]-->

<style>
  .translator { border: solid 2px black; background-color: #EEE9E9; padding: 5px; font-size: 15px; margin-bottom: 20px; }
  dl.domintro:before { content: 'Эта рамка не является нормативной. Требования к реализации приведены ниже нее.'; }
  p.warning:before { content: '\26A0 Внимание! '; }
</style>

</head>

  <!-- Yandex.Metrika counter --> <script type="text/javascript"> (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter36816840 = new Ya.Metrika({ id:36816840, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/36816840" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->

<p class="translator">
Этот документ является неофициальным переводом исходной английской версии <a href="https://www.w3.org/TR/dom/" target="_blank" rel="nofollow">W3C DOM4</a>. Обратите внимание на то, что оригинальная версия документа существует только на английском языке. Данный перевод может содержать неточности и ошибки. Перевод выполнил <a href="http://topolyan.com/" target="_blank">Кирилл Топольян</a>, 2017.</p>

<div class='head'>
  <p>


            <a href="http://www.w3.org/"><img width="72" height="48" src="https://www.w3.org/Icons/w3c_home" alt="W3C"></a>


  </p>
  <h1 class="title p-name" id="title" property="dcterms:title">W3C DOM4</h1>

  <h2 id="w3c-recommendation-19-november-2015">Рекомендация W3C от <time property="dcterms:issued" class="dt-published" datetime="2015-11-19">19 ноября 2015</time></h2>
  <dl>

      <dt>Эта версия:</dt>
      <dd><a class="u-url" href="http://www.w3.org/TR/2015/REC-dom-20151119/">http://www.w3.org/TR/2015/REC-dom-20151119/</a></dd>
      <dt>Последняя опубликованная версия:</dt>
      <dd><a href="http://www.w3.org/TR/dom/">http://www.w3.org/TR/dom/</a></dd>



      <dt>Доклад о реализации:</dt>
      <dd><a href="http://w3c.github.io/test-results/dom/details.html">http://w3c.github.io/test-results/dom/details.html</a></dd>


      <dt>Баг-трекер:</dt>
      <dd><a href="https://github.com/w3c/dom/issues/new">сообщить о баге</a> (<a href="https://github.com/w3c/dom/issues">открытые баги</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=DOM&amp;resolution=---">старые баги</a>)</dd>



      <dt>Предыдущая версия:</dt>
      <dd><a rel="dcterms:replaces" href="http://www.w3.org/TR/2015/PR-dom-20151006/">http://www.w3.org/TR/2015/PR-dom-20151006/</a></dd>


    <dt>Редакторы:</dt>
    <dd class="p-author h-card vcard" property="bibo:editor" resource="_:editor0"><span property="rdf:first" typeof="foaf:Person"><meta property="foaf:name" content="Anne van Kesteren"><a class="u-url url p-name fn" property="foaf:homepage" rel="nofollow" href="https://annevankesteren.nl/">Anne van Kesteren</a>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a> (версия WHATWG)</span>
<span property="rdf:rest" resource="_:editor1"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor1"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Aryeh Gregor</span>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a> (версия WHATWG)</span>
<span property="rdf:rest" resource="_:editor2"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor2"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Ms2ger</span>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a> (версия WHATWG)</span>
<span property="rdf:rest" resource="_:editor3"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor3"><span property="rdf:first" typeof="foaf:Person"><meta property="foaf:name" content="Alex Russell"><a class="u-url url p-name fn" property="foaf:homepage" rel="nofollow" href="https://infrequently.org/">Alex Russell</a>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.google.com/">Google</a></span>
<span property="rdf:rest" resource="_:editor4"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor4"><span property="rdf:first" typeof="foaf:Person"><meta property="foaf:name" content="Robin Berjon"><a class="u-url url p-name fn" property="foaf:homepage" rel="nofollow" href="http://berjon.com/">Robin Berjon</a>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="http://www.w3.org/">W3C</a></span>
<span property="rdf:rest" resource="rdf:nil"></span>
</dd>



  </dl>


   <p>Смотрите <a href="http://www.w3.org/2015/11/dom-errata.html"><strong>страницу исправлений</strong></a> этого документа, которая может включать в себя изменения после публикации.</p>

   <p>Также смотрите <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=dom"> <strong>переводы</strong></a>.</p>



   <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2015 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). Применяются правила <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">ответственности</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">торговой марки</a> и <a href="http://www.w3.org/Consortium/Legal/copyright-documents">использования документов</a> W3C.</p>

  <hr>
</div>


<h2 class="no-num no-toc" id="abstract">Аннотация</h2>
<p>DOM определяет платформо-независимую модель для событий и узлов деревьев. DOM4 добавляет <a href='#mutation-observers'>Mutation Observers (наблюдатели изменений)</a> как замену <a href='http://www.w3.org/TR/uievents/#legacy-mutationevent-events'>Mutation Events</a>.
</p>


<h2 id="h-sotd" resource="#h-sotd"><span property="xhv:role" resource="xhv:heading">Статус этого документа</span></h2>



        <p>
          <em>Этот раздел описывает статус данного документа на момент его публикации. Другие документы могут заменить этот документ. Список актуальных публикаций W3C и последняя ревизия этого технического доклада могут быть найдены в <a href="http://www.w3.org/TR/">индексе технических докладов W3C</a> по адресу http://www.w3.org/TR/.</em>
        </p>


      <p>
        Этот документ опубликован как снимок
        <a href="https://dom.spec.whatwg.org/">DOM Living Standard</a> с намерением поддержания отличий от оригинала к строгому минимуму, и только через формирование подмножеств (только не реализованные вещи были удалены из этой публикации).
      </p>
      <div class="warning"><div class="warning-title"><span>Предупреждение</span></div><div class="">
        <p>
          Разработчики должны принять во внимание
          <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=DOM&amp;resolution=---">старый список багов</a> в общем, но в особенности эти два бага, которые могут отрицательно повлиять на совместимость (более конкретно на
          <a href="#interface-document"><code>Document</code> интерфейс</a>):
        </p>
        <ul>
          <li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431">Баг 19431: Пространства имен элементов сделанные с помощью .createElement() в документах XML должны быть null</a></li>
          <li><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">Баг 22960: Document, XMLDocument, HTMLDocument, боже мой</a></li>
        </ul>
      </div></div>

        <p>
          Этот документ был опубликован <a href="http://www.w3.org/html/wg/">Рабочей группой HTML</a> как Рекомендация.
</p>

<p>Если вы хотите оставить комментарии к этому документу в порядке который отслеживается W3C, пожалуйста, добавьте их с помощью <a href="https://github.com/w3c/dom/issues">нашего публичного списка вопросов</a>. Если вы не можете сделать это, вы можете отправить e-mail на <a href="mailto:www-dom@w3.org">www-dom@w3.org</a>
    (<a href="mailto:www-dom-request@w3.org?subject=subscribe">подписка</a>,
    <a href="http://lists.w3.org/Archives/Public/www-dom/">архивы</a>), и мы примем меры чтобы перенести комментарии в нашу публичную базу данных багов. Любая обратная связь приветствуется.</p>

        <p>С момента предыдущей публикации изменений не было.</p>

          <p>
           Доступен <a href="http://w3c-test.org/dom/">обширный набор тестов</a> для этой спецификации. Посмотрите <a href="http://w3c.github.io/test-results/dom/details.html">отчет о реализации</a> Рабочей группы.
          </p>


  <p>Этот документ был рассмотрен членами W3C, разработчиками программного обеспечения, а также другими группами W3C и заинтересованными лицами, и одобрен Директором в качестве Рекомендации W3C. Это стабильный документ и может быть использован в качестве справочного материала или цитироваться из другого документа. Роль W3C в создании Рекомендации заключается в привлечении внимания к спецификации и способствовании ее широкому распространению. Это повышает функциональность и совместимость Веба.</p>

  <p>
Этот документ был подготовлен группой действующей под <a id="sotd_patent" property="w3p:patentRules" href="http://www.w3.org/Consortium/Patent-Policy-20040205/">Патентной политикой W3C от 5 февраля 2004</a>. W3C поддерживает публичный <a href="http://www.w3.org/2004/01/pp-impl/40318/status" rel="disclosure">список открытых патентов</a>, сделанных в связи с результатами деятельности группы; эта страница также включает в себя инструкции по раскрытию патента. Человек, который имеет фактическое знание патента, соответствующего <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">основным требованиям</a>, должен раскрыть информацию в соответствии с <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">разделом 6 патентной политики W3C</a>.
 </p>

  <p>
Данный документ регулируется <a id="w3c_process_revision" href="http://www.w3.org/2005/10/Process-20051014/">W3C Process Document от 14 октября 2005</a>.
  </p>







<h2 class="no-num no-toc" id="table-of-contents">Содержание</h2>

<!--begin-toc-->
<ol class="toc">
 <li><a class="no-num" href="#goals">Цели</a></li>
 <li><a href="#conformance"><span class="secno">1 </span>Соответствие</a>
  <ol>
   <li><a href="#dependencies"><span class="secno">1.1 </span>Зависимости</a></li>
   <li><a href="#extensibility"><span class="secno">1.2 </span>Расширяемость</a></ol></li>
 <li><a href="#terminology"><span class="secno">2 </span>Терминология</a>
  <ol>
   <li><a href="#trees"><span class="secno">2.1 </span>Деревья</a></li>
   <li><a href="#strings"><span class="secno">2.2 </span>Строки</a></li>
   <li><a href="#ordered-sets"><span class="secno">2.3 </span>Упорядоченные множества</a></li>
   <li><a href="#namespaces"><span class="secno">2.4 </span>Пространства имен</a></ol></li>
 <li><a href="#events"><span class="secno">3 </span>События</a>
  <ol>
   <li><a href="#introduction-to-dom-events"><span class="secno">3.1 </span>Введение в "DOM Events"</a></li>
   <li><a href="#interface-event"><span class="secno">3.2 </span>Интерфейс <code>Event</code></a></li>
   <li><a href="#interface-customevent"><span class="secno">3.3 </span>Интерфейс <code>CustomEvent</code></a></li>
   <li><a href="#constructing-events"><span class="secno">3.4 </span>Создание событий</a></li>
   <li><a href="#defining-event-interfaces"><span class="secno">3.5 </span>Определение интерфейсов событий</a></li>
   <li><a href="#interface-eventtarget"><span class="secno">3.6 </span>Интерфейс <code>EventTarget</code></a></li>
   <li><a href="#dispatching-events"><span class="secno">3.7 </span>Отправка событий</a></li>
   <li><a href="#firing-events"><span class="secno">3.8 </span>Вызов событий</a></ol></li>
 <li><a href="#nodes"><span class="secno">4 </span>Узлы</a>
  <ol>
   <li><a href="#introduction-to-the-dom"><span class="secno">4.1 </span>Введение в "The DOM"</a></li>
   <li><a href="#node-tree"><span class="secno">4.2 </span>Дерево узлов</a>
    <ol>
     <li><a href="#mutation-algorithms"><span class="secno">4.2.1 </span>Алгоритмы изменений</a></li>
     <li><a href="#interface-nonelementparentnode"><span class="secno">4.2.2 </span>Интерфейс <code>NonElementParentNode</code></a></li>
     <li><a href="#interface-parentnode"><span class="secno">4.2.3 </span>Интерфейс <code>ParentNode</code></a></li>
     <li><a href="#interface-nondocumenttypechildnode"><span class="secno">4.2.4 </span>Интерфейс <code>NonDocumentTypeChildNode</code></a></li>
     <li><a href="#interface-childnode"><span class="secno">4.2.5 </span>Интерфейс <code>ChildNode</code></a></li>
     <li><a href="#old-style-collections:-nodelist-and-htmlcollection"><span class="secno">4.2.6 </span>Коллекции старого типа: <code>NodeList</code> и <code>HTMLCollection</code></a>
      <ol>
       <li><a href="#interface-nodelist"><span class="secno">4.2.6.1 </span>Интерфейс <code>NodeList</code></a></li>
       <li><a href="#interface-htmlcollection"><span class="secno">4.2.6.2 </span>Интерфейс <code>HTMLCollection</code></a></ol></ol></li>
   <li><a href="#mutation-observers"><span class="secno">4.3 </span>Наблюдатели изменений (Mutation observers)</a>
    <ol>
     <li><a href="#interface-mutationobserver"><span class="secno">4.3.1 </span>Интерфейс <code>MutationObserver</code></a></li>
     <li><a href="#queuing-a-mutation-record"><span class="secno">4.3.2 </span>Очередь записи изменений</a></li>
     <li><a href="#interface-mutationrecord"><span class="secno">4.3.3 </span>Интерфейс <code>MutationRecord</code></a></li>
     <li><a href="#garbage-collection"><span class="secno">4.3.4 </span>Сборка мусора</a></ol></li>
   <li><a href="#interface-node"><span class="secno">4.4 </span>Интерфейс <code>Node</code></a></li>
   <li><a href="#interface-document"><span class="secno">4.5 </span>Интерфейс <code>Document</code></a>
    <ol>
     <li><a href="#interface-domimplementation"><span class="secno">4.5.1 </span>Интерфейс <code>DOMImplementation</code></a></ol></li>
   <li><a href="#interface-documentfragment"><span class="secno">4.6 </span>Интерфейс <code>DocumentFragment</code></a></li>
   <li><a href="#interface-documenttype"><span class="secno">4.7 </span>Интерфейс <code>DocumentType</code></a></li>
   <li><a href="#interface-element"><span class="secno">4.8 </span>Интерфейс <code>Element</code></a>
    <ol>
     <li><a href="#interface-attr"><span class="secno">4.8.1 </span>Интерфейс <code>Attr</code></a></ol></li>
   <li><a href="#interface-characterdata"><span class="secno">4.9 </span>Интерфейс <code>CharacterData</code></a></li>
   <li><a href="#interface-text"><span class="secno">4.10 </span>Интерфейс <code>Text</code></a></li>
   <li><a href="#interface-processinginstruction"><span class="secno">4.11 </span>Интерфейс <code>ProcessingInstruction</code></a></li>
   <li><a href="#interface-comment"><span class="secno">4.12 </span>Интерфейс <code>Comment</code></a></ol></li>
 <li><a href="#ranges"><span class="secno">5 </span>Диапазоны</a>
  <ol>
   <li><a href="#introduction-to-dom-ranges"><span class="secno">5.1 </span>Введение в "DOM Ranges"</a></li>
   <li><a href="#interface-range"><span class="secno">5.2 </span>Интерфейс <code>Range</code></a></ol></li>
 <li><a href="#traversal"><span class="secno">6 </span>Обход</a>
  <ol>
   <li><a href="#interface-nodeiterator"><span class="secno">6.1 </span>Интерфейс <code>NodeIterator</code></a></li>
   <li><a href="#interface-treewalker"><span class="secno">6.2 </span>Интерфейс <code>TreeWalker</code></a></li>
   <li><a href="#interface-nodefilter"><span class="secno">6.3 </span>Интерфейс <code>NodeFilter</code></a></ol></li>
 <li><a href="#sets"><span class="secno">7 </span>Множества</a>
  <ol>
   <li><a href="#interface-domtokenlist"><span class="secno">7.1 </span>Интерфейс <code>DOMTokenList</code></a></li>
   <li><a href="#interface-domsettabletokenlist"><span class="secno">7.2 </span>Интерфейс <code>DOMSettableTokenList</code></a></ol></li>
 <li><a href="#historical"><span class="secno">8 </span>История</a>
  <ol>
   <li><a href="#dom-events"><span class="secno">8.1 </span>DOM События</a></li>
   <li><a href="#dom-core"><span class="secno">8.2 </span>DOM Ядро</a></li>
   <li><a href="#dom-ranges"><span class="secno">8.3 </span>DOM Диапазоны</a></li>
   <li><a href="#dom-traversal"><span class="secno">8.4 </span>DOM Обход</a></ol></li>
 <li><a href="#errors"><span class="secno">А </span> Исключения и ошибки</a>
  <ol>
   <li><a href="#exceptions"><span class="secno">А.1 </span>Исключения</a></li>
   <li><a href="#sec-domerror"><span class="secno">А.2 </span>Интерфейс <code>DOMError</code></a></li>
   <li><a href="#error-names-0"><span class="secno">А.3 </span>Имена ошибок</a></ol></li>
 <li><a href="#css-concepts"><span class="secno">Б </span>Концепты CSS</a>
 <li><a class="no-num" href="#references">Ссылки</a></li>
 <li><a class="no-num" href="#acknowledgments">Благодарности</a></ol>
<!--end-toc-->



<h2 class="no-num" id="goals">Цели</h2>

<p>Эта спецификация стандартизирует DOM. Она делает это следующим образом:</p>

<ol>
 <li>
  <p>Объединяя <cite>Ядро DOM Level 3</cite>
  <a class="informative" href="#biblio-DOM3CORE">[DOM3CORE]</a>,
  <cite>Обход элементов</cite>
  <a class="informative" href="#biblio-ELEMENTTRAVERSAL">[ELEMENTTRAVERSAL]</a>,
  <cite>Selectors API Level 2</cite>
  <a class="informative" href="#biblio-SELECTORSAPI">[SELECTORSAPI]</a>, главы
  "Архитектура Событий DOM" и "Базовые Интерфейсы Событий"
  <cite>UI Events</cite>
  <a class="informative" href="#biblio-UIEVENTS">[UIEVENTS]</a> (конкретный тип событий не входящий в Стандарт DOM),
  <cite>Обход и Диапазон DOM Level 2</cite>
  <a class="informative" href="#biblio-DOM2TR">[DOM2TR]</a>, и:

  <ul>
   <li>Согласовывая их с экосистемой JavaScript где это возможно.
   <li>Согласовывая их с существующей реализацией.
   <li>Упрощая их насколько это возможно.
  </ul>

 <li><p>Перемещая возможности из Стандарта HTML <a href="#biblio-HTML">[HTML]</a>, которые имеют больше смысла быть частью Стандарта DOM.

 <li>
  <p>Определяя замену для глав "Mutation Events" и
  "Mutation Name Event Types" <cite>Спецификации UI Events (бывшая DOM Level 3 Events)</cite>
  <a class="informative" href="#biblio-UIEVENTS">[UIEVENTS]</a> так как старая модель была проблемной.

  <p class="note">Заметка: Старая модель, как ожидается, будет удалена из реализаций в установленном порядке.

 <li><p>Определяя новые возможности, которые упрощают частые операции DOM.
</ol>



<h2 id="conformance"><span class="secno">1 </span>Соответствие</h2>
<p>Все диаграммы, примеры и заметки в этой спецификации не являются нормативными, как и все разделы явно помеченные не-нормативными.
Все остальное в данной спецификации является нормативным.

<p>Ключевые слова "MUST" (должен), "MUST NOT" (не должен), "REQUIRED" (обязан), "SHALL", "SHALL NOT",
"SHOULD" (следует), "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY" (может) и
"OPTIONAL" (опционально) в этом документе должны интерпретироваться как описано в RFC 2119.
Для читабельности, эти слова не появляются капсом в этой спецификации. <a href="#biblio-RFC2119">[RFC2119]</a>

<p>Требования сформулированные в императиве как часть алгоритмов
(такие как "сократить пробелы в начале" or "возвратить false и прекратить шаги") должны интерпретироваться со значением
ключевого слова ("должен", "следует", "может" и т.д.) использованного в представлении алгоритма.

<p>Требования соответствия выраженные в виде алгоритмов или конкретных шагов
могут быть реализованы любым способом, до тех пор пока конечный результат эквивалентен. (В частности, алгоритмы определенные в этой спецификации направлены на то чтобы им было легко следовать, и не предназначены чтобы быть производительными.)

<p id="hardwareLimitations">Агенты пользователей могут устанавливать лимиты специфические для реализаций,
например для предотвращения атак отказа в обслуживании, для защиты от нехватки памяти, или работать в пределах специфических для платформы лимитов.

<p>Когда метод или атрибут говорить вызвать другой метод или атрибут, агент пользователя должен вызвать внутренний API для этого атрибута или метода, так что, например, автор не может изменить поведение путем переопределения атрибутов или методов с кастомными свойствами или функциями в JavaScript.

<p>Если не указано иное, сравнение строк выполняется <a href="#case-sensitive">регистрозависимым</a> образом.

<h3 id="dependencies"><span class="secno">1.1 </span>Зависимости</h3>

<p>Фрагменты IDL в этой спецификации должны интерпретироваться как обязаны для соответствия IDL фрагментам, как описано в спецификации Web IDL. <a href="#biblio-WEBIDL">[WEBIDL]</a>

<p>Некоторые из терминов использованных в этой спецификации определены в
<cite>Encoding</cite>, <cite>Selectors</cite>, <cite>Web IDL</cite>, <cite>XML</cite> и
<cite>Namespaces in XML</cite>.
<a href="#biblio-ENCODING">[ENCODING]</a>
<a href="#biblio-SELECTORS">[SELECTORS]</a>
<a href="#biblio-WEBIDL">[WEBIDL]</a>
<a href="#biblio-XML">[XML]</a>
<a href="#biblio-XMLNS">[XMLNS]</a>

<h3 id="extensibility"><span class="secno">1.2 </span>Расширяемость</h3>

<p>Специфические пропиетарные расширения к этой спецификации настоятельно не рекомендуются. Авторы не должны использовать такие расширения, так как это уменьшает совместимость и уменьшает охват пользователей,
позволяя только пользователям со специфическими пользовательскими агентами иметь доступ к такому контенту.

<p>Когда расширения нужны, Стандарт DOM может быть обновлен соответствующим образом, или написан новый стандарт, который охватывает возможности предусмотренных расширений для <dfn data-dfn-type="dfn" data-export="" data-lt="other applicable specifications" id="other-applicable-specifications">применимых спецификаций<a class="self-link" href="#other-applicable-specifications"></a></dfn>.</p>

<h2 id="terminology"><span class="secno">2 </span>Терминология</h2>

<p>Термин <dfn id="context-object">объект контекста</dfn> означает объект на котором алгоритм,
атрибут получения, атрибут присвоения или обсуждаемый метод был вызван. Когда
<a href="#context-object">объект контекста</a> однозначен, этот термин может быть опущен.

<!-- XXX we should prolly explain that "set attribute X to Y" works even for
readonly attributes when it is language for implementors -->

<h3 id="trees"><span class="secno">2.1 </span>Деревья</h3> <!-- Sorry reddit, this is not /r/trees -->

<p><dfn id="concept-tree" title="concept-tree">Дерево</dfn> это конечная иерархическая древовидная структура.
<dfn id="concept-tree-order" title="concept-tree-order">Порядок дерева</dfn> это порядковый, выполняемый с начала
обход <a href="#concept-tree" title="concept-tree">дерева</a>.
<!-- http://en.wikipedia.org/wiki/Tree_traversal#Depth-first_Traversal -->

<p>Объект который <dfn id="concept-tree-participate" title="concept-tree-participate">участвует</dfn> в <a href="#concept-tree" title="concept-tree">дереве</a> имеет
<dfn id="concept-tree-parent" title="concept-tree-parent">родителя</dfn>, который является другим объектом либо null, и упорядоченный список из нуля или более
<dfn id="concept-tree-child" title="concept-tree-child">дочерних</dfn> объектов. Объект <var>A</var>, чей
<a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> это объект <var>B</var>, является
<a href="#concept-tree-child" title="concept-tree-child">дочерним</a> от <var>B</var>.

<p><dfn id="concept-tree-root" title="concept-tree-root">Корень</dfn> объекта это он сам, если его
<a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> это null, или если же им является
<a href="#concept-tree-root" title="concept-tree-root">корень</a> его
<a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

<p>Объект <var>A</var> называется
<dfn id="concept-tree-descendant" title="concept-tree-descendant">потомком</dfn> объекта
<var>B</var>, если <var>A</var> является
<a href="#concept-tree-child" title="concept-tree-child">дочерним</a> от <var>B</var> или
<var>A</var> является <a href="#concept-tree-child" title="concept-tree-child">дочерним</a> объекта <var>C</var>, который
<a href="#concept-tree-descendant" title="concept-tree-descendant">наследник</a> от <var>B</var>.

<p>
<dfn id="concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">Включительный потомок</dfn> это сам объект или один из его
<a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>.

<p>Объект <var>A</var> называется
<dfn id="concept-tree-ancestor" title="concept-tree-ancestor">предком</dfn> объекта
<var>B</var> только если <var>B</var> является
<a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a> от
<var>A</var>.

<p><dfn id="concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">Включительный предок</dfn> это сам объект или один из его <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предков</a>.

<p>Объект <var>A</var> называется
<dfn id="concept-tree-sibling" title="concept-tree-sibling">сестринским</dfn> объекта
<var>B</var> только если <var>B</var> и <var>A</var>
имеют одного не-null <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

<p>Объект <var>A</var> является
<dfn id="concept-tree-preceding" title="concept-tree-preceding">предшествующим</dfn> объекту
<var>B</var> если <var>A</var> и <var>B</var> в одном <a href="#concept-tree" title="concept-tree">дереве</a> и <var>A</var> идет перед <var>B</var> в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

<p>Объект <var>A</var> является
<dfn id="concept-tree-following" title="concept-tree-following">следующим</dfn> объекту
<var>B</var> если <var>A</var> и <var>B</var> в одном <a href="#concept-tree" title="concept-tree">дереве</a> и <var>A</var> идет после <var>B</var> в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

<p><dfn id="concept-tree-first-child" title="concept-tree-first-child">Первый дочерний</dfn> объекта это его <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> или null, если он не имеет
<a href="#concept-tree-child" title="concept-tree-child">дочерних</a>.

<p><dfn id="concept-tree-last-child" title="concept-tree-last-child">Последний дочерний</dfn> объекта это его <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> или null, если он не имеет
<a href="#concept-tree-child" title="concept-tree-child">дочерних</a>.

<p><dfn id="concept-tree-previous-sibling" title="concept-tree-previous-sibling">Предыдущий сестринский</dfn> объекта это его <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующий</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a> или null, если он не имеет
<a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующего</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринского</a>.

<p><dfn id="concept-tree-next-sibling" title="concept-tree-next-sibling">Следующий сестринский</dfn> объекта это его <a href="#concept-tree-following" title="concept-tree-following">следующий</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a> или null, если объект не имеет
<a href="#concept-tree-following" title="concept-tree-following">следующего</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринского</a>.

<p><dfn id="concept-tree-index" title="concept-tree-index">Индекс</dfn> объекта это количество его <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующих</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринских</a>.


<h3 id="strings"><span class="secno">2.2 </span>Строки</h3>
<p>Сравнение двух строк <dfn id="case-sensitive">регистрозависимым</dfn> образом означает точное их сравнение, символ кода к символу кода.

<p>Сравнение двух строк <dfn id="ascii-case-insensitive">ASCII регистрозависимым</dfn> образом означает точное их сравнение, символ кода к символу кода, кроме того что символы в диапазоне от U+0041 до U+005A (т.е. от латинской заглавной A к латинской заглавной Z), включительно, и соответствующие символы в диапазоне от U+0061 до U+007A (т.е. от латинской маленькой A до латинской маленькой Z), включительно, считаются также соответствующими.

<p><dfn id="converted-to-ascii-uppercase" title="converted to ascii uppercase">Конвертация строки к ASCII заглавным</dfn> означает замену всех символов в диапазоне от U+0061 до U+007A (т.е. от латинской маленькой A до латинской маленькой Z), включительно, на соответствующие символы в диапазоне от U+0041 до U+005A (т.е. от латинской заглавной A до латинской заглавной Z).

<p><dfn id="converted-to-ascii-lowercase" title="converted to ascii lowercase">Конвертация строки к ASCII строчным</dfn> означает замену всех символов в диапазоне от U+0041 до U+005A (т.е. от латинской заглавной A до латинской заглавной Z), включительно, на соответствующие символы от U+0061 до U+007A (т.е. от латинской маленькой A до латинской маленькой Z).

<p><var>Паттерн</var> строки это <dfn id="prefix-match">prefix match</dfn> для строки
<var>s</var>, когда <var>паттерн</var> не длиннее чем
<var>s</var> и отбрасывая <var>s</var> к длине
<var>паттерна</var>, оставляя две строки как совпадающие друг с другом.

<h3 id="ordered-sets"><span class="secno">2.3 </span>Упорядоченные множества</h3>

<p><dfn id="concept-ordered-set-parser" title="concept-ordered-set-parser">Парсер упорядоченных множеств</dfn> принимает строку
<var>input</var> и затем выполняет следующие шаги:

<ol>
 <li><p>Сделать <var>position</var> указателем на <var>input</var>,
 изначально указывающим на начало строки.

 <li><p>Сделать <var>tokens</var> упорядоченным множеством токенов, изначально пустым.

 <li><p><a href="#skip-ascii-whitespace">Пропустить ASCII пробелы</a>.

 <li><p>Пока <var>position</var> еще не после конца
 <var>input</var>:

  <ol>
   <li><p><a href="#collect-a-code-point-sequence">Собрать последовательность кодовых точек</a> из кодовых точек, которые
   не являются <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелами</a>.

   <li><p>Если собранная строка не является <var>tokens</var>, добавить собранную строку к <var>tokens</var>.

   <li><p><a href="#skip-ascii-whitespace">Пропустить ASCII пробелы</a>.
  </ol>

 <li><p>Возвратить <var>tokens</var>.
</ol>

<p>Чтобы <dfn id="collect-a-code-point-sequence">собрать последовательность кодовых точек</dfn> из
<var>code points</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>input</var> и <var>position</var> теми же переменными как те с именем которых алгоритм вызвал эти шаги.

 <li><p>Сделать <var>result</var> пустой строкой.

 <li><p>Пока <var>position</var> не показывает на конец от
 <var>input</var> и точка кода на <var>position</var> одна из <var>code points</var>, добавить эту точку кода в конец
 <var>result</var> и предыдущую <var>position</var> к следующей точке кода в <var>input</var>.

 <li><p>Возвратить <var>result</var>.
</ol>

<p><dfn id="skip-ascii-whitespace">Пропустить ASCII пробелы</dfn> означает
<a href="#collect-a-code-point-sequence">собрать последовательность кодовых точек</a>
<a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелов</a> и отбросить возвращаемое значение.

<p><dfn id="concept-ordered-set-serializer" title="concept-ordered-set-serializer">Сериализатор упорядоченных множеств</dfn> принимает
<var>set</var> и возвращает конкатенацию строк в
<var>set</var>, отделенных друг от друга с помощью U+0020.


<h3 id="namespaces"><span class="secno">2.4 </span>Пространства имен</h3>
<p><dfn id="html-namespace">HTML пространство имен</dfn> это
<code>http://www.w3.org/1999/xhtml</code>.

<p><dfn id="xml-namespace">XML пространство имен</dfn> это
<code>http://www.w3.org/XML/1998/namespace</code>.

<p><dfn id="xmlns-namespace">XMLNS пространство имен</dfn> это
<code>http://www.w3.org/2000/xmlns/</code>.


<h2 id="events"><span class="secno">3 </span>События</h2>

<h3 id="introduction-to-dom-events"><span class="secno">3.1 </span>Введение в "DOM Events"</h3>

<p>Во всех веб-платформах <a href="#concept-event" title="concept-event">события</a>
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправляются</a> к объектам чтобы сигнализировать
возникновения, такие как активность сети или взаимодействие пользователя. Эти объекты
реализуют интерфейс <code><a href="#eventtarget">EventTarget</a></code> и таким образом добавляют
<a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> для наблюдения
<a href="#concept-event" title="concept-event">событий</a> вызовом <a href="#dom-eventtarget-addeventlistener">addEventListener()</a>:

<pre><code>obj.addEventListener("load", imgFetched)

function imgFetched(ev) {
  // успех
  …
}</code></pre>

<p><a href="#concept-event-listener" title="concept-event-listener">Слушатели событий</a> могут быть удалены путем использования метода
<code title="dom-EventTarget-removeEventListener"><a href="#dom-eventtarget-removeeventlistener">removeEventListener()</a></code>, передающего те же аргументы.

<p><a href="#concept-event" title="concept-event">События</a> также являются объектами и реализуют интерфейс
<code><a href="#event">Event</a></code> (или производный интерфейс). В примере выше
<var>ev</var> является <a href="#concept-event" title="concept-event">событием</a>. Он передается как аргумент к <b>приемнику</b> (callback)
<a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a>
(обычно это функция JavaScript, как показано выше).
Ключ <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a> от
<code title="dom-Event-type"><a href="#dom-event-type">type</a></code> <a href="#concept-event" title="concept-event">события</a>
 значения атрибута
("<code>load</code>" в примере выше). <code title="dom-Event-target"><a href="#dom-event-target">Target</a></code>
значения атрибута <a href="#concept-event" title="concept-event">события</a>
 возвращает объект к которому <a href="#concept-event" title="concept-event">событие</a> было
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> (<var>obj</var>
в примере выше).

<p>В то время как обычно <a href="#concept-event" title="concept-event">события</a>
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправляются</a> пользовательским агентом в
результате взаимодействия пользователя или окончания некоторого задания, приложения могут <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлять</a>
<a href="#concept-event" title="concept-event">события</a> самостоятельно, широко известные как синтетические события:

<pre><code>// добавить соответствующий слушатель событий
obj.addEventListener("cat", function(e) { process(e.detail) })

// создать и отправить событие
var event = new CustomEvent("cat", {"detail":{"hazcheeseburger":true}})
obj.dispatchEvent(event)</code></pre>

<p>Кроме сигнализирования, <a href="#concept-event" title="concept-event">события</a> также иногда используются чтобы дать приложению контроль над тем что происходит дальше в операции. Например как часть отправки формы,
<a href="#concept-event" title="concept-event">событие</a>, чье значение атрибута
<code title="dom-Event-type"><a href="#dom-event-type">type</a></code> равняется
"<code>submit</code>", является
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправленным</a>. Если метод <code title="dom-Event-preventDefault"><a href="#dom-event-preventdefault">preventDefault()</a></code> этого
<a href="#concept-event" title="concept-event">события</a>
 вызван, отправка формы будет прервана. Приложения, которые хотят использовать эту функциональность через <a href="#concept-event" title="concept-event">события</a>,
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправляемые</a> приложением
(синтетические события) могут использовать возвращаемое значение метода
<code title="dom-EventTarget-dispatchEvent"><a href="#dom-eventtarget-dispatchevent">dispatchEvent()</a></code>:

<pre><code>if(obj.dispatchEvent(event)) {
  // событие не было отменено, время для магии
  …
}</code></pre>

<p>Когда <a href="#concept-event" title="concept-event">событие</a>
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправляется</a> на объект, который
<a href="#concept-tree-participate" title="concept-tree-participate">участвует</a> в
<a href="#concept-tree" title="concept-tree">дереве</a> (например
<a href="#concept-element" title="concept-element">элемент</a>), оно может достигать также
<a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> на
<a href="#concept-tree-ancestor" title="concept-tree-ancestor">предках</a> объекта. Сначала все
<a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предка</a>, чья переменная <b>capture</b> установлена на true и вызвана, в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>. Затем, собственные
<a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> объекта вызываются. И наконец, если только значение атрибута <a href="#dom-event-bubbles" title="dom-Event-bubbles">bubbles</a> <a href="#concept-event" title="concept-event">события</a> является true, <a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предка</a> объекта вызываются заново,
но теперь в обратном <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

<p>Давайте взглянем на пример того как <a href="#concept-event" title="concept-event">события</a> работают в <a href="#concept-tree" title="concept-tree">дереве</a>:

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Boring example&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;Hello &lt;span id=x&gt;world&lt;/span&gt;!&lt;/p&gt;
  &lt;script&gt;
   function test(e) {
     debug(e.target, e.currentTarget, e.eventPhase)
   }
   document.addEventListener("hey", test, true)
   document.body.addEventListener("hey", test)
   var ev = new Event("hey", {bubbles:true})
   document.getElementById("x").dispatchEvent(ev)
  &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Функция <code>debug</code> будет вызвана дважды. Каждый раз значение атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code> <a href="#concept-event" title="concept-event">события</a> будет
<code>span</code> <a href="#concept-element" title="concept-element">элементом</a>. В первый раз значение атрибута <code title="dom-Event-currenttarget"><a href="#dom-event-target">currentTarget</a></code> будет <a href="#concept-document" title="concept-document">document</a>, второй раз — <code>body</code> <a href="#concept-element" title="concept-element">элементом</a>. Значение атрибута
<code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code> переключается с <code title="dom-Event-CAPTURING_PHASE"><a href="#dom-event-capturing_phase">CAPTURING_PHASE</a></code>
на <code title="dom-Event-BUBBLING_PHASE"><a href="#dom-event-bubbling_phase">BUBBLING_PHASE</a></code>. Если бы
<a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a> был зарегистрирован для <code>span</code> <a href="#concept-element" title="concept-element">элемента</a>, то значение атрибута
<code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code> было бы <code title="dom-Event-AT_TARGET"><a href="#dom-event-at_target">AT_TARGET</a></code>.


<h3 id="interface-event"><span class="secno">3.2 </span>Интерфейс <code><a href="#event">Event</a></code></h3>

<pre class="idl">[<a href="#concept-event-constructor" title="concept-event-constructor">Constructor</a>(DOMString <var>type</var>, optional <a href="#eventinit">EventInit</a> <var>eventInitDict</var>),
 Exposed=(Window,Worker)]
interface <dfn id="event">Event</dfn> {
  readonly attribute DOMString <a href="#dom-event-type" title="dom-Event-type">type</a>;
  readonly attribute <a href="#eventtarget">EventTarget</a>? <a href="#dom-event-target" title="dom-Event-target">target</a>;
  readonly attribute <a href="#eventtarget">EventTarget</a>? <a href="#dom-event-currenttarget" title="dom-Event-currentTarget">currentTarget</a>;

  const unsigned short <a href="#dom-event-none" title="dom-Event-NONE">NONE</a> = 0;
  const unsigned short <a href="#dom-event-capturing_phase" title="dom-Event-CAPTURING_PHASE">CAPTURING_PHASE</a> = 1;
  const unsigned short <a href="#dom-event-at_target" title="dom-Event-AT_TARGET">AT_TARGET</a> = 2;
  const unsigned short <a href="#dom-event-bubbling_phase" title="dom-Event-BUBBLING_PHASE">BUBBLING_PHASE</a> = 3;
  readonly attribute unsigned short <a href="#dom-event-eventphase" title="dom-Event-eventPhase">eventPhase</a>;

  void <a href="#dom-event-stoppropagation" title="dom-Event-stopPropagation">stopPropagation</a>();
  void <a href="#dom-event-stopimmediatepropagation" title="dom-Event-stopImmediatePropagation">stopImmediatePropagation</a>();

  readonly attribute boolean <a href="#dom-event-bubbles" title="dom-Event-bubbles">bubbles</a>;
  readonly attribute boolean <a href="#dom-event-cancelable" title="dom-Event-cancelable">cancelable</a>;
  void <a href="#dom-event-preventdefault" title="dom-Event-preventDefault">preventDefault</a>();
  readonly attribute boolean <a href="#dom-event-defaultprevented" title="dom-Event-defaultPrevented">defaultPrevented</a>;

  [Unforgeable] readonly attribute boolean <a href="#dom-event-istrusted" title="dom-Event-isTrusted">isTrusted</a>;
  readonly attribute DOMTimeStamp <a href="#dom-event-timestamp" title="dom-Event-timeStamp">timeStamp</a>;

  void <a href="#dom-event-initevent" title="dom-Event-initEvent">initEvent</a>(DOMString <var>type</var>, boolean <var>bubbles</var>, boolean <var>cancelable</var>);
};

dictionary <dfn id="eventinit">EventInit</dfn> {
  boolean <span title="dom-EventInit-bubbles">bubbles</span> = false;
  boolean <span title="dom-EventInit-cancelable">cancelable</span> = false;
};</pre>

<p><dfn id="concept-event" title="concept-event">Событие</dfn> позволяет сигнализировать, что что-то произошло. Например то, что картинка полностью загрузилась. Это представлено в интерфейсе <code><a href="#event">Event</a></code> или в интерфейсе, который наследует <code><a href="#event">Event</a></code> интерфейс.</p>

<dl class="domintro">
 <dt><code><var>event</var> = new <a href="#concept-event-constructor" title="concept-event-constructor">Event</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd><p>Возвращает новое <var>событие</var> чье значение атрибута
 <code title="dom-Event-type"><a href="#dom-event-type">type</a></code> установлено к
 <var>type</var>. Опциональный аргумент <var>eventInitDict</var> позволяет устанавливать атрибуты <code title="dom-Event-bubbles"><a href="#dom-event-bubbles">bubbles</a></code> и <code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code> через члены объекта того же имени.

 <dt><code><var>event</var> . <a href="#dom-event-type" title="dom-Event-type">type</a></code>
 <dd><p>Возвращает тип <var>события</var>, например
 "<code>click</code>", "<code>hashchange</code>" или
 "<code>submit</code>".

 <dt><code><var>event</var> . <a href="#dom-event-target" title="dom-Event-target">target</a></code>
 <dd><p>Возвращает объект к которому <var>событие</var> <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a>.

 <dt><code><var>event</var> . <a href="#dom-event-currenttarget" title="dom-Event-currentTarget">currentTarget</a></code>
 <dd><p>Возвращает объект чей <b>приемник</b> (callback) <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a> в настоящее время вызывается.

 <dt><code><var>event</var> . <a href="#dom-event-eventphase" title="dom-Event-eventPhase">eventPhase</a></code>
 <dd><p>Возвращает фазу <a href="#concept-event" title="concept-event">события</a>, которая является одной из <code title="dom-Event-NONE"><a href="#dom-event-none">NONE</a></code>,
 <code title="dom-Event-CAPTURING_PHASE"><a href="#dom-event-capturing_phase">CAPTURING_PHASE</a></code>,
 <code title="dom-Event-AT_TARGET"><a href="#dom-event-at_target">AT_TARGET</a></code> и
 <code title="dom-Event-BUBBLING_PHASE"><a href="#dom-event-bubbling_phase">BUBBLING_PHASE</a></code>.

 <dt><code><var>event</var> . <a href="#dom-event-stoppropagation" title="dom-Event-stopPropagation">stopPropagation</a>()</code>
 <dd><p>Когда <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> в
 <a href="#concept-tree" title="concept-tree">дерево</a>, вызов этого метода предотвращает
 <var>событие</var> от достижения других объектов кроме текущего объекта.

 <dt><code><var>event</var> . <a href="#dom-event-stopimmediatepropagation" title="dom-Event-stopImmediatePropagation">stopImmediatePropagation</a>()</code>
 <dd><p>Вызов этого метода предотвращает <var>событие</var> от достижения любых зарегистрированных <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> после того как текущий завершает обход, когда
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправляется</a> в
 <a href="#concept-tree" title="concept-tree">дерево</a>, также предотвращает <var>событие</var> от достижения других объектов.

 <dt><code><var>event</var> . <a href="#dom-event-bubbles" title="dom-Event-bubbles">bubbles</a></code>
 <dd><p>Возвращает true или false в зависимости от того как событие было инициализировано. True если <var>событие</var> проходит через значение атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code> <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предков</a> в обратном <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, и false в другом случае.

 <dt><code><var>event</var> . <a href="#dom-event-cancelable" title="dom-Event-cancelable">cancelable</a></code>
 <dd><p>Возвращает true или false в зависимости от того как <var>событие</var> было инициализировано. Его возвращаемое значение не всегда несет смысл, но true может указывать что часть операции в течение которой <var>событие</var> было
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a>, может быть отменено вызовом метода <code title="dom-Event-preventDefault"><a href="#dom-event-preventdefault">preventDefault()</a></code>.

 <dt><code><var>event</var> . <a href="#dom-event-preventdefault" title="dom-Event-preventDefault">preventDefault</a>()</code>
 <dd><p>Если вызвано когда значение атрибута
 <code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code> является true,
 сигнализирует что операция вызвавшая <a href="#concept-event-dispatch" title="concept-event-dispatch">отправку</a> <var>события</var> должна быть отменена.

 <dt><code><var>event</var> . <a href="#dom-event-defaultprevented" title="dom-Event-defaultPrevented">defaultPrevented</a></code>
 <dd><p>Возвращает true если
 <code title="dom-Event-preventDefault"><a href="#dom-event-preventdefault">preventDefault()</a></code> был вызван во время значения атрибута <code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code> true, и false в другом случае.

 <dt><code><var>event</var> . <a href="#dom-event-istrusted" title="dom-Event-isTrusted">isTrusted</a></code>
 <dd><p>Возвращает true если <var>событие</var> было
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> агентом пользователя, и false в другом случае.

 <dt><code><var>event</var> . <a href="#dom-event-timestamp" title="dom-Event-timeStamp">timeStamp</a></code>
 <dd><p>Возвращает время создания <var>события</var> в виде количества
 миллисекунд прошедших с 00:00:00 UTC, 1 января 1970.

 <!-- initEvent is dead -->
</dl>

<p>Атрибут <dfn id="dom-event-type" title="dom-Event-type"><code>type</code></dfn> должен возвратить значение с которым он был инициализирован. Когда
<a href="#concept-event" title="concept-event">событие</a> создано, атрибут должен быть
инициализирован к пустой строке.

<p>Атрибуты <dfn id="dom-event-target" title="dom-Event-target"><code>target</code></dfn> и
<dfn id="dom-event-currenttarget" title="dom-Event-currentTarget"><code>currentTarget</code></dfn>
должны возвратить значение с которыми они были инициализированы. Когда
<a href="#concept-event" title="concept-event">событие</a> создано, атрибуты должны быть инициализированы к null.

<p>Атрибут <dfn id="dom-event-eventphase" title="dom-Event-eventPhase"><code>eventPhase</code></dfn>
должен возвратить значение с которым он был инициализирован, которое должно быть одним из следующих:</p>
<dl>
 <dt><dfn id="dom-event-none" title="dom-Event-NONE"><code>NONE</code></dfn> (числовое значение 0)
 <dd><p><a href="#concept-event" title="concept-event">События</a> на данный момент не
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлены</a> в этой фазе.
 <dt><dfn id="dom-event-capturing_phase" title="dom-Event-CAPTURING_PHASE"><code>CAPTURING_PHASE</code></dfn> (числовое значение 1)</dt>
 <dd><p>Когда <a href="#concept-event" title="concept-event">событие</a>
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> к объекту который
 <a href="#concept-tree-participate" title="concept-tree-participate">участвует</a> в
 <a href="#concept-tree" title="concept-tree">дереве</a>, оно будет в этой фазе перед тем как
 достигнет своего значения атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code>.
 <dt><dfn id="dom-event-at_target" title="dom-Event-AT_TARGET"><code>AT_TARGET</code></dfn> (числовое значение 2)
 <dd><p>Когда <a href="#concept-event" title="concept-event">событие</a>
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a>, оно будет в этой фазе
 на своем значении атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code>.
 <dt><dfn id="dom-event-bubbling_phase" title="dom-Event-BUBBLING_PHASE"><code>BUBBLING_PHASE</code></dfn> (числовое значение 3)
 <dd><p>Когда <a href="#concept-event" title="concept-event">событие</a>
 <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> к объекту который
 <a href="#concept-tree-participate" title="concept-tree-participate">участвует</a> в
 <a href="#concept-tree" title="concept-tree">дереве</a>, оно будет в этой фазе после того
 как достигнет своего значения атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code>.
</dl>
<p>Изначально атрибут должен быть инициализирован к значению
<code title="dom-Event-NONE"><a href="#dom-event-none">NONE</a></code>.

<hr>

<p>Каждое <a href="#concept-event" title="concept-event">событие</a> имеет следующие ассоциированные с ним
флаги, которые изначально сняты:</p>
<ul>
 <li><dfn id="stop-propagation-flag">флаг остановки распространения</dfn>
 <li><dfn id="stop-immediate-propagation-flag">флаг остановки немедленного распространения</dfn>
 <li><dfn id="canceled-flag">флаг отмены</dfn>
 <li><dfn id="initialized-flag">флаг инициализации</dfn>
 <li><dfn id="dispatch-flag">флаг отправки</dfn>
</ul>

<p>Метод
<dfn id="dom-event-stoppropagation" title="dom-Event-stopPropagation"><code>stopPropagation()</code></dfn>
должен устанавливать <a href="#stop-propagation-flag">флаг остановки распространения</a>.

<p>Метод
<dfn id="dom-event-stopimmediatepropagation" title="dom-Event-stopImmediatePropagation"><code>stopImmediatePropagation()</code></dfn>
должен устанавливать <a href="#stop-propagation-flag">флаг остановки распространения</a> и
<a href="#stop-immediate-propagation-flag">флаг остановки немедленного распространения</a>.

<p>Атрибуты <dfn id="dom-event-bubbles" title="dom-Event-bubbles"><code>bubbles</code></dfn> и
<dfn id="dom-event-cancelable" title="dom-Event-cancelable"><code>cancelable</code></dfn> должны возвращать значения к которым они были инициализированы.

<p>Метод
<dfn id="dom-event-preventdefault" title="dom-Event-preventDefault"><code>preventDefault()</code></dfn>
должен устанавливать <a href="#canceled-flag">флаг отмены</a> если значение атрибута
<code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code> является true.

<p>Атрибут
<dfn id="dom-event-defaultprevented" title="dom-Event-defaultPrevented"><code>defaultPrevented</code></dfn>
должен возвращать true если <a href="#canceled-flag">флаг отмены</a> установлен, и
false в другом случае.

<hr>

<p>Атрибут <dfn id="dom-event-istrusted" title="dom-Event-isTrusted"><code>isTrusted</code></dfn> должен возвращать значение к которому был инициализирован. Когда
<a href="#concept-event" title="concept-event">событие</a> создано, атрибут должен быть инициализирован к false.

<p>Атрибут <dfn id="dom-event-timestamp" title="dom-Event-timeStamp"><code>timeStamp</code></dfn>
должен возвращать значение к которому был установлен. Когда
<a href="#concept-event" title="concept-event">событие</a> создано, атрибут должен быть
установлен к количеству миллисекунд которые прошли с
00:00:00 UTC, 1 января 1970, игнорируя високосные секунды.
<!-- leap seconds are ignored by JavaScript too -->

<hr>

<p>Чтобы <dfn id="concept-event-initialize" title="concept-event-initialize">инициализировать</dfn>
<var>событие</var> с <var>type</var>,
<var>bubbles</var> и <var>cancelable</var>, выполнить следующие шаги:

<ol>
 <li><p>Установить <a href="#initialized-flag">флаг инициализации</a>.
 <li><p>Снять <a href="#stop-propagation-flag">флаг остановки распространения</a>,
 <a href="#stop-immediate-propagation-flag">флаг остановки немедленного распространения распространения</a> и
 <a href="#canceled-flag">флаг отмены</a>.
 <li><p>Установить атрибут <code title="dom-Event-isTrusted"><a href="#dom-event-istrusted">isTrusted</a></code> к false.
 <li><p>Установить атрибут <code title="dom-Event-target"><a href="#dom-event-target">target</a></code> к
 null.
 <li><p>Установить атрибут <code title="dom-Event-type"><a href="#dom-event-type">type</a></code> к
 <var>type</var>.
 <li><p>Установить атрибут <code title="dom-Event-bubbles"><a href="#dom-event-bubbles">bubbles</a></code> к
 <var>bubbles</var>.
 <li><p>Установить атрибут <code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code> к <var>cancelable</var>.
</ol>

<p>Метод
<dfn id="dom-event-initevent" title="dom-Event-initEvent"><code>initEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>)</code></dfn>, когда вызван, должен выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#dispatch-flag">флаг отправки</a> <a href="#context-object">объекта контекста</a> установлен, прервать эти шаги.

 <li><p><a href="#concept-event-initialize" title="concept-event-initialize">Инициализировать</a>
 <a href="#context-object">объект контекста</a> с <var>type</var>, <var>bubbles</var> и
 <var>cancelable</var>.
</ol>

<p class="note">Заметка: Так как <a href="#concept-event" title="concept-event">события</a> имеют конструкторы
<code title="dom-Event-initEvent"><a href="#dom-event-initevent">initEvent()</a></code>, это является лишним. Тем не менее,
это должно поддерживаться для наследия.


<h3 id="interface-customevent"><span class="secno">3.3 </span>Интерфейс <code><a href="#customevent">CustomEvent</a></code></h3>

<pre class="idl">[<a href="#concept-event-constructor" title="concept-event-constructor">Constructor</a>(DOMString <var>type</var>, optional <a href="#customeventinit">CustomEventInit</a> <var>eventInitDict</var>),
 Exposed=(Window,Worker)]
interface <dfn id="customevent">CustomEvent</dfn> : <a href="#event">Event</a> {
  readonly attribute any <a href="#dom-customevent-detail" title="dom-CustomEvent-detail">detail</a>;

  void <a href="#dom-customevent-initcustomevent" title="dom-CustomEvent-initCustomEvent">initCustomEvent</a>(DOMString <var>type</var>, boolean <var>bubbles</var>, boolean <var>cancelable</var>, any <var>detail</var>);
};

dictionary <dfn id="customeventinit">CustomEventInit</dfn> : <a href="#eventinit">EventInit</a> {
  any <span title="dom-CustomEventInit-detail">detail</span> = null;
};</pre>

<p><a href="#concept-event" title="concept-event">События</a> с использованием интерфейса
<code><a href="#customevent">CustomEvent</a></code> могут использоваться для кастомных данных.</p>

<dl class="domintro">
 <dt><code><var>event</var> = new <a href="#concept-event-constructor" title="concept-event-constructor">CustomEvent</a>(<var>type</var> [, <var>eventInitDict</var>])</code>
 <dd><p>Работает аналогично конструктору для <code><a href="#event">Event</a></code>, кроме того что
 опциональный аргумент <var>eventInitDict</var> теперь позволяет
 устанавливать атрибут <code title="dom-Event-detail">detail</code> также.

 <dt><code><var>event</var> . <a href="#dom-customevent-detail" title="dom-CustomEvent-detail">detail</a></code>
 <dd><p>Возвращает любые кастомные данные с которыми <var>событие</var> было создано.
 Обычно используется для синтетических событий.

 <!-- initCustomEvent is dead -->
</dl>

<p>Атрибут <dfn id="dom-customevent-detail" title="dom-CustomEvent-detail"><code>detail</code></dfn> должен возвращать значение с которым был инициализирован.

<p>Метод
<dfn id="dom-customevent-initcustomevent" title="dom-CustomEvent-initCustomEvent"><code>initCustomEvent(<var>type</var>, <var>bubbles</var>, <var>cancelable</var>, <var>detail</var>)</code></dfn>
должен, когда вызван, выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#dispatch-flag">флаг отправки</a> <a href="#context-object">контекста события</a> установлен, прервать эти шаги.

 <li><p><a href="#concept-event-initialize" title="concept-event-initialize">Инициализировать</a>
 <a href="#context-object">объект контекста</a> с <var>type</var>, <var>bubbles</var> и
 <var>cancelable</var>.

 <li><p>Установить атрибут <code title="dom-CustomEvent-detail"><a href="#dom-customevent-detail">detail</a></code> <a href="#context-object">объекта контекста</a> к <var>detail</var>.
</ol>


<h3 id="constructing-events"><span class="secno">3.4 </span>Создание событий</h3>

<p>Когда <dfn id="concept-event-constructor" title="concept-event-constructor">конструктор</dfn> интерфейса <code><a href="#event">Event</a></code>, или интерфейс который наследует <code><a href="#event">Event</a></code> интерфейс, вызван, следующие шаги должны быть выполнены:

<ol>
 <li><p>Создать <a href="#concept-event" title="concept-event">событие</a> которое использует интерфейс с которым конструктор был вызван выше.

 <li><p>Установить его <a href="#initialized-flag">флаг инициализации</a>.

 <li><p>Инициализировать атрибут <code title="dom-Event-type"><a href="#dom-event-type">type</a></code> к аргументу <var>type</var>.

 <li><p>Если есть аргумент <var>eventInitDict</var>, то для каждого
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-dictionary-member">члена словаря</a> определенного в нем найти атрибут на <a href="#concept-event" title="concept-event">событии</a>, чей
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-identifier">идентификатор</a> совпадает с ключем
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-dictionary-member">члена словаря</a> и затем установить атрибут к значению этого
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-dictionary-member">члена словаря</a>.

 <li><p>Возвратить <a href="#concept-event" title="concept-event">событие</a>.
</ol>


<h3 id="defining-event-interfaces"><span class="secno">3.5 </span>Определение интерфейсов событий</h3>

<p>В общем, при определении нового интерфейса который наследует
<code><a href="#event">Event</a></code>, пожалуйста, всегда просите обратной связи от WHATWG или почтового архива W3C www-dom@w3.org.

<p>Интерфейс <code><a href="#customevent">CustomEvent</a></code> может использоваться как стартовая точка.
Тем не менее, не вводите каких-либо методов <code>init<var>*</var>Event()</code>, так как они являются избыточными с конструкторами. Интерфейсы которые наследуют
интерфейс <code><a href="#event">Event</a></code>, которые имеют такой метод, имеют его только по историческим причинам.


<h3 id="interface-eventtarget"><span class="secno">3.6 </span>Интерфейс <code><a href="#eventtarget">EventTarget</a></code></h3>

<pre class="idl">[Exposed=(Window,Worker)]
interface <dfn id="eventtarget">EventTarget</dfn> {
  void <a href="#dom-eventtarget-addeventlistener" title="dom-EventTarget-addEventListener">addEventListener</a>(DOMString <var>type</var>, <a href="#eventlistener">EventListener</a>? <var>callback</var>, optional boolean <var>capture</var> = false);
  void <a href="#dom-eventtarget-removeeventlistener" title="dom-EventTarget-removeEventListener">removeEventListener</a>(DOMString <var>type</var>, <a href="#eventlistener">EventListener</a>? <var>callback</var>, optional boolean <var>capture</var> = false);
  boolean <a href="#dom-eventtarget-dispatchevent" title="dom-EventTarget-dispatchEvent">dispatchEvent</a>(<a href="#event">Event</a> <var>event</var>);
};

callback interface <dfn id="eventlistener">EventListener</dfn> {
  void <span title="dom-EventListener-handleEvent">handleEvent</span>(<a href="#event">Event</a> <var>event</var>);
};</pre>

<p><code><a href="#eventtarget">EventTarget</a></code> это объект к которому
<a href="#concept-event" title="concept-event">событие</a>
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправляется</a> когда что-то произошло. Каждый <code><a href="#eventtarget">EventTarget</a></code> имеет связанный с ним список
<a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a>.

<p><dfn id="concept-event-listener" title="concept-event-listener">Слушатель событий</dfn> ассоциирует
callback с определенным <a href="#concept-event" title="concept-event">событием</a>. Каждый
<a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a> содержит
переменные <b>type</b> (<a href="#concept-event" title="concept-event">события</a>),
<b>callback</b> и <b>capture</b>.

<p class="note">Заметка: <b>Callback</b> назван <code><a href="#eventlistener">EventListener</a></code> по историческим причинам. Как видно из определения выше,
<a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a> является более широким концептом.

<dl class="domintro">
 <dt><code><var>target</var> . <a href="#dom-eventtarget-addeventlistener" title="dom-EventTarget-addEventListener">addEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
 <dd>
  <p>Добавляет <a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a>
  для <a href="#concept-event" title="concept-event">событий</a>, чье значение атрибута
  <code title="dom-Event-type"><a href="#dom-event-type">type</a></code> является
  <var>type</var>. Аргумент <var>callback</var> устанавливает
  <b>callback</b>, который будет вызван когда
  <a href="#concept-event" title="concept-event">событие</a>
  <a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a>. Когда установлен к true,
  аргумент <var>capture</var> предотвращает <b>callback</b> от вызова, если
  значение атрибута <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
  <a href="#concept-event" title="concept-event">события</a> равняется
  <code title="dom-Event-BUBBLING_PHASE"><a href="#dom-event-bubbling_phase">BUBBLING_PHASE</a></code>. Когда false, <b>callback</b>
  не будет вызван когда значение атрибута <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
  <a href="#concept-event" title="concept-event">события</a> равняется
  <code title="dom-Event-CAPTURING_PHASE"><a href="#dom-event-capturing_phase">CAPTURING_PHASE</a></code>. Так или иначе,
  <b>callback</b> будет вызван когда значение атрибута <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
  <a href="#concept-event" title="concept-event">события</a> является
  <code title="dom-Event-AT_TARGET"><a href="#dom-event-at_target">AT_TARGET</a></code>.

  <p><a href="#concept-event-listener" title="concept-event-listener">Слушатель событий</a> добавляется к списку <var>target</var>
  <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> и не
  добавляется если это дубликат, т.е. имеет те же значения <b>type</b>, <b>callback</b> и <b>capture</b>.

 <dt><code><var>target</var> . <a href="#dom-eventtarget-removeeventlistener" title="dom-EventTarget-removeEventListener">removeEventListener</a>(<var>type</var>, <var>callback</var> [, <var>capture</var> = false])</code>
 <dd><p>Удаляет <a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a>
 в списке <var>target</var>
 <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> с теми же
 <var>type</var>, <var>callback</var> и
 <var>capture</var>.

 <dt><code><var>target</var> . <a href="#dom-eventtarget-dispatchevent" title="dom-EventTarget-dispatchEvent">dispatchEvent</a>(<var>event</var>)</code>
 <dd><p><a href="#concept-event-dispatch" title="concept-event-dispatch">Отправляет</a> синтетическое
 событие <var>event</var> к <var>target</var> и возвращает true
 если значение атрибута <code title="dom-Event-cancelable"><a href="#dom-event-cancelable">cancelable</a></code>
 <var>события</var> равняется false,
 или его метод <code title="dom-Event-preventDefault"><a href="#dom-event-preventdefault">preventDefault()</a></code>
 не был вызван, и false в другом случае.
</dl>

<p>Метод
<dfn id="dom-eventtarget-addeventlistener" title="dom-EventTarget-addEventListener"><code>addEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Если <var>callback</var> равняется null, прервать эти шаги.
 <li><p>Добавить <a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a>
 в соответствующий список
 <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> с <b>type</b>
 установленным к <var>type</var>, <b>callback</b> установленным к <var>callback</var> и
 <b>capture</b> установленным к <var>capture</var>, кроме как если
 уже есть <a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a> в
 этом списке с теми же <b>type</b>, <b>callback</b> и <b>capture</b>.
</ol>

<p>Метод
<dfn id="dom-eventtarget-removeeventlistener" title="dom-EventTarget-removeEventListener"><code>removeEventListener(<var>type</var>, <var>callback</var>, <var>capture</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Удалить <a href="#concept-event-listener" title="concept-event-listener">слушатель событий</a>
 из соответствующего списка
 <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a>, чей
 <b>type</b> равняется <var>name</var>, <b>callback</b> равняется <var>callback</var> и
 <b>capture</b> равняется <var>capture</var>.</p>
</ol>

<p>Метод
<dfn id="dom-eventtarget-dispatchevent" title="dom-EventTarget-dispatchEvent"><code>dispatchEvent(<var>event</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Если <a href="#dispatch-flag">флаг отправки</a> <var>события</var> установлен или если
 его <a href="#initialized-flag">флаг инициализации</a> не установлен,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidstateerror">InvalidStateError</a></code>".
 <li><p>Инициализировать атрибут <code title="dom-Event-isTrusted"><a href="#dom-event-istrusted">isTrusted</a></code> 
 <var>события</var> к false.
 <li><p><a href="#concept-event-dispatch" title="concept-event-dispatch">Отправить</a>
 <var>событие</var> и возвратить значение которое возвращается.
</ol>


<h3 id="dispatching-events"><span class="secno">3.7 </span>Отправка событий</h3>

<p>Чтобы <dfn id="concept-event-dispatch" title="concept-event-dispatch">отправить</dfn>
<a href="#concept-event" title="concept-event">событие</a> к заданному объекту, с опциональным
<var>переопределением цели</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>event</var>
 <a href="#concept-event" title="concept-event">событием</a> которое отправлено.

 <li><p>Установить <a href="#dispatch-flag">флаг отправки</a> <var>события</var>.

 <li><p>Инициализировать атрибут <code title="dom-Event-target"><a href="#dom-event-target">target</a></code>
 <var>события</var> к
 <var>target override</var>, если он задан, и объект к которому
 <var>событие</var> отправлено в другом случае.

 <li><p>Если значение атрибута <code title="dom-Event-target"><a href="#dom-event-target">target</a></code>
 <var>события</var>
 <a href="#concept-tree-participate" title="concept-tree-participate">участвует</a> в
 <a href="#concept-tree" title="concept-tree">дереве</a>, сделать <var>event path</var>
 статическим упорядоченным списком всех его
 <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предков</a> в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, и сделать
 <var>event path</var> пустым списком в другом случае.

 <li><p>Инициализировать атрибут <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
 <var>события</var> к
 <code title="dom-Event-CAPTURING_PHASE"><a href="#dom-event-capturing_phase">CAPTURING_PHASE</a></code>.

 <li><p>Для каждого объекта в <var>event path</var>,
 <a href="#concept-event-listener-invoke" title="concept-event-listener-invoke">вызвать</a> его
 <a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> с событием
 <var>event</var>, до тех пор пока <a href="#stop-propagation-flag">флаг остановки распространения</a>
 <var>события</var> не снят.

 <li><p>Инициализировать атрибут <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
 <var>события</var> к
 <code title="dom-Event-AT_TARGET"><a href="#dom-event-at_target">AT_TARGET</a></code>.

 <li><p><a href="#concept-event-listener-invoke" title="concept-event-listener-invoke">Вызвать</a>
 <a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> значения атрибута
 <code title="dom-Event-target"><a href="#dom-event-target">target</a></code> <var>события</var>
 с <var>event</var>, если <a href="#stop-propagation-flag">флаг остановки распространения</a> <var>события</var> не установлен.

 <li>
  <p>Если значение атрибута <code title="dom-Event-bubbles"><a href="#dom-event-bubbles">bubbles</a></code> <var>события</var>
  равняется true, выполнить следующие подшаги:

  <ol>
   <li><p>Обратить порядок <var>event path</var>.

   <li><p>Инициализировать атрибут <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code> <var>события</var>
   к
   <code title="dom-Event-BUBBLING_PHASE"><a href="#dom-event-bubbling_phase">BUBBLING_PHASE</a></code>.

   <li><p>Для каждого объекта в <var>event path</var>,
   <a href="#concept-event-listener-invoke" title="concept-event-listener-invoke">вызвать</a> их
   <a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a>, с событием
   <var>event</var> до тех пор пока <a href="#stop-propagation-flag">флаг остановки распространения</a> <var>события</var> не снят.
  </ol>

 <li><p>Снять <a href="#dispatch-flag">флаг отправки</a> <var>события</var>.

 <li><p>Инициализировать атрибут <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code>
 <var>события</var> к
 <code title="dom-Event-NONE"><a href="#dom-event-none">NONE</a></code>.

 <li><p>Инициализировать атрибут <code title="dom-Event-currentTarget"><a href="#dom-event-currenttarget">currentTarget</a></code> <var>события</var> к null.

 <li><p>Возвратить false если <a href="#canceled-flag">флаг отмены</a> <var>события</var>
 установлен, и true в другом случае.
</ol>


<p>Чтобы <dfn id="concept-event-listener-invoke" title="concept-event-listener-invoke">вызвать</dfn>
<a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a> для объекта с событием,
выполнить следующие шаги:</p>
<ol>
 <li><p>Сделать <var>event</var>
 <a href="#concept-event" title="concept-event">событием</a> для которого вызваны
 <a href="#concept-event-listener" title="concept-event-listener">слушатели событий</a>.
 <li><p>Сделать <var>listeners</var> копией
 <a href="#concept-event-listener" title="concept-event-listener">слушателей событий</a> ассоциированных с
 объектом для которого эти шаги выполняются.
 <li><p>Инициализировать атрибут <code title="dom-Event-currentTarget"><a href="#dom-event-currenttarget">currentTarget</a></code> <var>события</var> к объекту для которого эти шаги выполняются.
 <li>
  <p>Затем выполнить следующие подшаги для каждого
  <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a> в
  <var>listeners</var>:</p>
  <ol>
   <li><p>Если <a href="#stop-immediate-propagation-flag">флаг остановки немедленного распространения</a> <var>события</var> установлен, прекратить
   <a href="#concept-event-listener-invoke" title="concept-event-listener-invoke">вызов</a> алгоритма.
   <li><p>Сделать <var>listener</var>
   <a href="#concept-event-listener" title="concept-event-listener">слушателем событий</a>.
   <li><p>Если значение атрибута <code title="dom-Event-type"><a href="#dom-event-type">type</a></code> <var>события</var>
   не равняется <b>type</b> <var>слушателя</var> (listener), прекратить
   эти подшаги (и выполнить их для следующего
   <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a>).
   <li><p>Если значение атрибута <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code> <var>события</var>
   равняется
   <code title="dom-Event-CAPTURING_PHASE"><a href="#dom-event-capturing_phase">CAPTURING_PHASE</a></code> и
   <b>capture</b> <var>слушателя</var> (listener) равняется false, прекратить эти
   подшаги (и выполнить их для следующего
   <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a>).
   <li><p>Если значение атрибута <code title="dom-Event-eventPhase"><a href="#dom-event-eventphase">eventPhase</a></code> <var>события</var>
   равняется
   <code title="dom-Event-BUBBLING_PHASE"><a href="#dom-event-bubbling_phase">BUBBLING_PHASE</a></code> и
   <b>capture</b> <var>слушателя</var> (listener) равняется true, прекратить эти подшаги
   (и выполнить их для следующего
   <a href="#concept-event-listener" title="concept-event-listener">слушателя событий</a>).
   <li><p>Вызвать <code title="dom-EventListener-handleEvent">handleEvent</code> <b>callback</b>-а <var>слушателя</var> (listener), с событием переданным в
   этот алгоритм как первый аргумент и значение атрибута <code title="dom-Event-currentTarget"><a href="#dom-event-currenttarget">currentTarget</a></code> <var>события</var> как
   <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-callback-this-value">callback this value</a>. Если это выдает любое исключение, <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/webappapis.html#report-the-exception">сообщите об исключении</a>.
  </ol>
 </li>
</ol>


<h3 id="firing-events"><span class="secno">3.8 </span>Вызов событий</h3>

<p><dfn id="concept-event-fire" title="concept-event-fire">Вызвать событие с именем <var>e</var></dfn>
означает, что новое <a href="#concept-event" title="concept-event">событие</a> с помощью интерфейса
<code><a href="#event">Event</a></code>, с его атрибутом
<code title="dom-Event-type"><a href="#dom-event-type">type</a></code> инициализированным к
<var>e</var> и его атрибутом <code title="dom-Event-isTrusted"><a href="#dom-event-istrusted">isTrusted</a></code>
инициализированным к true, должно быть
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправлено</a> к заданному объекту.

<p class="note">Заметка: Вызов в контексте DOM быстрый к созданию, инициализации и
<a href="#concept-event-dispatch" title="concept-event-dispatch">отправке</a>
<a href="#concept-event" title="concept-event">события</a>.
<a href="#concept-event-fire" title="concept-event-fire">Вызов события</a> делает этот процесс проще для записи. Если <a href="#concept-event" title="concept-event">событию</a> нужны <code>bubbles</code> или инициализированный атрибут
<code>cancelable</code>, можно написать
"<a href="#concept-event-fire" title="concept-event-fire">вызов события</a> названного
<code>submit</code> с его атрибутом <code>cancelable</code> инициализированным к true".



<h2 id="nodes"><span class="secno">4 </span>Узлы</h2>

<h3 id="introduction-to-the-dom"><span class="secno">4.1 </span>Введение в "The DOM"</h3>

<p>В своем первоначальном смысле, "The DOM" это API для
для доступа и управления документами (в частности, документами HTML и XML). В этой спецификации термин "документ" используется для любых
ресурсов на основе разметки, от коротких статических документов до длинных эссе или
отчетов с множеством мультимедиа, так и для полноценных интерактивных приложений.

<p>Эти документы представлены в виде
<a href="#concept-node-tree" title="concept-node-tree">дерева узлов</a>. Некоторые из
<a href="#concept-node" title="concept-node">узлов</a> в
<a href="#concept-tree" title="concept-tree">дереве</a> могут иметь
<a href="#concept-tree-child" title="concept-tree-child">дочерние</a> узлы, а некоторые нет.

<p>Для иллюстрации рассмотрим этот HTML-документ:

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html class=e&gt;
 &lt;head&gt;&lt;title&gt;Aliens?&lt;/title&gt;&lt;/head&gt;
 &lt;body&gt;Why yes.&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Он представлен следующим образом:

<ul class="domTree">
 <li>
  <a href="#concept-document" title="concept-document">Document</a>
  <ul>
   <li class="t10"><a href="#concept-doctype" title="concept-doctype">Doctype</a>: <code>html</code></li>
   <li class="t1"><a href="#concept-element" title="concept-element">Element</a>: <code>html</code> <span class="t2"><code class="attribute name">class</code>="<code class="attribute value">e</code>"</span>
    <ul>
     <li class="t1">
      <a href="#concept-element" title="concept-element">Element</a>: <code>head</code>
      <ul>
       <li class="t1">
        <a href="#concept-element" title="concept-element">Element</a>: <code>title</code>
        <ul>
         <li class="t3"><code><a href="#text">Text</a></code>: <span>Aliens?</span></li>
        </ul>
       </li>
      </ul>
     </li>
     <li class="t3"><code><a href="#text">Text</a></code>: <span>⏎␣</span></li>
     <li class="t1">
      <a href="#concept-element" title="concept-element">Element</a>: <code>body</code>
      <ul>
       <li class="t3"><code><a href="#text">Text</a></code>: <span>Why yes.⏎</span></li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

<!--
http://software.hixie.ch/utilities/js/live-dom-viewer/?%3C!DOCTYPE%20html%3E%0D%0A%3Chtml%20class%3De%3E%0D%0A%20%3Chead%3E%3Ctitle%3EAliens%3F%3C%2Ftitle%3E%3C%2Fhead%3E%0D%0A%20%3Cbody%3EWhy%20yes.%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E
-->

<p>Стоит отметить, что из-за магии
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/syntax.html#html-parser" title="HTML parser">HTML-парсинга</a>, не все
<a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a> были превращены в
<code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узлы</a>, но общий
концепт понятен. Разметка уходит, а <a href="#concept-tree" title="concept-tree">дерево</a> из
<a href="#concept-node" title="concept-node">узлов</a> приходит.

<p class="note">Заметка: Отличный
<a href="http://software.hixie.ch/utilities/js/live-dom-viewer/" target="_blank">Live DOM Viewer</a>
может использоваться для изучения этого вопроса более детально.


<h3 id="node-tree"><span class="secno">4.2 </span>Дерево узлов</h3>

<p>Объекты реализующие <code><a href="#document">Document</a></code>,
<code><a href="#documentfragment">DocumentFragment</a></code>, <code><a href="#documenttype">DocumentType</a></code>,
<code><a href="#element">Element</a></code>, <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code>
или <code><a href="#comment">Comment</a></code> интерфейс (проще сказать
<dfn id="concept-node" title="concept-node">узлы</dfn>),
<a href="#concept-tree-participate" title="concept-tree-participate">участвуют</a> в
<a href="#concept-tree" title="concept-tree">дереве</a>, проще названном
<dfn id="concept-node-tree" title="concept-node-tree">дерево узлов</dfn>.

<p><a href="#concept-node-tree" title="concept-node-tree">Дерево узлов</a> ограничивается следующим, выражаясь как отношения между типом
<a href="#concept-node" title="concept-node">узла</a> и его разрешенными
<a href="#concept-tree-child" title="concept-tree-child">дочерними</a>:
<dl>
 <dt><code><a href="#document">Document</a></code>
 <dd>
  <p>В <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>:
  <ol>
   <li><p>Ноль или более узлов, каждый из которых
   <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>.
   <li><p>Опционально один <code><a href="#documenttype">DocumentType</a></code> узел.
   <li><p>Ноль или более узлов, каждый из которых
   <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>.
   <li><p>Опционально один <code><a href="#element">Element</a></code> узел.
   <li><p>Ноль или более узлов, каждый из которых
   <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>.
  </ol>
 <dt><code><a href="#documentfragment">DocumentFragment</a></code>
 <dt><code><a href="#element">Element</a></code>
 <dd><p>Ноль или более узлов, каждый из которых один из: <code><a href="#element">Element</a></code>,
 <code><a href="#processinginstruction">ProcessingInstruction</a></code>, <code><a href="#comment">Comment</a></code> или
 <code><a href="#text">Text</a></code>.
 <dt><code><a href="#documenttype">DocumentType</a></code>
 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dd><p>Ничего.
</dl>
<!--AttrExodus -->

<p><dfn id="concept-node-length" title="concept-node-length">Длина</dfn>
<a href="#concept-node" title="concept-node">узла</a> <var>node</var> зависит от
<var>node</var>:
<dl class="switch">
 <dt><code><a href="#documenttype">DocumentType</a></code>
 <dd><p>Ноль.

 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dd><p>Его значение атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code>.

 <dt>Любой другой узел
 <dd><p>Его количество <a href="#concept-tree-child" title="concept-tree-child">дочерних</a>.
</dl>

<p><a href="#concept-node" title="concept-node">Узел</a> считается
<dfn id="concept-node-empty" title="concept-node-empty">пустым</dfn> если его
<a href="#concept-node-length" title="concept-node-length">длина</a> равняется нолю.


<h4 id="mutation-algorithms"><span class="secno">4.2.1 </span>Алгоритмы изменений</h4>

<p>Чтобы <dfn id="concept-node-ensure-pre-insertion-validity" title="concept-node-ensure-pre-insertion-validity">обеспечить валидность предварительной вставки</dfn>
<var>узла</var> в <var>родительский</var> перед
<var>дочерним</var>, выполнить следующие шаги:

<ol>
 <li><p>Если <var>родительский</var> не является <code><a href="#document">Document</a></code>,
 <code><a href="#documentfragment">DocumentFragment</a></code> или <code><a href="#element">Element</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <var>узел</var> является
 <a href="#concept-tree-host-including-inclusive-ancestor" title="concept-tree-host-including-inclusive-ancestor">хост-включительным включительным предком</a> <var>родительского</var>, <a href="#dfn-throw" title="concept-throw">выдать</a> "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <var>дочерний</var> не равен null и его
 <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> не
 <var>parent</var>, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#notfounderror">NotFoundError</a></code>".

 <li><p>Если <var>узел</var> не
 <code><a href="#documentfragment">DocumentFragment</a></code>, <code><a href="#documenttype">DocumentType</a></code>,
 <code><a href="#element">Element</a></code>, <code><a href="#text">Text</a></code>,
 <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>
 <a href="#concept-node" title="concept-node">узел</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <var>узел</var> это <code><a href="#text">Text</a></code>
 <a href="#concept-node" title="concept-node">узел</a> и <var>родитель</var> это
 <a href="#concept-document" title="concept-document">document</a>, или <var>узел</var> это
 <a href="#concept-doctype" title="concept-doctype">doctype</a> и <var>parent</var> не является <a href="#concept-document" title="concept-document">document</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li>
  <p>Если <var>родитель</var> это
  <a href="#concept-document" title="concept-document">document</a>, и любые из утверждений ниже, переключенные на <var>узел</var>, являются true, <a href="#dfn-throw" title="concept-throw">выдать</a>
  "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

  <dl class="switch">
   <dt><code><a href="#documentfragment">DocumentFragment</a></code> <a href="#concept-node" title="concept-node">узел</a>
   <dd>
    <p>Если <var>узел</var> имеет больше одного
    <a href="#concept-tree-child" title="concept-tree-child">дочернего</a> <a href="#concept-element" title="concept-element">элемента</a>
    или имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>.

    <p>В другом случае, если <var>узел</var> имеет один
    <a href="#concept-tree-child" title="concept-tree-child">дочерний элемент</a> <a href="#concept-element" title="concept-element">element</a> и <var>родитель</var> имеет
    <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-element" title="concept-element">элемент</a>, <var>дочерний</var> это
    <a href="#concept-doctype" title="concept-doctype">doctype</a> или <var>дочерний</var> не null и <a href="#concept-doctype" title="concept-doctype">doctype</a> является
    <a href="#concept-tree-following" title="concept-tree-following">следующим</a> за <var>дочерним</var> объектом.
    <!--"inclusively following"-->

   <dt><a href="#concept-element" title="concept-element">элемент</a>
   <dd><p><var>родитель</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-element" title="concept-element">элемент</a>, <var>дочерний</var> является
   <a href="#concept-doctype" title="concept-doctype">doctype</a> или <var>дочерний</var> не null и
   <a href="#concept-doctype" title="concept-doctype">doctype</a> является
   <a href="#concept-tree-following" title="concept-tree-following">следующим</a> за <var>дочерним</var> объектом.
   <!--"inclusively following"-->

   <dt><a href="#concept-doctype" title="concept-doctype">тип документа</a>
   <dd><p><var>родитель</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-doctype" title="concept-doctype">doctype</a>,
   <a href="#concept-element" title="concept-element">элемент</a> является
   <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующим</a> <var>дочернему</var>, или
   <var>дочерний</var> равен null и <var>родительский</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>
   <a href="#concept-element" title="concept-element">элемент</a>.
  </dl>
</ol>

<p>Чтобы <dfn id="concept-node-pre-insert" title="concept-node-pre-insert">предварительно вставить</dfn>
<var>узел</var> в <var>parent</var> перед
<var>child</var>, выполнить следующие шаги:

<ol>
 <li><p><a href="#concept-node-ensure-pre-insertion-validity" title="concept-node-ensure-pre-insertion-validity">Обеспечить валидность предварительной вставки</a>
 <var>узла</var> в <var>parent</var> перед
 <var>child</var>.

 <li><p>Сделать <var>reference child</var> <var>дочерним</var>.

 <li><p>Если <var>reference child</var> является <var>node</var>, установить его
 к <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующему сестринскому</a> <var>узла</var>.

 <li><p><a href="#concept-node-adopt" title="concept-node-adopt">Принять</a>
 <var>узел</var> в <a href="#concept-node-document" title="concept-node-document">node document</a> <var>родительского</var>.

 <li><p><a href="#concept-node-insert" title="concept-node-insert">Вставить</a> <var>узел</var>
 в <var>parent</var> перед <var>reference child</var>.

 <li><p>Возвратить <var>node</var>.
 <!-- technically this is post-insert -->
</ol>

<p><a href="#other-applicable-specifications" title="Other applicable specifications">Спецификации</a> могут определять
<dfn id="concept-node-insert-ext" title="concept-node-insert-ext">шаги вставки</dfn> для всех или некоторых
<a href="#concept-node" title="concept-node">узлов</a>. Алгоритм передает <var>newNode</var> как указано в алгоритме <a href="#concept-node-insert" title="concept-node-insert">вставки</a> ниже.

<p>Чтобы <dfn id="concept-node-insert" title="concept-node-insert">вставить</dfn> <var>узел</var>
в <var>parent</var> перед <var>child</var> с опциональным <i>флагом подавления наблюдений</i>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>count</var> количеством
 <a href="#concept-tree-child" title="concept-tree-child">children</a> <var>узла</var> если
 это <a href="#concept-node" title="concept-node">узел</a> <code><a href="#documentfragment">DocumentFragment</a></code>, или равным одному в другом случае.

 <li>
  <p>Если <var>child</var> не-null, выполнить эти шаги:

  <ol>
   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> является
   <var>parent</var> и
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> более чем
   <a href="#concept-tree-index" title="concept-tree-index">index</a> <var>дочернего</var>,
   увеличить их <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> на
   <var>count</var>.

   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
   <var>parent</var> и
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> более чем
   <a href="#concept-tree-index" title="concept-tree-index">index</a> <var>дочернего</var>,
   увеличить их <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> на
   <var>count</var>.
  </ol>

 <li><p>Сделать <var>узлы</var> <a href="#concept-tree-child" title="concept-tree-child">дочерними</a> <var>узла</var> если <var>узел</var> является <code><a href="#documentfragment">DocumentFragment</a></code> <a href="#concept-node" title="concept-node">узлом</a>, и списком содержащим единственный <var>узел</var> в другом случае.

 <li>
  <p>Если <var>node</var> является <code><a href="#documentfragment">DocumentFragment</a></code>
  <a href="#concept-node" title="concept-node">узлом</a>, <a href="#queue-a-mutation-record">поставить в очередь запись изменения</a>
  "<code>childList</code>" для <var>node</var> с removedNodes
  <var>nodes</var>.

  <p class="note">Заметка: Этот шаг намеренно не обращает внимания на
  <i>флаг подавления наблюдателей</i>.

 <li><p>Если <var>node</var> является <code><a href="#documentfragment">DocumentFragment</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#concept-node-remove" title="concept-node-remove">удалить</a> его
 <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> с установленным
 <i>флага подавления наблюдателей</i>.

 <li><p>Если <i>флага подавления наблюдателей</i> снят,
 <a href="#queue-a-mutation-record">поставить в очередь запись изменения</a> "<code>childList</code>" для
 <var>parent</var> с addedNodes <var>nodes</var>,
 nextSibling <var>child</var>, и previousSibling
 <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>child</var>
 или <a href="#concept-tree-last-child" title="concept-tree-last-child">последним дочерним</a> <var>parent</var> если
 <var>child</var> является null.

 <li>
  <p>Для каждого <var>newNode</var> в <var>nodes</var>, в
  <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, выполнить следующие шаги:

  <ol>
   <li><p>Вставить <var>newNode</var> в <var>parent</var> перед
   <var>child</var>, либо в конце <var>parent</var> если
   <var>child</var> является null.

   <li><p>Выполнить <a href="#concept-node-insert-ext" title="concept-node-insert-ext">шаги вставки</a> с
   <var>newNode</var>.
  </ol>
</ol>


<p>Чтобы <dfn id="concept-node-append" title="concept-node-append">добавить</dfn> <var>node</var>
к <var>parent</var>,
<a href="#concept-node-pre-insert" title="concept-node-pre-insert">предварительно вставить</a> <var>node</var>
в <var>parent</var> перед null.


<p>Чтобы <dfn id="concept-node-replace" title="concept-node-replace">заменить</dfn> <var>child</var>
на <var>node</var> внутри <var>parent</var>, выполнить следующие шаги:

<!-- Step 1-5 could be shared with concept-node-pre-insert, although step 3
     in pre-insert is a superset (which is fine). Step 6.1.1 could also be
     shared. -->

<ol>
 <li><p>Если <var>parent</var> не является <code><a href="#document">Document</a></code>,
 <code><a href="#documentfragment">DocumentFragment</a></code> или <code><a href="#element">Element</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <var>node</var> является
 <a href="#concept-tree-host-including-inclusive-ancestor" title="concept-tree-host-including-inclusive-ancestor">хост-включающим включительным предком</a> <var>parent</var>, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>child</var> не является
 <var>parent</var>, <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#notfounderror">NotFoundError</a></code>" исключение.

 <li><p>Если <var>node</var> не является
 <code><a href="#documentfragment">DocumentFragment</a></code>, <code><a href="#documenttype">DocumentType</a></code>,
 <code><a href="#element">Element</a></code>, <code><a href="#text">Text</a></code>,
 <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li><p>Если <var>node</var> является <code><a href="#text">Text</a></code>
 <a href="#concept-node" title="concept-node">узлом</a> и <var>parent</var> является
 <a href="#concept-document" title="concept-document">document</a>, либо если <var>node</var>
 <a href="#concept-doctype" title="concept-doctype">doctype</a> и <var>parent</var> не являются <a href="#concept-document" title="concept-document">document</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <li>
  <p>Если <var>parent</var> является
  <a href="#concept-document" title="concept-document">document</a>, и любые из утверждение ниже, переключенные на
  <var>node</var>, являются true, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
  "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

  <dl class="switch">
   <dt><code><a href="#documentfragment">DocumentFragment</a></code> <a href="#concept-node" title="concept-node">узел</a>
   <dd>
    <p>Если <var>node</var> имеет более одного
    <a href="#concept-tree-child" title="concept-tree-child">дочернего</a> <a href="#concept-element" title="concept-element">элемента</a>
    или имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>.

    <p>В другом случае, если <var>node</var> имеет один <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>
    <a href="#concept-element" title="concept-element">элемент</a>
    и <var>parent</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-element" title="concept-element">элемент</a>, который не является <var>child</var>, или если
    <a href="#concept-doctype" title="concept-doctype">doctype</a> является
    <a href="#concept-tree-following" title="concept-tree-following">следующим</a> <var>дочерним</var>.

   <dt><a href="#concept-element" title="concept-element">элемент</a>
   <dd><p><var>parent</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-element" title="concept-element">элемент</a>, не являющийся <var>child</var>, или
   <a href="#concept-doctype" title="concept-doctype">doctype</a> является
   <a href="#concept-tree-following" title="concept-tree-following">следующим</a> <var>дочерним</var>.

   <dt><a href="#concept-doctype" title="concept-doctype">doctype</a>
   <dd><var>parent</var> имеет <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <a href="#concept-doctype" title="concept-doctype">doctype</a>, не являющийся <var>child</var>, или
   <a href="#concept-element" title="concept-element">элемент</a> является
   <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующим</a> <var>child</var>.
  </dl>

  <p class="note">Заметка: Приведенные выше утверждения отличаются от алгоритма
  <a href="#concept-node-pre-insert" title="concept-node-pre-insert">предварительной вставки</a>.

 <li><p>Сделать <var>reference child</var> <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>child</var>.

 <li><p>Если <var>reference child</var> является <var>node</var>, установить его к <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующему сестринскому</a> <var>node</var>.

 <li><p><a href="#concept-node-adopt" title="concept-node-adopt">Принять</a>
 <var>node</var> в <a href="#concept-node-document" title="concept-node-document">документ узла</a> <var>parent</var>-а.

 <li><p><a href="#concept-node-remove" title="concept-node-remove">Удалить</a> <var>child</var>
 с его <var>parent</var> с установленным
 <i>флагом подавления наблюдателей</i>.

 <li><p><a href="#concept-node-insert" title="concept-node-insert">Вставить</a> <var>node</var>
 в <var>parent</var> перед <var>reference child</var> с
 установленным <i>флагом подавления наблюдателей</i>.

 <li><p>Сделать <var>nodes</var> <a href="#concept-tree-child" title="concept-tree-child">дочерними</a> <var>node</var> если <var>node</var> является <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#documentfragment">DocumentFragment</a></code>, и списком содержащим единственную <var>node</var> в другом случае.

 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code>childList</code>" для целевого <var>parent</var> с addedNodes
 <var>nodes</var>, removedNodes списком содержащим единственный
 <var>child</var>, nextSibling <var>reference child</var>, и
 previousSibling <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>child</var>.

 <li><p>Возвратить <var>child</var>.
</ol>


<p>Чтобы <dfn id="concept-node-replace-all" title="concept-node-replace-all">заменить все</dfn> с
<var>node</var> внутри <var>parent</var>, выполнить следующие шаги:

<ol>
 <li><p>Если <var>node</var> не является null,
 <a href="#concept-node-adopt" title="concept-node-adopt">принять</a> <var>node</var> с
 <a href="#concept-node-document" title="concept-node-document">узлом документа</a> <var>parent</var>.

 <li><p>Сделать <var>removedNodes</var> <a href="#concept-tree-child" title="concept-tree-child">дочерним</a> <var>parent</var>.

 <li><p>Сделать <var>addedNodes</var> пустым списком если <var>node</var> является
 null, <a href="#concept-tree-child" title="concept-tree-child">дочерним</a> <var>node</var> если
 <var>node</var> является <code><a href="#documentfragment">DocumentFragment</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>, или списком <var>node</var>
 в другом случае.

 <li><p><a href="#concept-node-remove" title="concept-node-remove">Удалить</a> все <a href="#concept-tree-child" title="concept-tree-child">дочерние</a>
 <var>parent</var>, в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, с установленным
 <i>флагом подавления наблюдателей</i>.

 <li><p>Если <var>node</var> не является null,
 <a href="#concept-node-insert" title="concept-node-insert">вставить</a> <var>node</var> в
 <var>parent</var> перед null с установленным <i>флагом подавления наблюдателей</i>.

 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code>childList</code>" для
 <var>parent</var> с addedNodes <var>addedNodes</var> и
 removedNodes <var>removedNodes</var>.
</ol>

<p class="note">Заметка: Этот алгоритм не делает никаких проверок в отношении ограничений
<a href="#concept-node-tree" title="concept-node-tree">дерева узлов</a>. Авторы спецификации должны использовать его с умом.


<p>Чтобы <dfn id="concept-node-pre-remove" title="concept-node-pre-remove">предварительно удалить</dfn>
<var>child</var> из <var>parent</var>, выполнить следующие шаги:</p>

<ol>
 <li><p>Если <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>child</var> не является
 <var>parent</var>, <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#notfounderror">NotFoundError</a></code>" исключение.

 <li><p><a href="#concept-node-remove" title="concept-node-remove">Удалить</a> <var>child</var>
 из <var>parent</var>.

 <li><p>Возвратить <var>child</var>.
 <!-- technically this is post-remove -->
</ol>


<p><a href="#other-applicable-specifications" title="Other applicable specifications">Спецификации</a> могут определять
<dfn id="concept-node-remove-ext" title="concept-node-remove-ext">шаги удаления</dfn> для всех или некоторых
<a href="#concept-node" title="concept-node">узлов</a>. Алгоритм передает <var>removedNode</var>,
<var>oldParent</var>, and <var>oldPreviousSibling</var>, как указано в алгоритме
<a href="#concept-node-remove" title="concept-node-remove">удаления</a> ниже.

<p>Чтобы <dfn id="concept-node-remove" title="concept-node-remove">удалить</dfn> <var>node</var>
из <var>parent</var> с опциональной установкой
<i>флага подавления наблюдателей</i>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>index</var> <a href="#concept-tree-index" title="concept-tree-index">индексом</a> <var>node</var>.

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> является
 <a href="#concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">включительным потомком</a>
 <var>node</var>, установить его
 <a href="#concept-range-start" title="concept-range-start">начало</a> к
 (<var>parent</var>, <var>index</var>).

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
 <a href="#concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">включительным потомком</a>
 <var>node</var>, установить его
 <a href="#concept-range-end" title="concept-range-end">конец</a> к
 (<var>parent</var>, <var>index</var>).

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> является
 <var>parent</var> и
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> больше чем
 <var>index</var>, уменьшить его
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> на единицу.

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
 <var>parent</var> и
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> больше чем
 <var>index</var>, уменьшить его
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> на единицу.

 <li><p>Сделать <var>oldPreviousSibling</var> <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>node</var>.

 <li><p>Если <i>флаг подавления наблюдателей</i> снят,
 <a href="#queue-a-mutation-record">поставить в очередь запись изменения</a> "<code>childList</code>" для
 <var>parent</var> с removedNodes списком содержащим единственную
 <var>node</var>, nextSibling <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>node</var>, и previousSibling <var>oldPreviousSibling</var>.

 <li><p>Для каждого <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предка</a>
 <var>ancestor</var> <var>node</var>-ы, если
 <var>ancestor</var> имеет любые
 <a href="#registered-observer" title="registered observer">зарегистрированные наблюдатели</a>, чье <code title="dom-MutationObserverInit-subtree">поддерево</code>
 <b>опций</b> является true, то
 для каждого такого <a href="#registered-observer">зарегистрированного наблюдателя</a> <var>registered</var> добавить
 <a href="#transient-registered-observer">переходный зарегистрированный наблюдатель</a>, чей <b>наблюдатель</b> и
 <b>опции</b> идентичны к <var>registered</var> и <b>source</b>, которые <var>registered</var> к списку <a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a> <var>node</var>.

 <li><p>Удалить <var>node</var> из его <var>parent</var>.

 <li><p>Выполнить <a href="#concept-node-remove-ext" title="concept-node-remove-ext">шаги удаления</a> с
 <var>node</var>, <var>parent</var> и <var>oldPreviousSibling</var>.
</ol>


<h4 id="interface-nonelementparentnode"><span class="secno">4.2.2 </span>Интерфейс <code><a href="#nonelementparentnode">NonElementParentNode</a></code></h4>

<p class="note no-backref">Заметка: Метод
<code title="dom-NonElementParentNode-getElementById"><a href="#dom-nonelementparentnode-getelementbyid">getElementById()</a></code> не на <a href="#concept-element" title="concept-element">элементах</a> для совместимости с более старыми версиями
jQuery. Если со временем данная версия jQuery исчезнет, может быть мы сможем поддерживать это.

<pre class="idl">[NoInterfaceObject,
 Exposed=Window]
interface <dfn id="nonelementparentnode">NonElementParentNode</dfn> {
  <a href="#element">Element</a>? <a href="#dom-nonelementparentnode-getelementbyid" title="dom-NonElementParentNode-getElementById">getElementById</a>(DOMString <var>elementId</var>);
};
<a href="#document">Document</a> implements <a href="#nonelementparentnode">NonElementParentNode</a>;
<a href="#documentfragment">DocumentFragment</a> implements <a href="#nonelementparentnode">NonElementParentNode</a>;</pre>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-nonelementparentnode-getelementbyid" title="dom-NonElementParentNode-getElementById">getElementById</a>(<var>elementId</var>)</code>
 <dd><p>Возвращает первый <a href="#concept-element" title="concept-element">элемент</a> внутри
 <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a> <var>node</var>, чей
 <a href="#concept-id" title="concept-id">ID</a> это <var>elementId</var>.
</dl>

<p>Метод
<dfn id="dom-nonelementparentnode-getelementbyid" title="dom-NonElementParentNode-getElementById"><code>getElementById(<var>elementId</var>)</code></dfn>
должен возвратить первый <a href="#concept-element" title="concept-element">элемент</a>, в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, внутри <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a> <a href="#context-object">объекта контекста</a>, чей
<a href="#concept-id" title="concept-id">ID</a> это <var>elementId</var>, либо null если такого <a href="#concept-element" title="concept-element">элемента</a> нет.


<h4 id="interface-parentnode"><span class="secno">4.2.3 </span>Интерфейс <code><a href="#parentnode">ParentNode</a></code></h4>

<p><dfn id="mutation-method-macro">Макрос метода изменений</dfn>:

<ol>
 <li><p>Сделать <var>node</var> null.

 <li><p>Заменить каждую строку в <var>nodes</var> на
 <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>, чьи
 <a href="#concept-cd-data" title="concept-CD-data">данные</a> являются строковым значением.

 <li>
  <p>Если <var>nodes</var> содержат более одного
  <a href="#concept-node" title="concept-node">узла</a>, установить <var>node</var> к новому
  <code><a href="#documentfragment">DocumentFragment</a></code> и
  <a href="#concept-node-append" title="concept-node-append">добавить</a> каждый
  <a href="#concept-node" title="concept-node">узел</a> в <var>nodes</var> к нему. Заново выдать любые исключения.

  <p>В другом случае, установить <var>node</var> к единственному
  <a href="#concept-node" title="concept-node">узлу</a>, который <var>nodes</var> содержит.
</ol>

<pre class="idl">[NoInterfaceObject,
 Exposed=Window]
interface <dfn id="parentnode">ParentNode</dfn> {
  [SameObject] readonly attribute <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-parentnode-children" title="dom-ParentNode-children">children</a>;
  readonly attribute <a href="#element">Element</a>? <a href="#dom-parentnode-firstelementchild" title="dom-ParentNode-firstElementChild">firstElementChild</a>;
  readonly attribute <a href="#element">Element</a>? <a href="#dom-parentnode-lastelementchild" title="dom-ParentNode-lastElementChild">lastElementChild</a>;
  readonly attribute unsigned long <a href="#dom-parentnode-childelementcount" title="dom-ParentNode-childElementCount">childElementCount</a>;

  <a href="#element">Element</a>? <a href="#dom-parentnode-queryselector" title="dom-ParentNode-querySelector">querySelector</a>(DOMString <var>selectors</var>);
  [NewObject] <a href="#nodelist">NodeList</a> <a href="#dom-parentnode-queryselectorall" title="dom-ParentNode-querySelectorAll">querySelectorAll</a>(DOMString <var>selectors</var>);
};
<a href="#document">Document</a> implements <a href="#parentnode">ParentNode</a>;
<a href="#documentfragment">DocumentFragment</a> implements <a href="#parentnode">ParentNode</a>;
<a href="#element">Element</a> implements <a href="#parentnode">ParentNode</a>;</pre>

<dl class="domintro">
 <dt><code><var>collection</var> = <var>node</var> . <a href="#dom-parentnode-children" title="dom-ParentNode-children">children</a></code>
 <dd><p>Возвращает <a href="#concept-tree-child" title="concept-tree-child">дочерние</a>
 <a href="#concept-element" title="concept-element">элементы</a>.

 <dt><code><var>element</var> = <var>node</var> . <a href="#dom-parentnode-firstelementchild" title="dom-ParentNode-firstElementChild">firstElementChild</a></code>
 <dd><p>Возвращает первый <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>, который
 является <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

 <dt><code><var>element</var> = <var>node</var> . <a href="#dom-parentnode-lastelementchild" title="dom-ParentNode-lastElementChild">lastElementChild</a></code>
 <dd><p>Возвращает последний <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>, который является
 <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

 <!-- childElementCount is redundant -->

 <dt><code><var>node</var> . <a href="#dom-parentnode-queryselector" title="dom-ParentNode-querySelector">querySelector</a>(<var>selectors</var>)</code>
 <dd>
  <p>Возвращает первый <a href="#concept-element" title="concept-element">элемент</a>, который является
  <a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a> <var>node</var>, который
  соответствует <var>selectors</var>.

 <dt><code><var>node</var> . <a href="#dom-parentnode-queryselectorall" title="dom-ParentNode-querySelectorAll">querySelectorAll</a>(<var>selectors</var>)</code>
 <dd>
  <p>Возвращает все <a href="#concept-element" title="concept-element">элементы</a>
  <a href="#concept-tree-descendant" title="concept-tree-descendant">потомки</a> <var>node</var>, которые соответствуют <var>selectors</var>.
</dl>

<p>Атрибут <dfn id="dom-parentnode-children" title="dom-ParentNode-children"><code>children</code></dfn>
должен возвратить <a href="#concept-collection" title="concept-collection">коллекцию</a> <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
<a href="#context-object">объекте контекста</a>, соответствующую только <a href="#concept-tree-child" title="concept-tree-child">дочерним</a>
<a href="#concept-element" title="concept-element">элементам</a>.

<p>Атрибут
<dfn id="dom-parentnode-firstelementchild" title="dom-ParentNode-firstElementChild"><code>firstElementChild</code></dfn>
должен возвратить первый <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>, который является <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

<p>Атрибут
<dfn id="dom-parentnode-lastelementchild" title="dom-ParentNode-lastElementChild"><code>lastElementChild</code></dfn>
должен возвратить последний <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>,
который является <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

<p>Атрибут
<dfn id="dom-parentnode-childelementcount" title="dom-ParentNode-childElementCount"><code>childElementCount</code></dfn>
должен возвратить количество
<a href="#concept-tree-child" title="concept-tree-child">дочерних</a>
<a href="#context-object">объекта контекста</a>, которые являются
<a href="#concept-element" title="concept-element">элементами</a>.

<p>Чтобы <dfn id="match-a-relative-selectors-string">сопоставить относительную строку селекторов</dfn> <var>relativeSelectors</var>
против <var>set</var>, выполнить данные шаги:

<ol>
 <li><p>Сделать <var>s</var> результатом
 <a class="external" data-anolis-spec="selectors" href="#css4-parse-a-relative-selector">парсинга относительного селектора</a> от
 <var>relativeSelectors</var> против <var>set</var>.
 <a href="#biblio-SELECTORS">[SELECTORS]</a>

 <li><p>Если <var>s</var> неудачен, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#syntaxerror">SyntaxError</a></code>".

 <li><p>Возвратить результат <a class="external" data-anolis-spec="selectors" href="#css4-evaluate-a-selector">оценки селектора</a>
 <var>s</var>, используя
 <a class="external" data-anolis-spec="selectors" href="#css4-scope-element" title=":scope element">:scope elements</a>
 <var>set</var>. <a href="#biblio-SELECTORS">[SELECTORS]</a>
</ol>

<p>Чтобы <dfn id="scope-match-a-selectors-string">scope-сопоставить строку селекторов</dfn> <var>selectors</var> против
<var>node</var>, выполнить данные шаги:

<ol>
 <li><p>Сделать <var>s</var> результатом
 <a class="external" data-anolis-spec="selectors" href="#css4-parse-a-selector">парсинга селектора</a> <var>selectors</var>.
 <a href="#biblio-SELECTORS">[SELECTORS]</a>

 <li><p>Если <var>s</var> неудачен, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#syntaxerror">SyntaxError</a></code>".

 <li><p>Возвратить результат <a class="external" data-anolis-spec="selectors" href="#css4-evaluate-a-selector">оценки селектора</a>
 <var>s</var> против <a href="#concept-tree-root" title="concept-tree-root">корня</a>
 <var>node</var>, используя
 <a class="external" data-anolis-spec="selectors" href="#css4-scoping-root">scoping root</a> <var>node</var>
 и метод
 <a class="external" data-anolis-spec="selectors" href="#css4-scope_filtered" title="scope_filtered">scope-filtered</a>.
 <a href="#biblio-SELECTORS">[SELECTORS]</a>.
</ol>

<p>Метод
<dfn id="dom-parentnode-queryselector" title="dom-ParentNode-querySelector"><code>querySelector(<var>selectors</var>)</code></dfn>
должен возвратить первый результат выполнения <a href="#scope-match-a-selectors-string">scope-сопоставления строки селекторов</a>
<var>selectors</var> против <a href="#context-object">объекта контекста</a>, и null если результат является пустым списком.

<p>Метод
<dfn id="dom-parentnode-queryselectorall" title="dom-ParentNode-querySelectorAll"><code>querySelectorAll(<var>selectors</var>)</code></dfn>
должен возвратить <a href="#concept-collection-static" title="concept-collection-static">статический</a> результат
выполнения <a href="#scope-match-a-selectors-string">scope-сопоставления строки селекторов</a> <var>selectors</var> против
<a href="#context-object">объекта контекста</a>.


<h4 id="interface-nondocumenttypechildnode"><span class="secno">4.2.4 </span>Интерфейс <code><a href="#nondocumenttypechildnode">NonDocumentTypeChildNode</a></code></h4>

<p class="note no-backref">Заметка: Атрибуты
<code title="dom-NonDocumentTypeChildNode-previousElementSibling"><a href="#dom-nondocumenttypechildnode-previouselementsibling">previousElementSibling</a></code>
и <code title="dom-NonDocumentTypeChildNode-nextElementSibling"><a href="#dom-nondocumenttypechildnode-nextelementsibling">nextElementSibling</a></code>
были удалены из узлов <code><a href="#documenttype">DocumentType</a></code> по причинам совместимости. Если эти дополнения посчитаются достаточно совместимыми в будущем, они могут быть восстановлены.

<pre class="idl">[NoInterfaceObject,
 Exposed=Window]
interface <dfn id="nondocumenttypechildnode">NonDocumentTypeChildNode</dfn> {
  readonly attribute <a href="#element">Element</a>? <a href="#dom-nondocumenttypechildnode-previouselementsibling" title="dom-NonDocumentTypeChildNode-previousElementSibling">previousElementSibling</a>;
  readonly attribute <a href="#element">Element</a>? <a href="#dom-nondocumenttypechildnode-nextelementsibling" title="dom-NonDocumentTypeChildNode-nextElementSibling">nextElementSibling</a>;
};
<a href="#element">Element</a> implements <a href="#nondocumenttypechildnode">NonDocumentTypeChildNode</a>;
<a href="#characterdata">CharacterData</a> implements <a href="#nondocumenttypechildnode">NonDocumentTypeChildNode</a>;</pre>

<dl class="domintro">
 <dt><code><var>element</var> = <var>node</var> . <a href="#dom-nondocumenttypechildnode-previouselementsibling" title="dom-NonDocumentTypeChildNode-previousElementSibling">previousElementSibling</a></code>
 <dd><p>Возвращает первый
 <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующий</a>
 <a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a>, который является
 <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

 <dt><code><var>element</var> = <var>node</var> . <a href="#dom-nondocumenttypechildnode-nextelementsibling" title="dom-NonDocumentTypeChildNode-nextElementSibling">nextElementSibling</a></code>
 <dd><p>Возвращает первый
 <a href="#concept-tree-following" title="concept-tree-following">следующий</a>
 <a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a>, который
 является <a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.
</dl>

<p>Атрибут
<dfn id="dom-nondocumenttypechildnode-previouselementsibling" title="dom-NonDocumentTypeChildNode-previousElementSibling"><code>previousElementSibling</code></dfn>
должен возвратить первый
<a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующий</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a>, который является
<a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.

<p>Атрибут
<dfn id="dom-nondocumenttypechildnode-nextelementsibling" title="dom-NonDocumentTypeChildNode-nextElementSibling"><code>nextElementSibling</code></dfn>
должен возвратить первый
<a href="#concept-tree-following" title="concept-tree-following">следующий</a>
<a href="#concept-tree-sibling" title="concept-tree-sibling">сестринский</a>, который является
<a href="#concept-element" title="concept-element">элементом</a>, и null в другом случае.


<h4 id="interface-childnode"><span class="secno">4.2.5 </span>Интерфейс <code><a href="#childnode">ChildNode</a></code></h4>

<pre class="idl">[NoInterfaceObject,
 Exposed=Window]
interface <dfn id="childnode">ChildNode</dfn> {
  void <a href="#dom-childnode-remove" title="dom-ChildNode-remove">remove</a>();
};
<a href="#documenttype">DocumentType</a> implements <a href="#childnode">ChildNode</a>;
<a href="#element">Element</a> implements <a href="#childnode">ChildNode</a>;
<a href="#characterdata">CharacterData</a> implements <a href="#childnode">ChildNode</a>;</pre>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-childnode-remove" title="dom-ChildNode-remove">remove</a>()</code>
 <dd><p>Удаляет <var>node</var>.
</dl>

<p>Метод
<dfn id="dom-childnode-remove" title="dom-ChildNode-remove"><code>remove()</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#context-object">объект контекста</a> не имеет
 <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>, прекратить данные шаги.

 <li><p><a href="#concept-node-remove" title="concept-node-remove">Удалить</a>
 <a href="#context-object">объект контекста</a> из <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>
 <a href="#context-object">объекта контекста</a>.
</ol>


<h4 id="old-style-collections:-nodelist-and-htmlcollection"><span class="secno">4.2.6 </span>Коллекции старого типа: <code><a href="#nodelist">NodeList</a></code> и <code><a href="#htmlcollection">HTMLCollection</a></code></h4>

<p><dfn id="concept-collection" title="concept-collection">Коллекция</dfn> это объект,
представляющий собой список узлов DOM. <a href="#concept-collection" title="concept-collection">Коллекция</a> может быть
<dfn id="concept-collection-live" title="concept-collection-live">живой</dfn> или
<dfn id="concept-collection-static" title="concept-collection-static">статичной</dfn>. Если не указано иное,
<a href="#concept-collection" title="concept-collection">коллекция</a> должна быть
<a href="#concept-collection-live" title="concept-collection-live">живой</a>.

<p>Если <a href="#concept-collection" title="concept-collection">коллекция</a> является <a href="#concept-collection-live" title="concept-collection-live">живой</a>, то атрибуты и методы
на этом объекте должны оперировать фактическими основными данными, а не снимком данных.

<p>Когда <a href="#concept-collection" title="concept-collection">коллекция</a> создана,
фильтр и корень ассоциированы с ней.

<p>Тогда <a href="#concept-collection" title="concept-collection">коллекция</a>
<dfn id="represented-by-the-collection" title="represented by the collection">представляет</dfn> вид поддерева с корнем в корне <a href="#concept-collection" title="concept-collection">коллекции</a>, содержа только узлы соответствующие заданному фильтру. Представление является линейным.
При отсутствии специальных требований к обратному, узлы внутри <a href="#concept-collection" title="concept-collection">коллекции</a> должны быть отсортированы в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.


<h5 id="interface-nodelist"><span class="secno">4.2.6.1 </span>Интерфейс <code><a href="#nodelist">NodeList</a></code></h5>

<p>Объект <code><a href="#nodelist">NodeList</a></code> является
<a href="#concept-collection" title="concept-collection">коллекцией</a>
<a href="#concept-node" title="concept-node">узлов</a>.

<pre class="idl">[Exposed=Window]
interface <dfn id="nodelist">NodeList</dfn> {
  getter <a href="#node">Node</a>? <a href="#dom-nodelist-item" title="dom-NodeList-item">item</a>(unsigned long <var>index</var>);
  readonly attribute unsigned long <a href="#dom-nodelist-length" title="dom-NodeList-length">length</a>;
  iterable&lt;<a href="#node">Node</a>&gt;;
};</pre>

<dl class="domintro">
 <dt><var>collection</var> . <code title="dom-NodeList-length"><a href="#dom-nodelist-length">length</a></code>
 <dd>
  <p>Возвращает количество <a href="#concept-node" title="concept-node">узлов</a> в
  <a href="#concept-collection" title="concept-collection">коллекции</a>.

 <dt><var>element</var> = <var>collection</var> . <code title="dom-NodeList-item"><a href="#dom-nodelist-item">item</a></code>(<var>index</var>)
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>
  <p>Возвращает <a href="#concept-node" title="concept-node">узел</a> с индексом
  <var>index</var> из
  <a href="#concept-collection" title="concept-collection">коллекции</a>. <a href="#concept-node" title="concept-node">Узлы</a> отсортированы в
  <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.
</dl>

<div class="impl">

<p><a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">Поддерживаемые индексы свойств</a> объекта
являются числами в диапазоне от нуля до одного меньше числа узлов,
<a href="#represented-by-the-collection">представленных в коллекции</a>. Если нет таких элементов, то
также нет <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">поддерживаемых индексов свойств</a>.

<p>Атрибут <dfn id="dom-nodelist-length" title="dom-NodeList-length"><code>length</code></dfn> должен возвратить количество узлов <a href="#represented-by-the-collection">представленных в коллекции</a>.

<p>Метод
<dfn id="dom-nodelist-item" title="dom-NodeList-item"><code>item(<var>index</var>)</code></dfn>
должен возвратить <var>index</var>-й
узел в <a href="#concept-collection" title="concept-collection">коллекции</a>. Если нет
<var>index</var>-го узла в <a href="#concept-collection" title="concept-collection">коллекции</a>, метод должен возвратить null.

</div>


<h5 id="interface-htmlcollection"><span class="secno">4.2.6.2 </span>Интерфейс <code><a href="#htmlcollection">HTMLCollection</a></code></h5>

<pre class="idl">[Exposed=Window]
interface <dfn id="htmlcollection">HTMLCollection</dfn> {
  readonly attribute unsigned long <a href="#dom-htmlcollection-length" title="dom-HTMLCollection-length">length</a>;
  getter <a href="#element">Element</a>? <a href="#dom-htmlcollection-item" title="dom-HTMLCollection-item">item</a>(unsigned long <var>index</var>);
  getter <a href="#element">Element</a>? <a href="#dom-htmlcollection-nameditem" title="dom-HTMLCollection-namedItem">namedItem</a>(DOMString <var>name</var>);
};</pre>

<p>Объект <code><a href="#htmlcollection">HTMLCollection</a></code> является
<a href="#concept-collection" title="concept-collection">коллекцией</a>
<a href="#concept-element" title="concept-element">элементов</a>.

<p class="note">Заметка: <code>Elements</code> являются лучшим решением для представления
<a href="#concept-collection" title="concept-collection">коллекций</a>
<a href="#concept-element" title="concept-element">элементов</a>. <code><a href="#htmlcollection">HTMLCollection</a></code> это исторический артефакт, от которого мы не можем избавить веб.

<dl class="domintro">
 <dt><var>collection</var> . <code title="dom-HTMLCollection-length"><a href="#dom-htmlcollection-length">length</a></code>
 <dd>
  <p>Возвращает количество <a href="#concept-element" title="concept-element">элементов</a> в
  <a href="#concept-collection" title="concept-collection">коллекции</a>.

 <dt><var>element</var> = <var>collection</var> . <code title="dom-HTMLCollection-item"><a href="#dom-htmlcollection-item">item</a></code>(<var>index</var>)
 <dt><var>element</var> = <var>collection</var>[<var>index</var>]
 <dd>
  <p>Возвращает <a href="#concept-element" title="concept-element">элемент</a> с индексом
  <var>index</var> из <a href="#concept-collection" title="concept-collection">коллекции</a>.
  <a href="#concept-element" title="concept-element">Элементы</a> отсортированы в <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

 <dt><var>element</var> = <var>collection</var> . <code title="dom-HTMLCollection-namedItem"><a href="#dom-htmlcollection-nameditem">namedItem</a></code>(<var>name</var>)
 <dt><var>element</var> = <var>collection</var>[<var>name</var>]
 <dd>
  <p>Возвращает первый <a href="#concept-element" title="concept-element">элемент</a> с <a href="#concept-id" title="concept-id">ID</a> или именем <var>name</var> из коллекции.
</dl>

<div class="impl">

<p><a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">Поддерживаемые индексы свойств</a> объекта
являются числами в диапазоне от ноля до одного меньше числа узлов
<a href="#represented-by-the-collection">представленных в коллекции</a>. Если нет таких элементов, то
нет <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">поддерживаемых индексов свойств</a>.

<p>Атрибут <dfn id="dom-htmlcollection-length" title="dom-HTMLCollection-length"><code>length</code></dfn> должен возвратить количество узлов <a href="#represented-by-the-collection">представленных в коллекции</a>.

<p>Метод
<dfn id="dom-htmlcollection-item" title="dom-HTMLCollection-item"><code>item(<var>index</var>)</code></dfn>
должен возвратить <var>index</var>-й
<a href="#concept-element" title="concept-element">элемент</a> в <a href="#concept-collection" title="concept-collection">коллекции</a>. Если нет
<var>index</var>-го <a href="#concept-element" title="concept-element">элемента</a> в <a href="#concept-collection" title="concept-collection">коллекции</a>, то метод должен возвратить null.

<p><a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-names">Поддерживаемые имена свойств</a>, все
<a class="external" rel="nofollow" target="_blank" data-anolis-spec="webidl" href="http://heycam.github.io/webidl/#dfn-unenumerable">не-числовые</a>, являются значениями из списка возвращенного следующими шагами:

<ol>
 <li><p>Сделать <var>result</var> пустой строкой.
 <li>
  <p>Для каждого <var>element</var>
  <a href="#represented-by-the-collection">представленного в коллекции</a>, в
  <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, выполнить следующие подшаги:
  <ol>
   <li><p>Если <var>element</var> имеет
   <a href="#concept-id" title="concept-id">ID</a>, которое не является пустой строкой и не
   в <var>result</var>, добавить <a href="#concept-id" title="concept-id">ID</a> <var>элемента</var> к <var>result</var>.

   <li><p>Если <var>element</var> в <a href="#html-namespace">пространстве имен HTML</a>
   и <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
   <a href="#concept-named-attribute" title="concept-named-attribute"><code>name</code> атрибут</a>,
   чье <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> не является пустой строкой и не в <var>result</var>, добавить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> <a href="#concept-named-attribute" title="concept-named-attribute"><code>name</code> атрибута</a>
   <var>элемента</var> к <var>result</var>.
  </ol>
 <li><p>Возвратить <var>result</var>.
</ol>

<p>Метод
<dfn id="dom-htmlcollection-nameditem" title="dom-HTMLCollection-namedItem"><code>namedItem(<var>key</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li>Если <var>key</var> является пустой строкой, возвратить null.</li>
 <li>
  <p>Возвратить первый <a href="#concept-element" title="concept-element">элемент</a> в
  <a href="#concept-collection" title="concept-collection">коллекции</a> для которой как минимум одно из следующего true:
  <ul>
   <li>он имеет <a href="#concept-id" title="concept-id">ID</a> которое является <var>key</var>.
   <li>он <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
   <a href="#concept-named-attribute" title="concept-named-attribute"><code>name</code> атрибут</a>
   чье <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> является
   <var>key</var>;
  </ul>
  <p>или null если нет такого <a href="#concept-element" title="concept-element">элемента</a>.
</ol>

</div>



<h3 id="mutation-observers"><span class="secno">4.3 </span>Наблюдатели изменений (Mutation observers)</h3>

<p>Каждая
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#unit-of-related-similar-origin-browsing-contexts">единица связанного similar-origin browsing контекста</a> имеет
<dfn id="mutation-observer-compound-microtask-queued-flag">флаг постановки в очередь составной микрозадачи наблюдателя изменений</dfn> и ассоциированный список объектов
<code><a href="#mutationobserver">MutationObserver</a></code>, который изначально пуст.
<a href="#biblio-HTML">[HTML]</a>

<p>Чтобы <dfn id="queue-a-mutation-observer-compound-microtask">поставить в очередь составную микрозадачу наблюдателя изменений</dfn>, выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#mutation-observer-compound-microtask-queued-flag">флаг постановки в очередь составной микрозадачи наблюдателя изменений</a> установлен, прекратить эти шаги.

 <li><p>Установить <a href="#mutation-observer-compound-microtask-queued-flag">флаг постановки в очередь составной микрозадачи наблюдателя изменений</a>.

 <li><p><a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/webappapis.html#queue-a-microtask" title="queue a microtask">Поставить в очередь</a>
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/webappapis.html#compound-microtask">составную микрозадачу</a> к
 <a href="#notify-mutation-observers">уведомлению наблюдателей изменений</a>.
</ol>

<p>Чтобы <dfn id="notify-mutation-observers">уведомить наблюдатели изменений</dfn>, выполнить следующие шаги:

<ol>
 <li><p>Снять <a href="#mutation-observer-compound-microtask-queued-flag">флаг постановки в очередь составной микрозадачи наблюдателя изменений</a>.

 <li><p>Сделать <var>notify list</var> копией списка объектов <code><a href="#mutationobserver">MutationObserver</a></code>
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#unit-of-related-similar-origin-browsing-contexts">единицы связанного similar-origin browsing контекста</a>.

 <li>
  <p>Для каждого объекта <code><a href="#mutationobserver">MutationObserver</a></code> <var>mo</var>
  в <var>notify list</var>,
  <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/webappapis.html#execute-a-compound-microtask-subtask">выполнить подзадачу составной микрозадачи</a>, чтобы выполнить следующие шаги:
  <a href="#biblio-HTML">[HTML]</a>

  <ol>
   <li><p>Сделать <var>queue</var> копией <a href="#concept-mo-queue" title="concept-MO-queue">записи очереди</a> <var>mo</var>.

   <li><p>Очистить <a href="#concept-mo-queue" title="concept-MO-queue">запись очереди</a> <var>mo</var>.

   <li><p>Удалить все
   <a href="#transient-registered-observer" title="transient registered observer">переходные зарегистрированные наблюдатели</a>,
   чьи <b>observer</b> являются <var>mo</var>.

   <li><p>Если <var>queue</var> не является пустым, вызвать
   <a href="#concept-mo-callback" title="concept-MO-callback">приемник</a> <var>mo</var>
   с <var>queue</var> в качестве первого аргумента и
   <var>mo</var> (самим) в качестве второго аргумента, и
   <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-callback-this-value">передать это значение</a>. Если это выдает исключение,
   <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/webappapis.html#report-the-exception">уведомить об исключении</a>.
  </ol>
</ol>

<hr>

<p>Каждый <a href="#concept-node" title="concept-node">узел</a> имеет связанный список
<a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a>.
<!-- XXX also mention this in the <code>Node</code> section non-normatively? -->

<p><dfn id="registered-observer">Зарегистрированный наблюдатель</dfn> состоит из <b>наблюдателя</b> (объект
<code><a href="#mutationobserver">MutationObserver</a></code>) и <b>опций</b> (словарь
<code><a href="#mutationobserverinit">MutationObserverInit</a></code>).
<dfn id="transient-registered-observer">Переходный зарегистрированный наблюдатель</dfn> это конкретный тип
<a href="#registered-observer">зарегистрированного наблюдателя</a>, который имеет <b>source</b>, который является
<a href="#registered-observer">зарегистрированным наблюдателем</a>.


<h4 id="interface-mutationobserver"><span class="secno">4.3.1 </span>Интерфейс <code><a href="#mutationobserver">MutationObserver</a></code></h4>

<pre class="idl">[<a href="#dom-mutationobserver" title="dom-MutationObserver">Constructor</a>(<a href="#mutationcallback">MutationCallback</a> <var>callback</var>)]
interface <dfn id="mutationobserver">MutationObserver</dfn> {
  void <a href="#dom-mutationobserver-observe" title="dom-MutationObserver-observe">observe</a>(<a href="#node">Node</a> <var>target</var>, <a href="#mutationobserverinit">MutationObserverInit</a> <var>options</var>);
  void <a href="#dom-mutationobserver-disconnect" title="dom-MutationObserver-disconnect">disconnect</a>();
  sequence&lt;<a href="#mutationrecord">MutationRecord</a>&gt; <a href="#dom-mutationobserver-takerecords" title="dom-MutationObserver-takeRecords">takeRecords</a>();
};

callback <dfn id="mutationcallback">MutationCallback</dfn> = void (sequence&lt;<a href="#mutationrecord">MutationRecord</a>&gt; <var>mutations</var>, <a href="#mutationobserver">MutationObserver</a> <var>observer</var>);

dictionary <dfn id="mutationobserverinit">MutationObserverInit</dfn> {
  boolean <span title="dom-MutationObserverInit-childList">childList</span> = false;
  boolean <span title="dom-MutationObserverInit-attributes">attributes</span>;
  boolean <span title="dom-MutationObserverInit-characterData">characterData</span>;
  boolean <span title="dom-MutationObserverInit-subtree">subtree</span> = false;
  boolean <span title="dom-MutationObserverInit-attributeOldValue">attributeOldValue</span>;
  boolean <span title="dom-MutationObserverInit-characterDataOldValue">characterDataOldValue</span>;
  sequence&lt;DOMString&gt; <span title="dom-MutationObserverInit-attributeFilter">attributeFilter</span>;
};</pre>

<p>Объект <code><a href="#mutationobserver">MutationObserver</a></code> может использоваться для наблюдения изменений
в <a href="#concept-tree" title="concept-tree">дереве</a>
<a href="#concept-node" title="concept-node">узлов</a>.

<p>Каждый объект <code><a href="#mutationobserver">MutationObserver</a></code> имеет ассоциированные контексты:
<ul>
 <li><p><dfn id="concept-mo-callback" title="concept-MO-callback">Приемник</dfn> устанавливается при создании.
 <li><p>Список <a href="#concept-node" title="concept-node">узлов</a> на котором <b>наблюдатель</b> <a href="#registered-observer">зарегистрированного наблюдателя</a>, который изначально пуст.
 <li><p>Список объектов <code><a href="#mutationrecord">MutationRecord</a></code> вызвавший
 <dfn id="concept-mo-queue" title="concept-MO-queue">запись очереди</dfn>, который изначально пуст.
</ul>

<dl class="domintro">
 <dt><code><var>observer</var> = new <a href="#dom-mutationobserver" title="dom-MutationObserver">MutationObserver</a>(<var>callback</var>)</code>
 <dd><p>Конструирует объект <code><a href="#mutationobserver">MutationObserver</a></code> и устанавливает его
 <a href="#concept-mo-callback" title="concept-MO-callback">приемник</a> к
 <var>callback</var>. <var>callback</var> вызывается с объектами
 списка <code><a href="#mutationrecord">MutationRecord</a></code> в качестве первого аргумента, и
 построенным объектом <code><a href="#mutationobserver">MutationObserver</a></code> в качестве второго аргумента. Он
 вызывается после <a href="#concept-node" title="concept-node">узлов</a> зарегистрированных с методом
 <code title="dom-MutationObserver-observe"><a href="#dom-mutationobserver-observe">observe()</a></code>, подверженных изменениям.

 <dt><code><var>observer</var> . <a href="#dom-mutationobserver-observe" title="dom-MutationObserver-observe">observe</a>(<var>target</var>, <var>options</var>)</code>
 <dd>
  <p>Поручает агенту пользователя наблюдать заданный <var>target</var>
  (<a href="#concept-node" title="concept-node">узел</a>) и сообщать о любых изменениях на основе
  критериев заданных <var>options</var> (объект).

  <p>Аргумент <var>options</var> позволяет устанавливать параметры наблюдения изменений с помощью членов объекта. Это аргументы объекта, которые могут использоваться:

  <dl>
   <dt><code title="dom-MutationObserverInit-childList">childList</code>
   <dd><p>Устанавливается к true если изменения <a href="#concept-tree-child" title="concept-tree-child">дочерних</a> <var>target</var> должны наблюдаться.

   <dt><code title="dom-MutationObserverInit-attributes">attributes</code>
   <dd><p>Устанавливается к true если изменения <a href="#concept-attribute" title="concept-attribute">атрибутов</a> <var>target</var> должны наблюдаться. Может быть опущен если
   <code title="dom-MutationObserverInit-attributeOldValue">attributeOldValue</code> и/или
   <code title="dom-MutationObserverInit-attributeFilter">attributeFilter</code> заданы.

   <dt><code title="dom-MutationObserverInit-characterData">characterData</code>
   <dd><p>Устанавливается к true если изменения <a href="#concept-cd-data" title="concept-CD-data">данных</a> <var>target</var> должны наблюдаться. Может быть опущен если
   <code title="dom-MutationObserverInit-characterDataOldValue">characterDataOldValue</code> задан.

   <dt><code title="dom-MutationObserverInit-subtree">subtree</code>
   <dd><p>Устанавливается к true если изменения не только <var>target</var>, но
   также <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a> <var>target</var> должны наблюдаться.

   <dt><code title="dom-MutationObserverInit-attributeOldValue">attributeOldValue</code>
   <dd><p>Устанавливается к true если
   <code title="dom-MutationObserverInit-attributes">attributes</code> является true или опущены,
   и <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> <a href="#concept-attribute" title="concept-attribute">атрибута</a> <var>target</var> перед изменением должно быть записано.

   <dt><code title="dom-MutationObserverInit-characterDataOldValue">characterDataOldValue</code>
   <dd><p>Устанавливается к true если
   <code title="dom-MutationObserverInit-characterData">characterData</code>
   установлен к true или опущен, и <a href="#concept-cd-data" title="concept-CD-data">данные</a> <var>target</var> перед изменением должны быть записаны.

   <dt><code title="dom-MutationObserverInit-attributeFilter">attributeFilter</code>
   <dd><p>Устанавливается к списку <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальных имен</a> <a href="#concept-attribute" title="concept-attribute">атрибутов</a> (без
   <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространства имен</a>) если не все
   изменения <a href="#concept-attribute" title="concept-attribute">атрибута</a> должны наблюдаться, и <code title="dom-MutationObserverInit-attributes">attributes</code> является true или опущены.
  </dl>

 <dt><code><var>observer</var> . <a href="#dom-mutationobserver-disconnect" title="dom-MutationObserver-disconnect">disconnect</a>()</code>
 <dd><p>Останавливает <var>observer</var> от наблюдения любых изменений.
 Пока метод <code title="dom-MutationObserver-observe"><a href="#dom-mutationobserver-observe">observe()</a></code> не используется снова, <a href="#concept-mo-callback" title="concept-MO-callback">приемник</a> <var>observer</var>-а не будет вызван.

 <dt><code><var>observer</var> . <a href="#dom-mutationobserver-takerecords" title="dom-MutationObserver-takeRecords">takeRecords</a>()</code>
 <dd><p>Очищает <a href="#concept-mo-queue" title="concept-MO-queue">запись очереди</a> и возвращает то что там было.
</dl>

<p>Конструктор
<dfn id="dom-mutationobserver" title="dom-MutationObserver"><code>MutationObserver(<var>callback</var>)</code></dfn>
должен создать новый объект <code><a href="#mutationobserver">MutationObserver</a></code> с
<a href="#concept-mo-callback" title="concept-MO-callback">приемником</a> установленным к <var>callback</var>,
добавить его к списку объектов <code><a href="#mutationobserver">MutationObserver</a></code>
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#unit-of-related-similar-origin-browsing-contexts">единиц связанных similar-origin browsing контекста</a>, и затем возвратить их.

<p>Метод
<dfn id="dom-mutationobserver-observe" title="dom-MutationObserver-observe"><code>observe(<var>target</var>, <var>options</var>)</code></dfn>, когда вызван, должен выполнить следующие шаги:

<ol>
 <li><p>Если <code title="dom-MutationObserverInit-attributeOldValue">attributeOldValue</code> или <code title="dom-MutationObserverInit-attributeFilter">attributeFilter</code> <var>options</var> представлены и <var>options</var>
 <code title="dom-MutationObserverInit-attributes">attributes</code> опущены, установить
 <var>options</var> <code title="dom-MutationObserverInit-attributes">attributes</code> к true.

 <li><p>Если <code title="dom-MutationObserverInit-characterDataOldValue">characterDataOldValue</code> <var>options</var>
 представлен и <var>options</var>
 <code title="dom-MutationObserverInit-characterData">characterData</code> опущен, установить
 <var>options</var>
 <code title="dom-MutationObserverInit-characterData">characterData</code> к true.

 <li><p>Если ни один из <var>options</var>
 <code title="dom-MutationObserverInit-childList">childList</code>
 <code title="dom-MutationObserverInit-attributes">attributes</code> и
 <code title="dom-MutationObserverInit-characterData">characterData</code> не является true,
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдать</a> исключение <code>TypeError</code>.

 <li><p>Если <var>options</var>
 <code title="dom-MutationObserverInit-attributeOldValue">attributeOldValue</code> является true
 и <var>options</var>
 <code title="dom-MutationObserverInit-attributes">attributes</code> является false,
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдать</a> исключение JavaScript <code>TypeError</code>.

 <li><p>Если <var>options</var>
 <code title="dom-MutationObserverInit-attributeFilter">attributeFilter</code> представлен
 и <var>options</var>
 <code title="dom-MutationObserverInit-attributes">attributes</code> является false,
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдать</a> JavaScript <code>TypeError</code>.

 <li><p>Если <var>options</var>
 <code title="dom-MutationObserverInit-characterDataOldValue">characterDataOldValue</code>
 является true и <var>options</var>
 <code title="dom-MutationObserverInit-characterData">characterData</code> является false,
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-throw">выдать</a> JavaScript <code>TypeError</code>.

 <li>
  <p>Для каждого <a href="#registered-observer">зарегистрированного наблюдателя</a> <var>registered</var> в списке <a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a> <var>target</var>, чьи <b>observer</b> являются <a href="#context-object">объектами контекста</a>:

  <ol>
   <li><p>Удалить все
   <a href="#transient-registered-observer" title="transient registered observer">переходные зарегистрированные наблюдатели</a>, чьи
   <b>source</b> являются <var>registered</var>.

   <li><p>Заменить <b>опции</b> <var>registered</var> на
   <var>options</var>.
  </ol>

 <li><p>В другом случае, добавить новый <a href="#registered-observer">зарегистрированный наблюдатель</a> к списку
 <a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a> <var>target</var> на
 <a href="#context-object">объект контекста</a> как <b>наблюдатель</b> и <var>options</var> как <b>опции</b>,
 и добавить <var>target</var> к списку <a href="#concept-node" title="concept-node">узлов</a> <a href="#context-object">объекта контекста</a> на котором он зарегистрирован.
</ol>

<p>Метод
<dfn id="dom-mutationobserver-disconnect" title="dom-MutationObserver-disconnect"><code>disconnect()</code></dfn>
должен, для каждого <a href="#concept-node" title="concept-node">узла</a>
<var>node</var> в списке <a href="#concept-node" title="concept-node">узлов</a> <a href="#context-object">объекта контекста</a>, удалить любые
<a href="#registered-observer">зарегистрированные наблюдатели</a> на <var>node</var>
для которых <a href="#context-object">объект контекста</a> является <b>observer</b>, и также
очистить <a href="#concept-mo-queue" title="concept-MO-queue">очередь записи</a> <a href="#context-object">объекта контекста</a>.

<p>Метод
<dfn id="dom-mutationobserver-takerecords" title="dom-MutationObserver-takeRecords"><code>takeRecords()</code></dfn>
должен возвратить копию
<a href="#concept-mo-queue" title="concept-MO-queue">очереди записи</a> и затем очистить
<a href="#concept-mo-queue" title="concept-MO-queue">очередь записи</a>.


<h4 id="queuing-a-mutation-record"><span class="secno">4.3.2 </span>Очередь записи изменений</h4>

<p>Чтобы <dfn id="queue-a-mutation-record">поставить в очередь запись изменения</dfn> <var>type</var> для
<var>target</var> с одним или более (зависит от
<var>type</var>) именем <var>name</var>, пространством имен
<var>namespace</var>, oldValue <var>oldValue</var>, addedNodes
<var>addedNodes</var>, removedNodes <var>removedNodes</var>,
previousSibling <var>previousSibling</var> и nextSibling
<var>nextSibling</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>interested observers</var> изначально пустым набором
 объектов <code><a href="#mutationobserver">MutationObserver</a></code> опционально в паре со строкой.

 <li><p>Сделать <var>nodes</var>
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительными предками</a> для
 <var>target</var>.

 <li>
  <p>Затем, для каждого <var>node</var> в <var>nodes</var>, и
  затем для каждого <var>registered observer</var> (с
  <b>опциями</b> <var>registered observer</var> как
  <var>options</var>) в списке <a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a> <var>node</var>:

  <ol>
   <li><p>Если <var>node</var> не является <var>target</var> и
   <code>subtree</code> <var>options</var>-й является false, то продолжить.

   <li><p>Если <var>type</var> является "<code>attributes</code>" и
   <code>attributes</code> <var>options</var>-й не является true, то продолжить.
   <!--not true==false||omitted-->

   <li><p>Если <var>type</var> является "<code>attributes</code>",
   <code>attributeFilter</code> <var>options</var>-й представлен, и
   <code>attributeFilter</code> <var>options</var>-й не содержит
   <var>name</var> или <var>namespace</var> является не-null, то продолжить.

   <li><p>Если <var>type</var> является "<code>characterData</code>" и
   <code>characterData</code> <var>options</var>-й не является true, то продолжить.
   <!--not true==false||omitted-->

   <li><p>Если <var>type</var> является "<code>childList</code>" и
   <code>childList</code> <var>options</var>-й является false, продолжить.

   <li><p>Если <b>наблюдатель</b> <var>registered observer</var>
   не в <var>interested observers</var>, добавить <b>observer</b>
   <var>registered observer</var>-а к
   <var>interested observers</var>.

   <li><p>Если <var>type</var> является "<code>attributes</code>"
   и <code>attributeOldValue</code> <var>options</var>-й является true, или
   <var>type</var> является "<code>characterData</code>" и
   <code>characterDataOldValue</code> <var>options</var>-й является true,
   установить парную строку <b>наблюдателя</b>
   <var>registered observer</var>-а в
   <var>interested observers</var> к <var>oldValue</var>.
  </ol>

 <li>
  <p>Затем, для каждого <var>observer</var> в
  <var>interested observers</var>:

  <ol>
   <li><p>Сделать <var>record</var> новым объектом <code><a href="#mutationrecord">MutationRecord</a></code>
   с его <code title="dom-MutationRecord-type"><a href="#dom-mutationrecord-type">type</a></code> установленным к
   <var>type</var> и
   <code title="dom-MutationRecord-target"><a href="#dom-mutationrecord-target">target</a></code> установленным к
   <var>target</var>.

   <li><p>Если <var>name</var> и <var>namespace</var> заданы,
   установить <code title="dom-MutationRecord-attributeName"><a href="#dom-mutationrecord-attributename">attributeName</a></code> <var>record</var>-а к
   <var>name</var>, и <code title="dom-MutationRecord-attributeNamespace"><a href="#dom-mutationrecord-attributenamespace">attributeNamespace</a></code> <var>record</var>-а
   к <var>namespace</var>.

   <li><p>Если <var>addedNodes</var> задан, установить <code title="dom-MutationRecord-addedNodes"><a href="#dom-mutationrecord-addednodes">addedNodes</a></code> <var>record</var>-а к
   <var>addedNodes</var>.

   <li><p>Если <var>removedNodes</var> задан, установить <code title="dom-MutationRecord-removedNodes"><a href="#dom-mutationrecord-removednodes">removedNodes</a></code> <var>record</var>-а к
   <var>removedNodes</var>,

   <li><p>Если <var>previousSibling</var> задан, установить <code title="dom-MutationRecord-previousSibling"><a href="#dom-mutationrecord-previoussibling">previousSibling</a></code> <var>record</var>-а к
   <var>previousSibling</var>.

   <li><p>Если <var>nextSibling</var> задан, установить <code title="dom-MutationRecord-nextSibling"><a href="#dom-mutationrecord-nextsibling">nextSibling</a></code> <var>record</var>-а к
   <var>nextSibling</var>.

   <li><p>Если <var>observer</var> имеет парную строку,
   установить <code title="dom-MutationRecord-oldValue"><a href="#dom-mutationrecord-oldvalue">oldValue</a></code> <var>record</var>-а
   к парной строке <var>observer</var>-а.

   <li><p>Добавить <var>record</var> к <a href="#concept-mo-queue" title="concept-MO-queue">очереди записи</a> <var>observer</var>-а.
  </ol>

 <li><p><a href="#queue-a-mutation-observer-compound-microtask">Поставить в очередь составную микрозадачу наблюдателя изменений</a>.
</ol>


<h4 id="interface-mutationrecord"><span class="secno">4.3.3 </span>Интерфейс <code><a href="#mutationrecord">MutationRecord</a></code></h4>

<pre class="idl">[Exposed=Window]
interface <dfn id="mutationrecord">MutationRecord</dfn> {
  readonly attribute DOMString <a href="#dom-mutationrecord-type" title="dom-MutationRecord-type">type</a>;
  readonly attribute <a href="#node">Node</a> <a href="#dom-mutationrecord-target" title="dom-MutationRecord-target">target</a>;
  [SameObject] readonly attribute <a href="#nodelist">NodeList</a> <a href="#dom-mutationrecord-addednodes" title="dom-MutationRecord-addedNodes">addedNodes</a>;
  [SameObject] readonly attribute <a href="#nodelist">NodeList</a> <a href="#dom-mutationrecord-removednodes" title="dom-MutationRecord-removedNodes">removedNodes</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-mutationrecord-previoussibling" title="dom-MutationRecord-previousSibling">previousSibling</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-mutationrecord-nextsibling" title="dom-MutationRecord-nextSibling">nextSibling</a>;
  readonly attribute DOMString? <a href="#dom-mutationrecord-attributename" title="dom-MutationRecord-attributeName">attributeName</a>;
  readonly attribute DOMString? <a href="#dom-mutationrecord-attributenamespace" title="dom-MutationRecord-attributeNamespace">attributeNamespace</a>;
  readonly attribute DOMString? <a href="#dom-mutationrecord-oldvalue" title="dom-MutationRecord-oldValue">oldValue</a>;
};</pre>

<dl class="domintro">
 <dt><code><var>record</var> . <a href="#dom-mutationrecord-type" title="dom-MutationRecord-type">type</a></code>
 <dd><p>Возвращает "<code>attributes</code>" если это было изменение
 <a href="#concept-attribute" title="concept-attribute">атрибута</a>.
 "<code>characterData</code>" если это было изменение
 <code><a href="#characterdata">CharacterData</a></code> <a href="#concept-node" title="concept-node">узла</a>. И
 "<code>childList</code>" если это было изменение
 <a href="#concept-tree" title="concept-tree">дерева</a>
 <a href="#concept-node" title="concept-node">узлов</a>.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-target" title="dom-MutationRecord-target">target</a></code>
 <dd><p>Возвращает <a href="#concept-node" title="concept-node">узел</a> который изменение затронуло, основываясь на <code title="dom-MutationRecord-type"><a href="#dom-mutationrecord-type">type</a></code>.
 Для "<code>attributes</code>", это
 <a href="#concept-element" title="concept-element">элемент</a> чей
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> был изменен. Для
 "<code>characterData</code>", это <code><a href="#characterdata">CharacterData</a></code>
 <a href="#concept-node" title="concept-node">узел</a>. Для "<code>childList</code>",
 это  <a href="#concept-node" title="concept-node">узел</a> чей
 <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> был изменен.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-addednodes" title="dom-MutationRecord-addedNodes">addedNodes</a></code>
 <dt><code><var>record</var> . <a href="#dom-mutationrecord-removednodes" title="dom-MutationRecord-removedNodes">removedNodes</a></code>
 <dd><p>Возвращает добавленные и удаленные <a href="#concept-node" title="concept-node">узлы</a> соответственно.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-previoussibling" title="dom-MutationRecord-previousSibling">previousSibling</a></code>
 <dt><code><var>record</var> . <a href="#dom-mutationrecord-nextsibling" title="dom-MutationRecord-nextSibling">nextSibling</a></code>
 <dd><p>Возвращает <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущий</a>
 и <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующий сестринский</a> добавленных и удаленных <a href="#concept-node" title="concept-node">узлов</a> соответственно, и null в другом случае.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-attributename" title="dom-MutationRecord-attributeName">attributeName</a></code>
 <dd><p>Возвращает
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a>
 измененного <a href="#concept-attribute" title="concept-attribute">атрибута</a>, и null в другом случае.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-attributenamespace" title="dom-MutationRecord-attributeNamespace">attributeNamespace</a></code>
 <dd><p>Возвращает <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> измененного <a href="#concept-attribute" title="concept-attribute">атрибута</a>, и null в другом случае.

 <dt><code><var>record</var> . <a href="#dom-mutationrecord-oldvalue" title="dom-MutationRecord-oldValue">oldValue</a></code>
 <dd><p>Возвращаемое значение зависит от
 <code title="dom-MutationRecord-type"><a href="#dom-mutationrecord-type">type</a></code>. Для
 "<code>attributes</code>", это
 <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> измененного <a href="#concept-attribute" title="concept-attribute">атрибута</a> перед изменением.
 Для "<code>characterData</code>", это
 <a href="#concept-cd-data" title="concept-CD-data">данные</a> измененного
 <a href="#concept-node" title="concept-node">узла</a> перед изменением. Для
 "<code>childList</code>", это null.
</dl>

<p>Атрибуты <dfn id="dom-mutationrecord-type" title="dom-MutationRecord-type"><code>type</code></dfn> и
<dfn id="dom-mutationrecord-target" title="dom-MutationRecord-target"><code>target</code></dfn>
должны возвращать значения к которым были инициализированы.

<p>Атрибуты
<dfn id="dom-mutationrecord-addednodes" title="dom-MutationRecord-addedNodes"><code>addedNodes</code></dfn> и
<dfn id="dom-mutationrecord-removednodes" title="dom-MutationRecord-removedNodes"><code>removedNodes</code></dfn>
должны возвращать значения к которым были инициализированы. Если не задано другое, когда объект <code><a href="#mutationrecord">MutationRecord</a></code> создан, они оба должны
быть инициализированы к пустому <code><a href="#nodelist">NodeList</a></code>.

<p>Атрибуты
<dfn id="dom-mutationrecord-previoussibling" title="dom-MutationRecord-previousSibling"><code>previousSibling</code></dfn>,
<dfn id="dom-mutationrecord-nextsibling" title="dom-MutationRecord-nextSibling"><code>nextSibling</code></dfn>,
<dfn id="dom-mutationrecord-attributename" title="dom-MutationRecord-attributeName"><code>attributeName</code></dfn>,
<dfn id="dom-mutationrecord-attributenamespace" title="dom-MutationRecord-attributeNamespace"><code>attributeNamespace</code></dfn> и
<dfn id="dom-mutationrecord-oldvalue" title="dom-MutationRecord-oldValue"><code>oldValue</code></dfn>
должны возвращать значения к которым были инициализированы. Если не указано иное, когда объект <code><a href="#mutationrecord">MutationRecord</a></code> создан, они должны быть инициализированы к null.

<h4 id="garbage-collection"><span class="secno">4.3.4 </span>Сборка мусора</h4>

<p><a href="#concept-node" title="concept-node">Узлы</a> имеют сильное отношение к
<a href="#registered-observer" title="registered observer">зарегистрированным наблюдателям</a> в их
списке <a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a>.

<p><a href="#registered-observer" title="registered observer">Зарегистрированные наблюдатели</a> в списке
<a href="#registered-observer" title="registered observer">зарегистрированных наблюдателей</a> <a href="#concept-node" title="concept-node">узла</a> имеют слабое отношение к <a href="#concept-node" title="concept-node">узлу</a>.


<h3 id="interface-node"><span class="secno">4.4 </span>Интерфейс <code><a href="#node">Node</a></code></h3>
<pre class="idl">[Exposed=Window]
interface <dfn id="node">Node</dfn> : <a href="#eventtarget">EventTarget</a> {
  const unsigned short <a href="#dom-node-element_node" title="dom-Node-ELEMENT_NODE">ELEMENT_NODE</a> = 1;
  const unsigned short <span title="dom-Node-ATTRIBUTE_NODE">ATTRIBUTE_NODE</span> = 2; // historical
  const unsigned short <a href="#dom-node-text_node" title="dom-Node-TEXT_NODE">TEXT_NODE</a> = 3;
  const unsigned short <span title="dom-Node-CDATA_SECTION_NODE">CDATA_SECTION_NODE</span> = 4; // historical
  const unsigned short <span title="dom-Node-ENTITY_REFERENCE_NODE">ENTITY_REFERENCE_NODE</span> = 5; // historical
  const unsigned short <span title="dom-Node-ENTITY_NODE">ENTITY_NODE</span> = 6; // historical
  const unsigned short <a href="#dom-node-processing_instruction_node" title="dom-Node-PROCESSING_INSTRUCTION_NODE">PROCESSING_INSTRUCTION_NODE</a> = 7;
  const unsigned short <a href="#dom-node-comment_node" title="dom-Node-COMMENT_NODE">COMMENT_NODE</a> = 8;
  const unsigned short <a href="#dom-node-document_node" title="dom-Node-DOCUMENT_NODE">DOCUMENT_NODE</a> = 9;
  const unsigned short <a href="#dom-node-document_type_node" title="dom-Node-DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE</a> = 10;
  const unsigned short <a href="#dom-node-document_fragment_node" title="dom-Node-DOCUMENT_FRAGMENT_NODE">DOCUMENT_FRAGMENT_NODE</a> = 11;
  const unsigned short <span title="dom-Node-NOTATION_NODE">NOTATION_NODE</span> = 12; // historical
  readonly attribute unsigned short <a href="#dom-node-nodetype" title="dom-Node-nodeType">nodeType</a>;<!-- NodeExodus

  readonly attribute DOMString <span title=dom-Node-namespaceURI>namespaceURI</span>;
  readonly attribute DOMString <span title=dom-Node-prefix>prefix</span>;
  readonly attribute DOMString <span title=dom-Node-localName>localName</span>;-->
  readonly attribute DOMString <a href="#dom-node-nodename" title="dom-Node-nodeName">nodeName</a>;

  readonly attribute DOMString? <a href="#dom-node-baseuri" title="dom-Node-baseURI">baseURI</a>;

  <!--AttrExodus
  boolean <span title=dom-Node-hasAttributes>hasAttributes</span>();
  readonly attribute <span>NamedNodeMap</span> <span title=dom-Node-attributes>attributes</span>;

  -->readonly attribute <a href="#document">Document</a>? <a href="#dom-node-ownerdocument" title="dom-Node-ownerDocument">ownerDocument</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-node-parentnode" title="dom-Node-parentNode">parentNode</a>;
  readonly attribute <a href="#element">Element</a>? <a href="#dom-node-parentelement" title="dom-Node-parentElement">parentElement</a>;
  boolean <a href="#dom-node-haschildnodes" title="dom-Node-hasChildNodes">hasChildNodes</a>();
  [SameObject] readonly attribute <a href="#nodelist">NodeList</a> <a href="#dom-node-childnodes" title="dom-Node-childNodes">childNodes</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-node-firstchild" title="dom-Node-firstChild">firstChild</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-node-lastchild" title="dom-Node-lastChild">lastChild</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-node-previoussibling" title="dom-Node-previousSibling">previousSibling</a>;
  readonly attribute <a href="#node">Node</a>? <a href="#dom-node-nextsibling" title="dom-Node-nextSibling">nextSibling</a>;

           attribute DOMString? <a href="#dom-node-nodevalue" title="dom-Node-nodeValue">nodeValue</a>;
           attribute DOMString? <a href="#dom-node-textcontent" title="dom-Node-textContent">textContent</a>;
  void <a href="#dom-node-normalize" title="dom-Node-normalize">normalize</a>();

  [NewObject] <a href="#node">Node</a> <a href="#dom-node-clonenode" title="dom-Node-cloneNode">cloneNode</a>(optional boolean <var>deep</var> = false);
  boolean <a href="#dom-node-isequalnode" title="dom-Node-isEqualNode">isEqualNode</a>(<a href="#node">Node</a>? <var>node</var>);

  const unsigned short <a href="#dom-node-document_position_disconnected" title="dom-Node-DOCUMENT_POSITION_DISCONNECTED">DOCUMENT_POSITION_DISCONNECTED</a> = 0x01;
  const unsigned short <a href="#dom-node-document_position_preceding" title="dom-Node-DOCUMENT_POSITION_PRECEDING">DOCUMENT_POSITION_PRECEDING</a> = 0x02;
  const unsigned short <a href="#dom-node-document_position_following" title="dom-Node-DOCUMENT_POSITION_FOLLOWING">DOCUMENT_POSITION_FOLLOWING</a> = 0x04;
  const unsigned short <a href="#dom-node-document_position_contains" title="dom-Node-DOCUMENT_POSITION_CONTAINS">DOCUMENT_POSITION_CONTAINS</a> = 0x08;
  const unsigned short <a href="#dom-node-document_position_contained_by" title="dom-Node-DOCUMENT_POSITION_CONTAINED_BY">DOCUMENT_POSITION_CONTAINED_BY</a> = 0x10;
  const unsigned short <a href="#dom-node-document_position_implementation_specific" title="dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</a> = 0x20;
  unsigned short <a href="#dom-node-comparedocumentposition" title="dom-Node-compareDocumentPosition">compareDocumentPosition</a>(<a href="#node">Node</a> <var>other</var>);
  boolean <a href="#dom-node-contains" title="dom-Node-contains">contains</a>(<a href="#node">Node</a>? <var>other</var>);

  DOMString? <a href="#dom-node-lookupprefix" title="dom-Node-lookupPrefix">lookupPrefix</a>(DOMString? <var>namespace</var>);
  DOMString? <a href="#dom-node-lookupnamespaceuri" title="dom-Node-lookupNamespaceURI">lookupNamespaceURI</a>(DOMString? <var>prefix</var>);
  boolean <a href="#dom-node-isdefaultnamespace" title="dom-Node-isDefaultNamespace">isDefaultNamespace</a>(DOMString? <var>namespace</var>);

  <a href="#node">Node</a> <a href="#dom-node-insertbefore" title="dom-Node-insertBefore">insertBefore</a>(<a href="#node">Node</a> <var>node</var>, <a href="#node">Node</a>? <var>child</var>);
  <a href="#node">Node</a> <a href="#dom-node-appendchild" title="dom-Node-appendChild">appendChild</a>(<a href="#node">Node</a> <var>node</var>);
  <a href="#node">Node</a> <a href="#dom-node-replacechild" title="dom-Node-replaceChild">replaceChild</a>(<a href="#node">Node</a> <var>node</var>, <a href="#node">Node</a> <var>child</var>);
  <a href="#node">Node</a> <a href="#dom-node-removechild" title="dom-Node-removeChild">removeChild</a>(<a href="#node">Node</a> <var>child</var>);
};</pre>

<p class="note">Заметка: <code><a href="#node">Node</a></code> является абстрактным интерфейсом и не существует как <a href="#concept-node" title="concept-node">узел</a>. Он используется всеми
<a href="#concept-node" title="concept-node">узлами</a> (<code><a href="#document">Document</a></code>,
<code><a href="#documentfragment">DocumentFragment</a></code>, <code><a href="#documenttype">DocumentType</a></code>,
<code><a href="#element">Element</a></code>, <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> и <code><a href="#comment">Comment</a></code>).

<p>Каждый <a href="#concept-node" title="concept-node">узел</a> имеет ассоциированный
<dfn id="concept-node-document" title="concept-node-document">документ узла</dfn>, установленный при создании,
который является <a href="#concept-document" title="concept-document">документом</a>.

<p class="note">Заметка: <a href="#concept-node-document" title="concept-node-document">Документ узла</a> <a href="#concept-node" title="concept-node">узла</a> может быть изменен с помощью алгоритма <a href="#concept-node-adopt" title="concept-node-adopt">принятия</a>.

<p>Каждый <a href="#concept-node" title="concept-node">узел</a> также имеет ассоциированный
<dfn id="concept-node-base-url" title="concept-node-base-url">базовый URL</dfn>.

<p class="note">Заметка: Другие спецификации определяют значение
<a href="#concept-node-base-url" title="concept-node-base-url">базового URL</a> и его наблюдаемое поведение. Эта спецификация определяет только концепт и атрибут
<code title="dom-Node-baseURI"><a href="#dom-node-baseuri">baseURI</a></code>.

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-nodetype" title="dom-Node-nodeType">nodeType</a></code>
 <dd>
  <p>Возвращает тип <var>node</var>, представленный числом из списка ниже:</p>

  <dl>
   <dt><code><a href="#node">Node</a> . <a href="#dom-node-element_node" title="dom-Node-ELEMENT_NODE">ELEMENT_NODE</a></code> (1)
   <dd><var>node</var> является
   <a href="#concept-element" title="concept-element">элементом</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-text_node" title="dom-Node-TEXT_NODE">TEXT_NODE</a></code> (3)
   <dd><var>node</var> является <code><a href="#text">Text</a></code>
   <a href="#concept-node" title="concept-node">узлом</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-processing_instruction_node" title="dom-Node-PROCESSING_INSTRUCTION_NODE">PROCESSING_INSTRUCTION_NODE</a></code> (7)
   <dd><var>node</var> является <code><a href="#processinginstruction">ProcessingInstruction</a></code>
   <a href="#concept-node" title="concept-node">узлом</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-comment_node" title="dom-Node-COMMENT_NODE">COMMENT_NODE</a></code> (8)
   <dd><var>node</var> является <code><a href="#comment">Comment</a></code>
   <a href="#concept-node" title="concept-node">узлом</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_node" title="dom-Node-DOCUMENT_NODE">DOCUMENT_NODE</a></code> (9)
   <dd><var>node</var> является
   <a href="#concept-document" title="concept-document">документом</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_type_node" title="dom-Node-DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE</a></code> (10)
   <dd><var>node</var> является
   <a href="#concept-doctype" title="concept-doctype">типом документа</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_fragment_node" title="dom-Node-DOCUMENT_FRAGMENT_NODE">DOCUMENT_FRAGMENT_NODE</a></code> (11)
   <dd><var>node</var> является <code><a href="#documentfragment">DocumentFragment</a></code>
   <a href="#concept-node" title="concept-node">узлом</a>.
  </dl>

 <dt><code><var>node</var> . <a href="#dom-node-nodename" title="dom-Node-nodeName">nodeName</a></code>
 <dd>
  <p>Возвращает строку соответствующую для типа <var>node</var>, а именно:

  <dl>
   <dt><code><a href="#element">Element</a></code>
   <dd>Его значение атрибута <code title="dom-Element-tagName"><a href="#dom-element-tagname">tagName</a></code>.

   <dt><code><a href="#text">Text</a></code>
   <dd>"<code>#text</code>".

   <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
   <dd>Его <a href="#concept-pi-target" title="concept-PI-target">цель</a>.

   <dt><code><a href="#comment">Comment</a></code>
   <dd>"<code>#comment</code>".

   <dt><code><a href="#document">Document</a></code>
   <dd>"<code>#document</code>".

   <dt><code><a href="#documenttype">DocumentType</a></code>
   <dd>Его <a href="#concept-doctype-name" title="concept-doctype-name">имя</a>.

   <dt><code><a href="#documentfragment">DocumentFragment</a></code>
   <dd>"<code>#document-fragment</code>".
  </dl>
</dl>

<p>Атрибут <dfn id="dom-node-nodetype" title="dom-Node-nodeType"><code>nodeType</code></dfn> должен возвратить тип узла, который должен быть одним из следующих:

<ul>
 <li><dfn id="dom-node-element_node" title="dom-Node-ELEMENT_NODE"><code>ELEMENT_NODE</code></dfn> (1);

 <!--AttrExodus
 <li><dfn title=dom-Node-ATTRIBUTE_NODE><code>ATTRIBUTE_NODE</code></dfn> (2, historical);
 -->

 <li><dfn id="dom-node-text_node" title="dom-Node-TEXT_NODE"><code>TEXT_NODE</code></dfn> (3);

 <!-- XXX still questionable
 <li><dfn title=dom-Node-CDATA_SECTION_NODE><code>CDATA_SECTION_NODE</code></dfn> (4, historical);
 -->

 <li><dfn id="dom-node-processing_instruction_node" title="dom-Node-PROCESSING_INSTRUCTION_NODE"><code>PROCESSING_INSTRUCTION_NODE</code></dfn> (7);

 <li><dfn id="dom-node-comment_node" title="dom-Node-COMMENT_NODE"><code>COMMENT_NODE</code></dfn> (8);

 <li><dfn id="dom-node-document_node" title="dom-Node-DOCUMENT_NODE"><code>DOCUMENT_NODE</code></dfn> (9);

 <li><dfn id="dom-node-document_type_node" title="dom-Node-DOCUMENT_TYPE_NODE"><code>DOCUMENT_TYPE_NODE</code></dfn> (10);

 <li><dfn id="dom-node-document_fragment_node" title="dom-Node-DOCUMENT_FRAGMENT_NODE"><code>DOCUMENT_FRAGMENT_NODE</code></dfn> (11).
</ul>


<!-- NodeExodus
<hr>

<p>The <dfn title=dom-Node-namespaceURI><code>namespaceURI</code></dfn> attribute must return the namespace that is associated with the node, if there is one and it's not the empty string, and null otherwise.

<p>The <dfn title=dom-Node-prefix><code>prefix</code></dfn> attribute must return the prefix that is associated with the node, if there is one and it's not the empty string, and null otherwise.
<!- - support setting? - - On setting, it must run these steps:

<ol>
 <li><p>Let <var title>prefix</var> be the value being assigned.
 <li>
  <p>If <var title>prefix</var> is not null, run these substeps:
  <ol>
   <li><p>If <var title>prefix</var> does not match the
   <code data-anolis-spec=xml>Name</code> production in XML,
   <span title=concept-throw>throw</span> an
   "<code>InvalidCharacterError</code>" exception.
   <li><p>If <var title>prefix</var> does not match the <code
   data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML, <span title=concept-throw>throw</span> a
   "<code>NamespaceError</code>" exception.
  </ol>
 <li><p>Actually this does not match any browser. Let's try to drop it instead.
</ol>- ->

<p>The <dfn title=dom-Node-localName><code>localName</code></dfn> attribute
must return the local name that is associated with the node, if it has one,
and null otherwise.-->

<p>Атрибут <dfn id="dom-node-nodename" title="dom-Node-nodeName"><code>nodeName</code></dfn> должен возвратить следующее, в зависимости от типа <a href="#context-object">объекта контекста</a>:

<dl class="switch">
 <dt><code><a href="#element">Element</a></code>
 <dd><p>Его значение атрибута <code title="dom-Element-tagName"><a href="#dom-element-tagname">tagName</a></code>.

 <!--AttrExodus
 <dt><code>Attr</code>
 <dd><p>The <span>context object</span>'s
 <code title=dom-Attr-name>name</code> attribute.
 -->

 <dt><code><a href="#text">Text</a></code>
 <dd><p>"<code>#text</code>".

 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dd><p>Его <a href="#concept-pi-target" title="concept-PI-target">цель</a>.

 <dt><code><a href="#comment">Comment</a></code>
 <dd><p>"<code>#comment</code>".

 <dt><code><a href="#document">Document</a></code>
 <dd><p>"<code>#document</code>".

 <dt><code><a href="#documenttype">DocumentType</a></code>
 <dd><p>Его <a href="#concept-doctype-name" title="concept-doctype-name">имя</a>.

 <dt><code><a href="#documentfragment">DocumentFragment</a></code>
 <dd><p>"<code>#document-fragment</code>".
</dl>

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-baseuri" title="dom-Node-baseURI">baseURI</a></code>
 <dd><p>Возвращает <a href="#concept-node-base-url" title="concept-node-base-url">базовый URL</a>.
</dl>

<p>Атрибут <dfn id="dom-node-baseuri" title="dom-Node-baseURI"><code>baseURI</code></dfn> должен возвратить ассоциированный <a href="#concept-node-base-url" title="concept-node-base-url">базовый URL</a>.

<!--AttrExodus
<hr>

<p>The <dfn title=dom-Node-hasAttributes><code>hasAttributes()</code></dfn>
method must return true if there are any attributes associated with the
<span>context object</span>, if it is an <code>Element</code> node, and false
otherwise.

<p>The <dfn title=dom-Node-attributes><code>attributes</code></dfn> attribute must return a <code>NamedNodeMap</code> of all the <code>Attr</code> nodes associated with the node of the <span>context object</span>, if it is an <code>Element</code> node, and null otherwise.
-->

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-ownerdocument" title="dom-Node-ownerDocument">ownerDocument</a></code>
 <dd>
  <p>Возвращает <a href="#concept-node-document" title="concept-node-document">документ узла</a>.
  <p>Возвращает null для <a href="#concept-document" title="concept-document">документов</a>.

 <dt><code><var>node</var> . <a href="#dom-node-parentnode" title="dom-Node-parentNode">parentNode</a></code>
 <dd><p>Возвращает <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

 <dt><code><var>node</var> . <a href="#dom-node-parentelement" title="dom-Node-parentElement">parentElement</a></code>
 <dd><p>Возвращает <a href="#parent-element">родительский элемент</a>.

 <dt><code><var>node</var> . <a href="#dom-node-haschildnodes" title="dom-Node-hasChildNodes">hasChildNodes()</a></code>
 <dd><p>Возвращает имеет ли <var>node</var>
 <a href="#concept-tree-child" title="concept-tree-child">дочерних</a>.

 <dt><code><var>node</var> . <a href="#dom-node-childnodes" title="dom-Node-childNodes">childNodes</a></code>
 <dd><p>Возвращает <a href="#concept-tree-child" title="concept-tree-child">дочерние</a>.

 <dt><code><var>node</var> . <a href="#dom-node-firstchild" title="dom-Node-firstChild">firstChild</a></code>
 <dd><p>Возвращает <a href="#concept-tree-first-child" title="concept-tree-first-child">первый дочерний</a>.

 <dt><code><var>node</var> . <a href="#dom-node-lastchild" title="dom-Node-lastChild">lastChild</a></code>
 <dd><p>Возвращает <a href="#concept-tree-last-child" title="concept-tree-last-child">последний дочерний</a>.

 <dt><code><var>node</var> . <a href="#dom-node-previoussibling" title="dom-Node-previousSibling">previousSibling</a></code>
 <dd><p>Возвращает
 <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущий сестринский</a>.

 <dt><code><var>node</var> . <a href="#dom-node-nextsibling" title="dom-Node-nextSibling">nextSibling</a></code>
 <dd><p>Возвращает
 <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующий сестринский</a>.
</dl>

<div class="impl">

<p>Атрибут <dfn id="dom-node-ownerdocument" title="dom-Node-ownerDocument"><code>ownerDocument</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li>Если <a href="#context-object">объект контекста</a> является
 <a href="#concept-document" title="concept-document">документом</a>, возвратить null.

 <li>Возвратить <a href="#concept-node-document" title="concept-node-document">документ узла</a>.
</ol>

<div class="note">
<p><a href="#concept-node-document" title="concept-node-document">Документ узла</a>
<a href="#concept-document" title="concept-document">документа</a> это сам этот
<a href="#concept-document" title="concept-document">документ</a>.
<p>Все <a href="#concept-node" title="concept-node">узлы</a> имеют
<a href="#concept-document" title="concept-document">документ</a> в любое время.
</div>

<p>Атрибут <dfn id="dom-node-parentnode" title="dom-Node-parentNode"><code>parentNode</code></dfn>
должен возвратить <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.
<!-- AttrExodus
<li><p>If the <span>context object</span> is an <code>Attr</code> node,
return null.
-->

<p>Атрибут <dfn id="dom-node-parentelement" title="dom-Node-parentElement"><code>parentElement</code></dfn>
должен возвратить <a href="#parent-element">родительский элемент</a>.

<p>Метод <dfn id="dom-node-haschildnodes" title="dom-Node-hasChildNodes"><code>hasChildNodes()</code></dfn>
должен возвратить true если <a href="#context-object">объект контекста</a> имеет
<a href="#concept-tree-child" title="concept-tree-child">дочерних</a>, и false в другом случае.

<p>Атрибут <dfn id="dom-node-childnodes" title="dom-Node-childNodes"><code>childNodes</code></dfn>
должен возвратить <code><a href="#nodelist">NodeList</a></code> с корнем в
<a href="#context-object">объекте контекста</a> соответствующий только
<a href="#concept-tree-child" title="concept-tree-child">дочерним</a>.

<p>Атрибут <dfn id="dom-node-firstchild" title="dom-Node-firstChild"><code>firstChild</code></dfn>
должен возвратить
<a href="#concept-tree-first-child" title="concept-tree-first-child">первый дочерний</a>.

<p>Атрибут <dfn id="dom-node-lastchild" title="dom-Node-lastChild"><code>lastChild</code></dfn> должен возвратить <a href="#concept-tree-last-child" title="concept-tree-last-child">последний дочерний</a>.

<p>Атрибут
<dfn id="dom-node-previoussibling" title="dom-Node-previousSibling"><code>previousSibling</code></dfn>
должен возвратить
<a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущий сестринский</a>.
<!-- AttrExodus
 <li><p>If the <span>context object</span> is an <code>Attr</code> node,
 return null.
-->

<p>Атрибут <dfn id="dom-node-nextsibling" title="dom-Node-nextSibling"><code>nextSibling</code></dfn>
должен возвратить
<a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующий сестринский</a>.
<!-- AttrExodus
 <li><p>If the <span>context object</span> is an <code>Attr</code> node,
 return null.
-->

</div>

<hr>

<!-- TODO: domintro -->

<p>Атрибут <dfn id="dom-node-nodevalue" title="dom-Node-nodeValue"><code>nodeValue</code></dfn> должен возвратить следующее, в зависимости от <a href="#context-object">объекта контекста</a>:

<dl class="switch">
 <!--AttrExodus <dt><code>Attr</code> -->
 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dd><p><a href="#concept-cd-data" title="concept-CD-data">Данные</a> <a href="#context-object">объекта контекста</a>.

 <dt>Любой другой узел
 <dd><p>Null.
</dl>

<p>Атрибут <code title="dom-Node-nodeValue"><a href="#dom-node-nodevalue">nodeValue</a></code> должен, при установке, если новое значение является null, действовать как если бы это была пустая строка, затем выполнить описанное ниже, в зависимости от <a href="#context-object">объекта контекста</a>:

<dl class="switch">
 <!--AttrExodus <dt><code>Attr</code> -->
 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dd><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
 <a href="#context-object">объекта контекста</a>, смещение 0, подсчет на значение атрибута
 <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code>, и данные на новое значение.

 <dt>Любой другой узел
 <dd><p>Не делать ничего.
</dl>

<p>Атрибут <dfn id="dom-node-textcontent" title="dom-Node-textContent"><code>textContent</code></dfn>
должен возвратить следующее, в зависимости от
<a href="#context-object">объекта контекста</a>:

<dl class="switch">
 <dt><code><a href="#documentfragment">DocumentFragment</a></code>
 <dt><code><a href="#element">Element</a></code>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dd><p>Конкатенация <a href="#concept-cd-data" title="concept-CD-data">данных</a> всех <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a> <a href="#concept-node" title="concept-node">узла</a> <code><a href="#text">Text</a></code>
 <a href="#context-object">объекта контекста</a>, в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dd><p><a href="#concept-cd-data" title="concept-CD-data">Данные</a> <a href="#context-object">объекта контекста</a>.

 <dt>Любой другой узел
 <dd><p>Null.
</dl>

<p>Атрибут <code title="dom-Node-textContent"><a href="#dom-node-textcontent">textContent</a></code> должен, при установке, если новое значение является null, действовать как если бы это была пустая строка, затем выполнить описанное ниже, в зависимости от <a href="#context-object">объекта контекста</a>:

<dl class="switch">
 <dt><code><a href="#documentfragment">DocumentFragment</a></code>
 <dt><code><a href="#element">Element</a></code>
 <!--AttrExodus <dt><code>Attr</code> -->
 <dd>
  <ol>
   <li><p>Сделать <var>node</var> null.

   <li><p>Если новое значение не является пустой строкой, установить <var>node</var> к
   новому <a href="#concept-node" title="concept-node">узлу</a> <code><a href="#text">Text</a></code>, чьи
   <a href="#concept-cd-data" title="concept-CD-data">данные</a> это новое значение.

   <li><p><a href="#concept-node-replace-all" title="concept-node-replace-all">Заменить всё</a> на
   <var>node</var> внутри <a href="#context-object">объекта контекста</a>.
  </ol>

 <dt><code><a href="#text">Text</a></code>
 <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
 <dt><code><a href="#comment">Comment</a></code>
 <dd><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
 <a href="#context-object">объекта контекста</a>, смещение 0, подсчет на значение атрибута
 <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">длины</a></code>, и данные на новое значение.

 <dt>Любой другой узел
 <dd><p>Не делать ничего
</dl>

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-normalize" title="dom-Node-normalize">normalize</a>()</code>
 <dd><p>Удаляет <a href="#concept-node-empty" title="concept-node-empty">пустой</a>
 <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code> и конкатенирует
 <a href="#concept-cd-data" title="concept-CD-data">данные</a> остающихся
 <a href="#contiguous-text-nodes">смежных <code>Text</code> узлов</a> в первые их
 <a href="#concept-node" title="concept-node">узлы</a>.
</dl>

<p>Метод <dfn id="dom-node-normalize" title="dom-Node-normalize"><code>normalize()</code></dfn> должен выполнить следующие шаги:</p>

<p>Для каждого <a href="#concept-tree-descendant" title="concept-tree-descendant">потомка</a> <a href="#concept-node" title="concept-node">узла</a> <code><a href="#text">Text</a></code> <a href="#context-object">объекта контекста</a>:

<ol>
 <li><p>Сделать <var>node</var> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a> <a href="#concept-node" title="concept-node">узла</a> <code><a href="#text">Text</a></code>.

 <li><p>Сделать <var>length</var> значением атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> <var>node</var>.

 <li><p>Если <var>length</var> равняется нолю,
 <a href="#concept-node-remove" title="concept-node-remove">удалить</a> <var>node</var> и
 продолжить со следующим <code><a href="#text">Text</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>, если имеется.

 <li><p>Сделать <var>data</var> конкатенацией
 <a href="#concept-cd-data" title="concept-CD-data">данных</a> <a href="#contiguous-text-nodes">смежных <code>Text</code> узлов</a> <var>node</var> (за исключением себя), в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

 <li><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
 <var>node</var>, смещение <var>length</var>,
 подсчет 0, и данные <var>data</var>.

 <li><p>Сделать <var>current node</var> <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>node</var>.

 <li><p>Пока <var>current node</var> является <code><a href="#text">Text</a></code> узлом:

 <ol>
  <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
  <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
  <var>current node</var>, добавить <var>length</var> к его
  <a href="#concept-range-start-offset" title="concept-range-start-offset">начальному смещению</a> и установить его
  <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> к
  <var>node</var>.

  <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
  <var>current node</var>, добавить <var>length</var> к его
  <a href="#concept-range-end-offset" title="concept-range-end-offset">конечному смещению</a> и установить его
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> к
  <var>node</var>.

  <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
  <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
  <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>current node</var> и
  <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> это
  <a href="#concept-tree-index" title="concept-tree-index">индекс</a> <var>current node</var>, установить его
  <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> к
  <var>node</var> и его
  <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> к
  <var>length</var>.

  <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
  <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>current node</var> и
  <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> является
  <a href="#concept-tree-index" title="concept-tree-index">индексом</a> <var>current node</var>, установить его
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> к
  <var>node</var> и его
  <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> к
  <var>length</var>.

  <li><p>Добавить значение атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> <var>current node</var> к
  <var>length</var>.

  <li><p>Установить <var>current node</var> к его
  <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующему сестринскому</a>.
 </ol>

 <li><p><a href="#concept-node-remove" title="concept-node-remove">Удалить</a>
 <a href="#contiguous-text-nodes">смежные <code>Text</code> узлы</a> <var>node</var> (за исключением его самого), в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.
</ol>

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-clonenode" title="dom-Node-cloneNode">cloneNode</a>([<var>deep</var> = false])</code>
 <dd><p>Возвращает копию <var>node</var>. Если
 <var>deep</var> является true, копия также включает <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>
 <var>node</var>.

 <dt><code><var>node</var> . <a href="#dom-node-isequalnode" title="dom-Node-isEqualNode">isEqualNode</a>(<var>other</var>)</code>
 <dd><p>Возвращает имеют ли <var>node</var> и <var>other</var> одинаковые свойства.
</dl>

<div class="impl">

<p><a href="#other-applicable-specifications" title="Other applicable specifications">Спецификации</a> могут определять
<dfn id="concept-node-clone-ext" title="concept-node-clone-ext">шаги клонирования</dfn> для всех или некоторых
<a href="#concept-node" title="concept-node">узлов</a>. Алгоритм передает <var>copy</var>,
<var>node</var>, <var>document</var> и опционально
<i>clone children flag</i>, как указано в алгоритме
<a href="#concept-node-clone" title="concept-node-clone">клонирования</a>.

<p class="note no-backref">Заметка: HTML определяет
<a href="#concept-node-clone-ext" title="concept-node-clone-ext">шаги клонирования</a> для элементов
<code class="external" data-anolis-spec="html"><a href="http://www.w3.org/TR/html5/scripting-1.html#the-script-element">script</a></code> и
<code class="external" data-anolis-spec="html"><a href="http://www.w3.org/TR/html5/forms.html#the-input-element">input</a></code>. SVG должен делать то же самое для его элементов <code>script</code>, но не называет это на данный момент.

<p>Чтобы <dfn id="concept-node-clone" title="concept-node-clone">клонировать</dfn> <var>node</var>,
опционально с <var>document</var> и <i>флагом клонирования дочерних</i>, выполнить данные шаги:
<!-- This algorithm is used by dom-Node-cloneNode, dom-Document-importNode,
dom-Range-extractContents, dom-Range-cloneContents -->

<ol>
 <li><p>Если <var>document</var> не задан, сделать <var>document</var> <a href="#concept-node-document" title="concept-node-document">документом узла</a> <var>node</var>.

 <li><p>Сделать <var>copy</var> <a href="#concept-node" title="concept-node">узлом</a>
 реализующим те же интерфейсы, что и <var>node</var>.

 <li>
  <p>Если <var>copy</var> является
  <a href="#concept-document" title="concept-document">документом</a>, установить его
  <a href="#concept-node-document" title="concept-node-document">документ узла</a> и
  <var>document</var> к <var>copy</var>.
  <p>В другом случае, установить <a href="#concept-node-document" title="concept-node-document">документ узла</a> <var>copy</var> к
  <var>document</var>.

 <li>
  <p>Копировать следующее из <var>node</var> в <var>copy</var>, в зависимости от типа <var>node</var>:
  <dl class="switch">
   <dt><code><a href="#document">Document</a></code>
   <dd><p>Его <a href="#concept-document-encoding" title="concept-document-encoding">кодировку</a>,
   <a href="#concept-document-content-type" title="concept-document-content-type">тип контента</a>,
   <a href="#concept-document-url" title="concept-document-url">URL</a>, его режим
   (<a href="#concept-document-quirks" title="concept-document-quirks">режим совместимости</a>,
   <a href="#concept-document-limited-quirks" title="concept-document-limited-quirks">ограниченный режим совместимости</a> или
   <a href="#concept-document-no-quirks" title="concept-document-no-quirks">не-совместимый режим</a>) и его тип
   (<a href="#xml-document">XML документ</a> или <a href="#html-document">HTML документ</a>).

   <dt><code><a href="#documenttype">DocumentType</a></code>
   <dd><p>Его <a href="#concept-doctype-name" title="concept-doctype-name">имя</a>,
   <a href="#concept-doctype-publicid" title="concept-doctype-publicid">публичный ID</a> и
   <a href="#concept-doctype-systemid" title="concept-doctype-systemid">системный ID</a>.

   <dt><code><a href="#element">Element</a></code>
   <dd><p>Его <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a>,
   <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>,
   <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> и его
   <a href="#concept-element-attribute" title="concept-element-attribute">список атрибутов</a>.

   <!--AttrExodus
   <dt><code>Attr</code>
   <dd><p><code title=dom-Attr-value>value</code>
   -->

   <dt><code><a href="#text">Text</a></code>
   <dt><code><a href="#comment">Comment</a></code>
   <dd><p>Его <a href="#concept-cd-data" title="concept-CD-data">данные</a>.

   <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
   <dd><p>Его <a href="#concept-pi-target" title="concept-PI-target">цель</a> и
   <a href="#concept-cd-data" title="concept-CD-data">данные</a>.

   <dt>Любой другой узел
   <dd><p>—
  </dl>

 <li><p>Выполнить любые <a href="#concept-node-clone-ext" title="concept-node-clone-ext">шаги клонирования</a>
 определенные для <var>node</var> в <a href="#other-applicable-specifications">других применимых спецификациях</a>, затем
 передать <var>copy</var>, <var>node</var>, <var>document</var> и
 <i>флаг клонирования дочерних</i> если установлен, в качестве параметров.

 <li><p>Если <i>флаг клонирования дочерних</i> установлен,
 <a href="#concept-node-clone" title="concept-node-clone">клонировать</a> все
 <a href="#concept-tree-child" title="concept-tree-child">дочерние</a> <var>node</var> и
 добавить их к <var>copy</var>, с указанным <var>document</var>
 и установленным <i>флагом клонирования дочерних</i>.

 <li><p>Возвратить <var>copy</var>.
</ol>

<p>Метод
<dfn id="dom-node-clonenode" title="dom-Node-cloneNode"><code>cloneNode(<var>deep</var>)</code></dfn>
должен возвратить <a href="#concept-node-clone" title="concept-node-clone">клон</a>
<a href="#context-object">объекта контекста</a>, с установленным <i>флагом клонирования дочерних</i> если <var>deep</var> является true.

<p><a href="#concept-node" title="concept-node">Узел</a> <var>A</var>
<dfn id="concept-node-equals" title="concept-node-equals">равняется</dfn> <a href="#concept-node" title="concept-node">узлу</a>
<var>B</var> если все следующие условия равняются true:

<ul>
 <li><p>Значение атрибута 
 <code title="dom-Node-nodeType"><a href="#dom-node-nodetype">nodeType</a></code> для <var>A</var> и <var>B</var> является идентичным.
 <li>
  <p>Следующее также равняется, основываясь на <var>A</var>:
  <dl class="switch">
   <dt><code><a href="#documenttype">DocumentType</a></code>
   <dd><p>Его <a href="#concept-doctype-name" title="concept-doctype-name">имя</a>,
   <a href="#concept-doctype-publicid" title="concept-doctype-publicid">публичный ID</a> и
   <a href="#concept-doctype-systemid" title="concept-doctype-systemid">системный ID</a>.

   <dt><code><a href="#element">Element</a></code>
   <dd>
    <p>Его <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a>,
    <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>,
    <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a>,
    количество <a href="#concept-attribute" title="concept-attribute">атрибутов</a> в его
    <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a>.

   <!--AttrExodus
   <dt><code>Attr</code>
   <dd><p><code title=dom-Attr-value>value</code>
   -->

   <dt><code><a href="#processinginstruction">ProcessingInstruction</a></code>
   <dd><p>Его <a href="#concept-pi-target" title="concept-PI-target">цель</a> и
   <a href="#concept-cd-data" title="concept-CD-data">данные</a>.

   <dt><code><a href="#text">Text</a></code>
   <dt><code><a href="#comment">Comment</a></code>
   <dd><p>Его <a href="#concept-cd-data" title="concept-CD-data">данные</a>.

   <dt>Любой другой узел
   <dd><p>—
  </dl>
 <li><p>Если <var>A</var> является <a href="#concept-element" title="concept-element">элементом</a>, каждый
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> в его
 <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a> имеет
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> с тем же
 <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространством имен</a>,
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальным именем</a> и
 <a href="#concept-attribute-value" title="concept-attribute-value">значением</a> в <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a> <var>B</var>.
 <li><p><var>A</var> и <var>B</var> имеет то же количество
 <a href="#concept-tree-child" title="concept-tree-child">дочерних</a>.
 <li><p>Каждый <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> <var>A</var>
 <a href="#concept-node-equals" title="concept-node-equals">равняется</a>
 <a href="#concept-tree-child" title="concept-tree-child">дочернему</a> <var>B</var> идентичного
 <a href="#concept-tree-index" title="concept-tree-index">индекса</a>.
</ul>

<p>Метод
<dfn id="dom-node-isequalnode" title="dom-Node-isEqualNode"><code>isEqualNode(<var>node</var>)</code></dfn>
должен возвратить true если <var>node</var> не является null и
<a href="#context-object">объект контекста</a> <a href="#concept-node-equals" title="concept-node-equals">равняется</a>
<var>node</var>, и false в другом случае.

</div>

<hr>

<dl class="domintro">
 <dt><code><var>node</var> . <a href="#dom-node-comparedocumentposition" title="dom-Node-compareDocumentPosition">compareDocumentPosition</a>(<var>other</var>)</code>
 <dd>
  <p>Возвращает битмаск указывающий позицию <var>other</var>
  по отношению к <var>node</var>. Следующие биты могут быть установлены:

  <dl>
   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_position_disconnected" title="dom-Node-DOCUMENT_POSITION_DISCONNECTED">DOCUMENT_POSITION_DISCONNECTED</a></code> (1)
   <dd>Устанавливается когда <var>node</var> и <var>other</var> не находятся в одном <a href="#concept-tree" title="concept-tree">дереве</a>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_position_preceding" title="dom-Node-DOCUMENT_POSITION_PRECEDING">DOCUMENT_POSITION_PRECEDING</a></code> (2)
   <dd>Устанавливается когда <var>other</var> является
   <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующим</a>
   <var>node</var>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_position_following" title="dom-Node-DOCUMENT_POSITION_FOLLOWING">DOCUMENT_POSITION_FOLLOWING</a></code> (4)
   <dd>Устанавливается когда <var>other</var> является
   <a href="#concept-tree-following" title="concept-tree-following">следующим</a>
   <var>node</var>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_position_contains" title="dom-Node-DOCUMENT_POSITION_CONTAINS">DOCUMENT_POSITION_CONTAINS</a></code> (8)
   <dd>Устанавливается когда <var>other</var> является
   <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a>
   <var>node</var>.

   <dt><code><a href="#node">Node</a> . <a href="#dom-node-document_position_contained_by" title="dom-Node-DOCUMENT_POSITION_CONTAINED_BY">DOCUMENT_POSITION_CONTAINED_BY</a></code> (16, 10 в шестнадцатеричном)
   <dd>Устанавливается когда <var>other</var> является
   <a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a>
   <var>node</var>.
  </dl>

 <dt><code><var>node</var> . <a href="#dom-node-contains" title="dom-Node-contains">contains</a>(<var>other</var>)</code>
 <dd><p>Возвращает true если <var>other</var> является
 <a href="#concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">включительным потомком</a>
 <var>node</var>, и false в другом случае.
</dl>

<p>Эти константы
<code title="dom-Node-compareDocumentPosition"><a href="#dom-node-comparedocumentposition">compareDocumentPosition()</a></code>
возвращаются как маска:

<ul class="brief">
 <li><dfn id="dom-node-document_position_disconnected" title="dom-Node-DOCUMENT_POSITION_DISCONNECTED"><code>DOCUMENT_POSITION_DISCONNECTED</code></dfn> (1);
 <li><dfn id="dom-node-document_position_preceding" title="dom-Node-DOCUMENT_POSITION_PRECEDING"><code>DOCUMENT_POSITION_PRECEDING</code></dfn> (2);
 <li><dfn id="dom-node-document_position_following" title="dom-Node-DOCUMENT_POSITION_FOLLOWING"><code>DOCUMENT_POSITION_FOLLOWING</code></dfn> (4);
 <li><dfn id="dom-node-document_position_contains" title="dom-Node-DOCUMENT_POSITION_CONTAINS"><code>DOCUMENT_POSITION_CONTAINS</code></dfn> (8);
 <li><dfn id="dom-node-document_position_contained_by" title="dom-Node-DOCUMENT_POSITION_CONTAINED_BY"><code>DOCUMENT_POSITION_CONTAINED_BY</code></dfn> (16, 10 в шестнадцатеричном);
 <li><dfn id="dom-node-document_position_implementation_specific" title="dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"><code>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code></dfn> (32, 20 в шестнадцатеричном).
</ul>

<p>Метод <dfn id="dom-node-comparedocumentposition" title="dom-Node-compareDocumentPosition"><code>compareDocumentPosition(<var>other</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>reference</var> <a href="#context-object">объектом контекста</a>.
 <li><p>Если <var>other</var> и <var>reference</var> это один и тот же объект, возвратить ноль.

 <li>
  <p>Если <var>other</var> и <var>reference</var> не
  находятся в одном <a href="#concept-tree" title="concept-tree">дереве</a>, возвратить результат добавления
  <code title="dom-Node-DOCUMENT_POSITION_DISCONNECTED"><a href="#dom-node-document_position_disconnected">DOCUMENT_POSITION_DISCONNECTED</a></code>,
  <code title="dom-Node-DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC"><a href="#dom-node-document_position_implementation_specific">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</a></code>
  и
  <code title="dom-Node-DOCUMENT_POSITION_PRECEDING"><a href="#dom-node-document_position_preceding">DOCUMENT_POSITION_PRECEDING</a></code> либо
  <code title="dom-Node-DOCUMENT_POSITION_FOLLOWING"><a href="#dom-node-document_position_following">DOCUMENT_POSITION_FOLLOWING</a></code>,
  с тем ограничением, что это должно быть последовательным, вместе.

  <p class="note">Заметка: Хотя возврат
  <code title="dom-Node-DOCUMENT_POSITION_PRECEDING"><a href="#dom-node-document_position_preceding">DOCUMENT_POSITION_PRECEDING</a></code> или
  <code title="dom-Node-DOCUMENT_POSITION_FOLLOWING"><a href="#dom-node-document_position_following">DOCUMENT_POSITION_FOLLOWING</a></code>
  обычно реализуется с помощью сравнения указателей. В JavaScript могут использоваться
  реализации <code>Math.random()</code>.

 <li><p>Если <var>other</var> является
 <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a>
 <var>reference</var>, возвратить результат добавления
 <code title="dom-Node-DOCUMENT_POSITION_CONTAINS"><a href="#dom-node-document_position_contains">DOCUMENT_POSITION_CONTAINS</a></code>
 к
 <code title="dom-Node-DOCUMENT_POSITION_PRECEDING"><a href="#dom-node-document_position_preceding">DOCUMENT_POSITION_PRECEDING</a></code>.

 <li><p>Если <var>other</var> является
 <a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a>
 <var>reference</var>, возвратить результат добавления
 <code title="dom-Node-DOCUMENT_POSITION_CONTAINED_BY"><a href="#dom-node-document_position_contained_by">DOCUMENT_POSITION_CONTAINED_BY</a></code>
 к
 <code title="dom-Node-DOCUMENT_POSITION_FOLLOWING"><a href="#dom-node-document_position_following">DOCUMENT_POSITION_FOLLOWING</a></code>.

 <li><p>Если <var>other</var> является
 <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующим</a>
 <var>reference</var>, возвратить
 <code title="dom-Node-DOCUMENT_POSITION_PRECEDING"><a href="#dom-node-document_position_preceding">DOCUMENT_POSITION_PRECEDING</a></code>.

 <li><p>Возвратить
 <code title="dom-Node-DOCUMENT_POSITION_FOLLOWING"><a href="#dom-node-document_position_following">DOCUMENT_POSITION_FOLLOWING</a></code>.
</ol>

<!-- AttrExodus compareDocumentPosition() works differently if Attr inherits
     from Node -->

<p>Метод
<dfn id="dom-node-contains" title="dom-Node-contains"><code>contains(<var>other</var>)</code></dfn>
должен возвратить true если <var>other</var> является
<a href="#concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">включительным потомком</a>
<a href="#context-object">объекта контекста</a>, и false в другом случае (включая когда
<var>other</var> является null).

<hr>

<!-- TODO: domintro -->

<!--
 XXX apparently these algorithms might not be quite correct
 https://bugzilla.mozilla.org/show_bug.cgi?id=312019
 https://bugzilla.mozilla.org/show_bug.cgi?id=505178
-->

<p>Чтобы <dfn id="locate-a-namespace-prefix">найти префикс пространства имен</dfn> для <var>element</var> с помощью
<var>namespace</var>, выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> <var>element</var>-а является
 <var>namespace</var> и его
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> не
 null, возвратить его
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>.

 <li><p>Если <var>element</var>
 <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> чей
 <a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a> это
 "<code>xmlns</code>" и
 <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> это
 <var>namespace</var>, то возвратить первое такое <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> <a href="#concept-attribute" title="concept-attribute">атрибута</a> <var>element</var>-а.

 <li><p>Если <a href="#parent-element">родительский элемент</a> <var>element</var>-а является null,
 возвратить результат выполнения <a href="#locate-a-namespace-prefix">поиска префикса пространства имен</a> на этом
 <a href="#concept-element" title="concept-element">элементе</a> с помощью <var>namespace</var>.
 В другом случае, возвратить null.
</ol>

<p>Чтобы <dfn id="locate-a-namespace">найти пространство имен</dfn> для <var>node</var> используя
<var>prefix</var> в зависимости от <var>node</var>:

<dl class="switch">
 <dt><code><a href="#element">Element</a></code>
 <dd>
  <ol>
   <li><p>Если его <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> не является null и его
   <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> является
   <var>prefix</var>, возвратить
   <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a>.

   <li>
    <p>Если он <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
    <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
    <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> является
    <a href="#xmlns-namespace">XMLNS пространством имен</a>,
    <a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a>
    это "<code>xmlns</code>" и
    <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
    <var>prefix</var>, или если <var>prefix</var> не null и
    <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
    <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
    <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> является
    <a href="#xmlns-namespace">XMLNS пространством имен</a>,
    <a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a>
    является null и <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a>
    является "<code>xmlns</code>":

    <ol>
     <li><p>Сделать <var>value</var> его
     <a href="#concept-attribute-value" title="concept-attribute-value">значением</a> если это не пустая строка, и null в другом случае.

     <li><p>Возвратить <var>value</var>.
    </ol>

   <li><p>Если его <a href="#parent-element">родительский элемент</a> является null, возвратить null.

   <li><p>Возвратить результат выполнения <a href="#locate-a-namespace">поиска пространства имен</a> на
   его <a href="#parent-element">родительском элементе</a> используя <var>prefix</var>.
  </ol>

 <!--AttrExodus <code>Attr</code> -->
 <dt><code><a href="#document">Document</a></code>
 <dd>
  <ol>
   <li><p>Если его <a href="#document-element">элемент документа</a> является null, возвратить null.

   <li><p>Возвратить результат выполнения <a href="#locate-a-namespace">поиска пространства имен</a> на
   его <a href="#document-element">элементе документа</a> используя <var>prefix</var>.
  </ol>

 <dt><code><a href="#documenttype">DocumentType</a></code>
 <dt><code><a href="#documentfragment">DocumentFragment</a></code>
 <dd><p>Возвратить null.

 <dt>Любой другой узел
 <dd>
  <ol>
   <li><p>Если его <a href="#parent-element">родительский элемент</a> является null, возвратить null.

   <li><p>Возвратить результат выполнения <a href="#locate-a-namespace">поиска пространства имен</a> на
   его <a href="#parent-element">родительском элементе</a> используя <var>prefix</var>.
  </ol>
</dl>

<p>Метод
<dfn id="dom-node-lookupprefix" title="dom-Node-lookupPrefix"><code>lookupPrefix(<var>namespace</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>namespace</var> является null или пустой строкой, возвратить null.

 <li>
  <p>В другом случае это зависит от <a href="#context-object">объекта контекста</a>:

  <dl class="switch">
   <dt><code><a href="#element">Element</a></code>
   <dd><p>Возвратить результат
   <a href="#locate-a-namespace-prefix" title="locate a namespace prefix">поиска префикса пространства имен</a>
   для узла с помощью <var>namespace</var>.

   <!--AttrExodus <code>Attr</code> -->
   <dt><code><a href="#document">Document</a></code>
   <dd><p>Возвратить результат
   <a href="#locate-a-namespace-prefix" title="locate a namespace prefix">поиска префикса пространства имен</a>
   для его <a href="#document-element">элемента документа</a>, если он не является null, и null в другом случае.

   <dt><code><a href="#documenttype">DocumentType</a></code>
   <dt><code><a href="#documentfragment">DocumentFragment</a></code>
   <dd><p>Возвратить null.

   <dt>Любой другой узел
   <dd><p>Возвратить результат
   <a href="#locate-a-namespace-prefix" title="locate a namespace prefix">поиска префикса пространства имен</a>
   для его <a href="#parent-element">родительского элемента</a>, или если он является null, null.
  </dl>
</ol>

<p>Метод
<dfn id="dom-node-lookupnamespaceuri" title="dom-Node-lookupNamespaceURI"><code>lookupNamespaceURI(<var>prefix</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>prefix</var> является пустой строкой, установить его к null.

 <li><p>Возвратить результат выполнения <a href="#locate-a-namespace">поиска пространства имен</a> для
 <a href="#context-object">объекта контекста</a> с помощью <var>prefix</var>.
</ol>

<p>Метод
<dfn id="dom-node-isdefaultnamespace" title="dom-Node-isDefaultNamespace"><code>isDefaultNamespace(<var>namespace</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

 <li><p>Сделать <var>defaultNamespace</var> результатом выполнения
 <a href="#locate-a-namespace">поиска пространства имен</a> для <a href="#context-object">объекта контекста</a> используя
 null.

 <li><p>Возвратить true если <var>defaultNamespace</var> является тем же что и
 <var>namespace</var>, и false в другом случае.
</ol>

<hr>

<p>Метод
<dfn id="dom-node-insertbefore" title="dom-Node-insertBefore"><code>insertBefore(<var>node</var>, <var>child</var>)</code></dfn>
должен возвратить результат
<a href="#concept-node-pre-insert" title="concept-node-pre-insert">предварительной вставки</a>
<var>node</var> в <a href="#context-object">объекта контекста</a> перед
<var>child</var>.

<p>Метод
<dfn id="dom-node-appendchild" title="dom-Node-appendChild"><code>appendChild(<var>node</var>)</code></dfn>
должен возвратить результат
<a href="#concept-node-append" title="concept-node-append">добавления</a> <var>node</var> к <a href="#context-object">объекту контекста</a>.

<p>Метод
<dfn id="dom-node-replacechild" title="dom-Node-replaceChild"><code>replaceChild(<var>node</var>, <var>child</var>)</code></dfn>
должен возвратить результат
<a href="#concept-node-replace" title="concept-node-replace">замены</a> <var>child</var>
на <var>node</var> внутри <a href="#context-object">объекта контекста</a>.

<p>Метод
<dfn id="dom-node-removechild" title="dom-Node-removeChild"><code>removeChild(<var>child</var>)</code></dfn>
должен возвратить результат
<a href="#concept-node-pre-remove" title="concept-node-pre-remove">предварительного удаления</a>
<var>child</var> из <a href="#context-object">объекта контекста</a>.

<hr><!-- Collections -->

<p>
<dfn id="concept-getelementsbytagname" title="concept-getElementsByTagName">Список элементов с локальным именем <var>localName</var></dfn>
для <a href="#concept-node" title="concept-node">узла</a> <var>root</var> это
<code><a href="#htmlcollection">HTMLCollection</a></code> возвращенная следующим алгоритмом:
<ol>
 <li><p>Если <var>localName</var> является "<code>*</code>" (U+002A),
 возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в <var>root</var>,
 чей фильтр соответствует только <a href="#concept-element" title="concept-element">элементам</a>.

 <li>
  <p>В другом случае, если <a href="#concept-node-document" title="concept-node-document">документ узла</a> <var>root</var> является
  <a href="#html-document">HTML документом</a>, возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
  <var>root</var>, чей фильтр соответствует следующим
  <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a>:

  <ul>
   <li>Чье <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> является
   <a href="#html-namespace">HTML пространством имен</a> и чье
   <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> является
   <var>localName</var> <a href="#converted-to-ascii-lowercase">конвертированное в ASCII строчные</a>.

   <li>Чье <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a>
   <em>не</em> является <a href="#html-namespace">HTML пространством имен</a> и чье
   <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
   <var>localName</var>.
  </ul>

 <li><p>В другом случае, возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
 <var>root</var>, чей фильтр соответствует
 <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a>, чьи
 <a href="#concept-element-local-name" title="concept-element-local-name">local name</a> это
 <var>localName</var>.
</ol>

<p>Когда вызван с тем же аргументом, тот же объект <code><a href="#htmlcollection">HTMLCollection</a></code>
может быть возвращен, как и в предыдущем вызове.


<p>
<dfn id="concept-getelementsbytagnamens" title="concept-getElementsByTagNameNS">Список элементов с пространством имен
<var>namespace</var> и локальным именем <var>localName</var></dfn>
для <a href="#concept-node" title="concept-node">узла</a> <var>root</var> это
<code><a href="#htmlcollection">HTMLCollection</a></code> возвращенный следующим алгоритмом:

<ol>
 <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

 <li><p>Если <var>namespace</var> и <var>localName</var>
 являются "<code>*</code>" (U+002A), возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
 <var>root</var>, чей фильтр соответствует
 <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a>.

 <li><p>В другом случае, если <var>namespace</var> является "<code>*</code>"
 (U+002A), возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
 <var>root</var>, чей фильтр соответствует
 <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a> чье
 <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
 <var>localName</var>.

 <li><p>В другом случае, если <var>localName</var> является "<code>*</code>"
 (U+002A), возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
 <var>root</var>, чей фильтр соответствует
 <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a> чье
 <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> это
 <var>namespace</var>.

 <li><p>В другом случае, возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в
 <var>root</var>, чей фильтр соответствует
 <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a> чье
 <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> это
 <var>namespace</var> и
 <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
 <var>localName</var>.
</ol>

<p>Когда вызван с теми же аргументами, тот же объект <code><a href="#htmlcollection">HTMLCollection</a></code>
может быть возвращен, как возвращался в предыдущем вызове.


<p>
<dfn id="concept-getelementsbyclassname" title="concept-getElementsByClassName">Список элементом с именами классов <var>classNames</var></dfn>
для <a href="#concept-node" title="concept-node">node</a> <var>root</var> это
<code><a href="#htmlcollection">HTMLCollection</a></code> возвращенный следующим алгоритмом:
<ol>
 <li>
  <p>Сделать <var>classes</var> результатом выполнения
  <a href="#concept-ordered-set-parser" title="concept-ordered-set-parser">парсера упорядоченного множества</a> на
  <var>classNames</var>.

 <li>
  <p>Если <var>classes</var> является пустым множеством, возвратить пустой
  <code><a href="#htmlcollection">HTMLCollection</a></code>.

 <li>
  <p>Возвратить <code><a href="#htmlcollection">HTMLCollection</a></code> с корнем в <var>root</var>,
  чей фильтр соответствует <a href="#concept-element" title="concept-element">элементам</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомкам</a>, которые имеют все их
  <a href="#concept-class" title="concept-class">классы</a> в <var>classes</var>.

  <p>Сравнения для <a href="#concept-class" title="concept-class">классов</a> должны быть сделаны
  <a href="#ascii-case-insensitive">ASCII регистрозависимым</a> образом, если <a href="#concept-node-document" title="concept-node-document">документ узла</a> <var>root</var>-а в
  <a href="#concept-document-quirks" title="concept-document-quirks">режиме совместимости</a>, и
  <a href="#case-sensitive">регистрозависимым</a> образом в другом случае.
</ol>

<p>Когда вызван с тем же аргументом, тот же объект <code><a href="#htmlcollection">HTMLCollection</a></code>
может быть возвращен, как возвращался в предыдущем вызове.


<h3 id="interface-document"><span class="secno">4.5 </span>Интерфейс <code><a href="#document">Document</a></code></h3>
<pre class="idl">[<a href="#dom-document" title="dom-Document">Constructor</a>,
 Exposed=Window]
interface <dfn id="document">Document</dfn> : <a href="#node">Node</a> {
  [SameObject] readonly attribute <a href="#domimplementation">DOMImplementation</a> <a href="#dom-document-implementation" title="dom-Document-implementation">implementation</a>;
  readonly attribute DOMString <a href="#dom-document-url" title="dom-Document-URL">URL</a>;
  readonly attribute DOMString <a href="#dom-document-documenturi" title="dom-Document-documentURI">documentURI</a>;
  readonly attribute DOMString <a href="#dom-document-origin" title="dom-Document-origin">origin</a>;
  readonly attribute DOMString <a href="#dom-document-compatmode" title="dom-Document-compatMode">compatMode</a>;
  readonly attribute DOMString <a href="#dom-document-characterset" title="dom-Document-characterSet">characterSet</a>;
  readonly attribute DOMString <a href="#dom-document-contenttype" title="dom-Document-contentType">contentType</a>;

  readonly attribute <a href="#documenttype">DocumentType</a>? <a href="#dom-document-doctype" title="dom-Document-doctype">doctype</a>;
  readonly attribute <a href="#element">Element</a>? <a href="#dom-document-documentelement" title="dom-Document-documentElement">documentElement</a>;
  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-document-getelementsbytagname" title="dom-Document-getElementsByTagName">getElementsByTagName</a>(DOMString <var>localName</var>);
  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-document-getelementsbytagnamens" title="dom-Document-getElementsByTagNameNS">getElementsByTagNameNS</a>(DOMString? <var>namespace</var>, DOMString <var>localName</var>);
  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-document-getelementsbyclassname" title="dom-Document-getElementsByClassName">getElementsByClassName</a>(DOMString <var>classNames</var>);

  [NewObject] <a href="#element">Element</a> <a href="#dom-document-createelement" title="dom-Document-createElement">createElement</a>(DOMString <var>localName</var>);
  [NewObject] <a href="#element">Element</a> <a href="#dom-document-createelementns" title="dom-Document-createElementNS">createElementNS</a>(DOMString? <var>namespace</var>, DOMString <var>qualifiedName</var>);
  [NewObject] <a href="#documentfragment">DocumentFragment</a> <a href="#dom-document-createdocumentfragment" title="dom-Document-createDocumentFragment">createDocumentFragment</a>();
  [NewObject] <a href="#text">Text</a> <a href="#dom-document-createtextnode" title="dom-Document-createTextNode">createTextNode</a>(DOMString <var>data</var>);
  [NewObject] <a href="#comment">Comment</a> <a href="#dom-document-createcomment" title="dom-Document-createComment">createComment</a>(DOMString <var>data</var>);
  [NewObject] <a href="#processinginstruction">ProcessingInstruction</a> <a href="#dom-document-createprocessinginstruction" title="dom-Document-createProcessingInstruction">createProcessingInstruction</a>(DOMString <var>target</var>, DOMString <var>data</var>);<!--
  CDATASection createCDATASection(DOMString data);
  EntityReference createEntityReference(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttribute>createAttribute</span>(DOMString name);
  <span>Attr</span> <span title=dom-Document-createAttributeNS>createAttributeNS</span>(DOMString namespace, DOMString qualifiedName);
    If adding this, search for [createAttribute]-->

  [NewObject] <a href="#node">Node</a> <a href="#dom-document-importnode" title="dom-Document-importNode">importNode</a>(<a href="#node">Node</a> <var>node</var>, optional boolean <var>deep</var> = false);
  <a href="#node">Node</a> <a href="#dom-document-adoptnode" title="dom-Document-adoptNode">adoptNode</a>(<a href="#node">Node</a> <var>node</var>);

  [NewObject] <a href="#event">Event</a> <a href="#dom-document-createevent" title="dom-Document-createEvent">createEvent</a>(DOMString <var>interface</var>);

  [NewObject] <a href="#range">Range</a> <a href="#dom-document-createrange" title="dom-Document-createRange">createRange</a>();

  // <a href="#nodefilter">NodeFilter</a>.<a href="#dom-nodefilter-show_all" title="dom-NodeFilter-SHOW_ALL">SHOW_ALL</a> = 0xFFFFFFFF
  [NewObject] <a href="#nodeiterator">NodeIterator</a> <a href="#dom-document-createnodeiterator" title="dom-Document-createNodeIterator">createNodeIterator</a>(<!--
  --><a href="#node">Node</a> <var>root</var>, <!--
  -->optional unsigned long <var>whatToShow</var> = 0xFFFFFFFF, <!--
  -->optional <a href="#nodefilter">NodeFilter</a>? <var>filter</var> = null);
  [NewObject] <a href="#treewalker">TreeWalker</a> <a href="#dom-document-createtreewalker" title="dom-Document-createTreeWalker">createTreeWalker</a>(<!--
  --><a href="#node">Node</a> <var>root</var>, <!--
  -->optional unsigned long <var>whatToShow</var> = 0xFFFFFFFF, <!--
  -->optional <a href="#nodefilter">NodeFilter</a>? <var>filter</var> = null);
};

[Exposed=Window]
interface <dfn id="xmldocument">XMLDocument</dfn> : <a href="#document">Document</a> {};</pre>

<p><a href="#concept-node" title="concept-node">Узлы</a> <code><a href="#document">Document</a></code> проще называются <dfn id="concept-document" title="concept-document">документами</dfn>.

<p>Каждый <a href="#concept-document" title="concept-document">документ</a> имеет ассоциированную
<dfn id="concept-document-encoding" title="concept-document-encoding">кодировку</dfn>,
<dfn id="concept-document-content-type" title="concept-document-content-type">тип контента</dfn> и
<dfn id="concept-document-url" title="concept-document-url">URL</dfn>.
<a href="#biblio-ENCODING">[ENCODING]</a>
<a href="#biblio-URL">[URL]</a>

<p>Если не указано другое, <a href="#concept-document-encoding" title="concept-document-encoding">кодировка</a> <a href="#concept-document" title="concept-document">документа</a> это
<code class="external" data-anolis-spec="encoding"><a href="http://www.w3.org/TR/encoding/#utf-8">utf-8</a></code>
<a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#encoding">кодировка</a>, его
<a href="#concept-document-content-type" title="concept-document-content-type">тип контента</a> это
"<code>application/xml</code>" и
<a href="#concept-document-url" title="concept-document-url">URL</a> это
"<code>about:blank</code>".

<p>Если не указано иное, <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождение</a> <a href="#concept-document" title="concept-document">документа</a> это глобально уникальный идентификатор
и его <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> это
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркало</a>
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождения</a>.
<a href="#biblio-HTML">[HTML]</a>

<p><a href="#concept-document" title="concept-document">документ</a> считается
<dfn id="xml-document">XML документом</dfn> если только он не помечен как
<dfn id="html-document">HTML документ</dfn>. Является ли
<a href="#concept-document" title="concept-document">документ</a>
<a href="#html-document">HTML документом</a> или <a href="#xml-document">XML документом</a>, это влияет на поведения конкретных API.

<p><a href="#concept-document" title="concept-document">Документ</a> всегда установлен к одному из трех режимов: <dfn id="concept-document-no-quirks" title="concept-document-no-quirks">не-совместимый режим</dfn> по умолчанию; <dfn id="concept-document-quirks" title="concept-document-quirks">режим совместимости</dfn>, используется как правило для устаревших документов; и
<dfn id="concept-document-limited-quirks" title="concept-document-limited-quirks">ограниченный режим совместимости</dfn>. Если не указано иное,
в другом случае <a href="#concept-document" title="concept-document">документ</a> должен быть в
<a href="#concept-document-no-quirks" title="concept-document-no-quirks">не-совместимом режиме</a>.

<p class="note">Заметка: Режим изменяется с режима по умолчанию только лишь когда
<a href="#concept-document" title="concept-document">документ</a> создан
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/syntax.html#html-parser">HTML парсером</a>, в зависимости от
присутствия, отсутствия или значения строки DOCTYPE.
<a href="#biblio-HTML">[HTML]</a>

<p class="note">Заметка: <a href="#concept-document-no-quirks" title="concept-document-no-quirks">Не-совместимый режим</a>
изначально назывался "стандартным режимом",
<a href="#concept-document-limited-quirks" title="concept-document-limited-quirks">ограничено-совместимый режим</a> когда-то был известен как "почти стандартный режим". Они были переименованы потому что теперь их детали определены стандартами. (И потому что Ian Hickson наложил вето на их первоначальные имена, потому что они бессмысленны.)

<hr>

<dl class="domintro">
 <dt><code><var>document</var> = new <a href="#dom-document" title="dom-Document">Document</a>()</code>
 <dd><p>Возвращает новый <a href="#concept-document" title="concept-document">документ</a>.

 <dt><code><var>document</var> . <a href="#dom-document-implementation" title="dom-Document-implementation">implementation</a></code>
 <dd><p>Возвращает объект <code><a href="#domimplementation">DOMImplementation</a></code> <var>document</var>-а.

 <dt><code><var>document</var> . <a href="#dom-document-url" title="dom-Document-URL">URL</a></code>
 <dt><code><var>document</var> . <a href="#dom-document-documenturi" title="dom-Document-documentURI">documentURI</a></code>
 <dd><p>Возвращает <a href="#concept-document-url" title="concept-document-url">URL</a> <var>document</var>-а.

 <dt><code><var>document</var> . <a href="#dom-document-origin" title="dom-Document-origin">origin</a></code>
 <dd><p>Возвращает <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождение</a> <var>document</var>-а.

 <dt><code><var>document</var> . <a href="#dom-document-compatmode" title="dom-Document-compatMode">compatMode</a></code>
 <dd>
  <p>Возвращает строку "<code>CSS1Compat</code>" если
  <var>document</var> в
  <a href="#concept-document-no-quirks" title="concept-document-no-quirks">не-совместимом режиме</a> или
  <a href="#concept-document-limited-quirks" title="concept-document-limited-quirks">ограничено-совместимом режиме</a>, и
  "<code>BackCompat</code>" если <var>document</var> в
  <a href="#concept-document-quirks" title="concept-document-quirks">режиме совместимости</a>.

 <dt><code><var>document</var> . <a href="#dom-document-characterset" title="dom-Document-characterSet">characterSet</a></code>
 <dd><p>Возвращает <a href="#concept-document-encoding" title="concept-document-encoding">кодировку</a> <var>document</var>-а.

 <dt><code><var>document</var> . <a href="#dom-document-contenttype" title="dom-Document-contentType">contentType</a></code>
 <dd><p>Возвращает <a href="#concept-document-content-type" title="concept-document-content-type">тип контента</a> <var>document</var>-а.
</dl>

<p>Конструктор <dfn id="dom-document" title="dom-Document"><code>Document()</code></dfn>
должен возвратить новый <a href="#concept-document" title="concept-document">документ</a>, чье
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождение</a> является
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркалом</a> к
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождению</a> ассоциированного
<a href="#concept-document" title="concept-document">документа</a> глобального объекта, и
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> является
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркалом</a> к
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> ассоциированного <a href="#concept-document" title="concept-document">документа</a> глобального объекта.
<a href="#biblio-HTML">[HTML]</a>

<p class="note">Заметка: В отличие от
<code title="dom-DOMImplementation-createDocument"><a href="#dom-domimplementation-createdocument">createDocument()</a></code>, этот конструктор возвращает не объект <code><a href="#xmldocument">XMLDocument</a></code>, а
<a href="#concept-document" title="concept-document">документ</a> (объект <code><a href="#document">Document</a></code>).

<p>Атрибут
<dfn id="dom-document-implementation" title="dom-Document-implementation"><code>implementation</code></dfn>
должен возвратить объект <code><a href="#domimplementation">DOMImplementation</a></code>, который ассоциирован с <a href="#concept-document" title="concept-document">документом</a>.

<p>Атрибуты <dfn id="dom-document-url" title="dom-Document-URL"><code>URL</code></dfn> и
<dfn id="dom-document-documenturi" title="dom-Document-documentURI"><code>documentURI</code></dfn>
должны возвратить <a href="#concept-document-url" title="concept-document-url">URL</a>.

<p>Атрибут <dfn id="dom-document-origin" title="dom-Document-origin"><code>origin</code></dfn>
должен возвратить
<a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html51/browsers.html#unicode-serialisation-of-an-origin" title="Unicode serialization of an origin">Unicode сериализацию</a> <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождения</a>
<a href="#context-object">объекта контекста</a>.

<p>Атрибут <dfn id="dom-document-compatmode" title="dom-Document-compatMode"><code>compatMode</code></dfn>
должен возвратить "<code>BackCompat</code>" если
<a href="#context-object">объект контекста</a> в
<a href="#concept-document-quirks" title="concept-document-quirks">режиме совместимости</a>, и
"<code>CSS1Compat</code>" в другом случае.

<p>Получатель атрибута <dfn id="dom-document-characterset" title="dom-Document-characterSet"><code>characterSet</code></dfn> и получатель атрибута <dfn id="dom-document-inputencoding" title="dom-Document-inputEncoding"><code>inputEncoding</code></dfn> должны выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>name</var> <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#name">именем</a>
 <a href="#concept-document-encoding" title="concept-document-encoding">кодировки</a>.

 <li>
  <p>Если <var>name</var> находится в первой колонке таблицы ниже, установить
  <var>name</var> к значению второй колонки той же строки:

  <!-- The order matches the Encoding Standard -->
  <table>
   <tr>
    <th>Имя
    <th>Имя совместимости
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#utf-8">utf-8</a>
    <td>"<code>UTF-8</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ibm866">ibm866</a>
    <td>"<code>IBM866</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-2">iso-8859-2</a>
    <td>"<code>ISO-8859-2</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-3">iso-8859-3</a>
    <td>"<code>ISO-8859-3</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-4">iso-8859-4</a>
    <td>"<code>ISO-8859-4</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-5">iso-8859-5</a>
    <td>"<code>ISO-8859-5</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-6">iso-8859-6</a>
    <td>"<code>ISO-8859-6</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-7">iso-8859-7</a>
    <td>"<code>ISO-8859-7</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-8">iso-8859-8</a>
    <td>"<code>ISO-8859-8</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-8-i">iso-8859-8-i</a>
    <td>"<code>ISO-8859-8-I</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-10">iso-8859-10</a>
    <td>"<code>ISO-8859-10</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-13">iso-8859-13</a>
    <td>"<code>ISO-8859-13</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-14">iso-8859-14</a>
    <td>"<code>ISO-8859-14</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-15">iso-8859-15</a>
    <td>"<code>ISO-8859-15</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-8859-16">iso-8859-16</a>
    <td>"<code>ISO-8859-16</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#koi8-r">koi8-r</a>
    <td>"<code>KOI8-R</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#koi8-u">koi8-u</a>
    <td>"<code>KOI8-U</code>"
   <!-- macintosh, windows-*, x-mac-cyrillic -->
   <tr>
    <td>gbk
    <td>"<code>GBK</code>"
   <!-- gb18030 -->
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#big5">big5</a>
    <td>"<code>Big5</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#euc-jp">euc-jp</a>
    <td>"<code>EUC-JP</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#iso-2022-jp">iso-2022-jp</a>
    <td>"<code>ISO-2022-JP</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#shift_jis">shift_jis</a>
    <td>"<code>Shift_JIS</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#euc-kr">euc-kr</a>
    <td>"<code>EUC-KR</code>"
   <!-- replacement -->
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#utf-16be">utf-16be</a>
    <td>"<code>UTF-16BE</code>"
   <tr>
    <td><a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#utf-16le">utf-16le</a>
    <td>"<code>UTF-16LE</code>"
   <!-- x-user-defined -->
  </table>

 <li><p>Возвратить <var>name</var>.
</ol>

<p>Атрибут <dfn id="dom-document-contenttype" title="dom-Document-contentType"><code>contentType</code></dfn>
должен возвратить
<a href="#concept-document-content-type" title="concept-document-content-type">тип контента</a>.

<hr>

<dl class="domintro">
 <dt><var>document</var> . <code title="dom-Document-doctype"><a href="#dom-document-doctype">doctype</a></code>
 <dd><p>Возвращает <a href="#concept-doctype" title="concept-doctype">doctype</a> или null если его нет.

 <dt><var>document</var> . <code title="dom-Document-documentElement"><a href="#dom-document-documentelement">documentElement</a></code>
 <dd><p>Возвращает <a href="#document-element">document element</a>.

 <dt><var>collection</var> = <var>document</var> . <code title="dom-Document-getElementsByTagName"><a href="#dom-document-getelementsbytagname">getElementsByTagName(<var>localName</var>)</a></code>

 <dd>
  <p>Если <var>localName</var> является "<code>*</code>", возвращает
  <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>.

  <p>В другом случае, возвращает <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>, чье
  <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
  <var>localName</var>. (Сравнивается регистронезависимо против
  <a href="#concept-element" title="concept-element">элементов</a> в
  <a href="#html-namespace">HTML пространстве имен</a> внутри <a href="#html-document">HTML документа</a>.)

 <dt><var>collection</var> = <var>document</var> . <code title="dom-Document-getElementsByTagName"><a href="#dom-document-getelementsbytagname">getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</a></code>

 <dd>
  <p>Если <var>namespace</var> и <var>localName</var> являются
  "<code>*</code>", возвращает <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>.

  <p>Если только <var>namespace</var> является "<code>*</code>", возвращает
  <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>, чье
  <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
  <var>localName</var>.

  <p>Если только <var>localName</var> является "<code>*</code>", возвращает
  <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>, чье
  <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> это
  <var>namespace</var>.

  <p>В другом случае, возвращает <code><a href="#htmlcollection">HTMLCollection</a></code> всех
  <a href="#concept-element" title="concept-element">элементов</a> <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a>, чье
  <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> это
  <var>namespace</var> и
  <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
  <var>localName</var>.

 <dt><var>collection</var> = <var>document</var> . <code title="dom-Document-getElementsByClassName"><a href="#dom-document-getelementsbyclassname">getElementsByClassName(<var>classes</var>)</a></code>
 <dt><var>collection</var> = <var>element</var> . <code title="dom-Element-getElementsByClassName"><a href="#dom-element-getelementsbyclassname">getElementsByClassName(<var>classes</var>)</a></code>
 <dd>
  <p>Возвращает <code><a href="#htmlcollection">HTMLCollection</a></code>
  <a href="#concept-element" title="concept-element">элементов</a> в объекте на котором
  метод был вызван (<a href="#concept-document" title="concept-document">документ</a> или
  <a href="#concept-element" title="concept-element">элемент</a>), который имеет все классы заданные в <var>classes</var>.
  <p>Аргумент <var>classes</var> интерпретируется как разделенный пробелами список классов.
</dl>

<p>Атрибут <dfn id="dom-document-doctype" title="dom-Document-doctype"><code>doctype</code></dfn> должен возвратить <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>
<a href="#concept-document" title="concept-document">документа</a>, который является
<a href="#concept-doctype" title="concept-doctype">doctype</a>, и null в другом случае.

<p>Атрибут
<dfn id="dom-document-documentelement" title="dom-Document-documentElement"><code>documentElement</code></dfn>
должен возвратить <a href="#document-element">document element</a>.

<p>Метод
<dfn id="dom-document-getelementsbytagname" title="dom-Document-getElementsByTagName"><code>getElementsByTagName(<var>localName</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbytagname" title="concept-getElementsByTagName">список элементов с локальным именем <var>localName</var></a>
для <a href="#context-object">объекта контекста</a>.

<p class="note">Заметка: Таким образом, в <a href="#html-document">HTML документе</a>, под
<code>document.getElementsByTagName("FOO")</code> будут подходить элементы
<code>FOO</code>, которые не в
<a href="#html-namespace">HTML пространстве имен</a>, и элементы <code>foo</code>, которые в
<a href="#html-namespace">HTML пространстве имен</a>, но не элементы <code>FOO</code>, которые в <a href="#html-namespace">HTML пространстве имен</a>.


<p>Метод
<dfn id="dom-document-getelementsbytagnamens" title="dom-Document-getElementsByTagNameNS"><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbytagnamens" title="concept-getElementsByTagNameNS">список элементов с пространством имен <var>namespace</var> и локальным именем <var>localName</var></a>
для <a href="#context-object">объекта контекста</a>.


<p>Метод
<dfn id="dom-document-getelementsbyclassname" title="dom-Document-getElementsByClassName"><code>getElementsByClassName(<var>classNames</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbyclassname" title="concept-getElementsByClassName">список элементов с именами классов <var>classNames</var></a>
для <a href="#context-object">объекта контекста</a>.

<div class="example">
 <p>На примере следующего XHTML фрагмента:

 <pre>&lt;div id="example"&gt;
  &lt;p id="p1" class="aaa bbb"/&gt;
  &lt;p id="p2" class="aaa ccc"/&gt;
  &lt;p id="p3" class="bbb ccc"/&gt;
&lt;/div&gt;</pre>

 <p>Вызов
 <code>document.getElementById('example').getElementsByClassName('aaa')</code>
 возвратил бы <code><a href="#htmlcollection">HTMLCollection</a></code> с параграфами
 <code>p1</code> и <code>p2</code> в нем.

 <p>Вызов
 <code>getElementsByClassName('ccc bbb')</code>
 возвратил бы только один узел, а именно <code>p3</code>. Вызов
 <code>document.getElementById('example').getElementsByClassName('bbb  ccc ')</code>
 возвратил бы то же самое.

 <p>Вызов
 <code>getElementsByClassName('aaa,bbb')</code>
 не возвратил бы узлов; ни один из элементов выше не в
 классе <code>aaa,bbb</code>.
</div>

<hr>

<dl class="domintro">
 <dt><var>element</var> = <var>document</var> . <code title="dom-Document-createElement"><a href="#dom-document-createelement">createElement(<var>localName</var>)</a></code>
 <dd>
  <p>Возвращает <a href="#concept-element" title="concept-element">элемент</a> в
  <a href="#html-namespace">HTML пространстве имен</a> [смотрите <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431'>баг 19431</a>] с <var>localName</var> в качестве
  <a href="#concept-element-local-name" title="concept-element-local-name">локального имени</a>. (В
  <a href="#html-document">HTML документе</a> <var>localName</var> строчными буквами.)

  <p>Если <var>localName</var> не соответствует производному
  <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>, будет
  выдано исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <dt><var>element</var> = <var>document</var> . <code title="dom-Document-createElement"><a href="#dom-document-createelement">createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</a></code>

 <dd>
  <p>Возвражает <a href="#concept-element" title="concept-element">элемент</a> с
  <a href="#concept-element-namespace" title="concept-element-namespace">пространством имен</a>
  <var>namespace</var>. Его
  <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> будет
  всем перед "<code>:</code>" (U+003E) в
  <var>qualifiedName</var> или null. Его
  <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> будет
  всем после "<code>:</code>" (U+003E) в
  <var>qualifiedName</var> или <var>qualifiedName</var>.

  <p>Если <var>localName</var> не соответствует производному
  <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>, будет выдано исключение
  "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

  <p>Если одно из следующих условий является true, будет выдано исключение
  "<code><a href="#namespaceerror">NamespaceError</a></code>":

  <ul>
   <li><var>localName</var> не соответствует производному
   <code class="external" data-anolis-spec="xmlns"><a href="http://www.w3.org/TR/xml-names/#NT-QName">QName</a></code>.
   <li><a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">Префикс пространства имен</a>
   не является null и <var>namespace</var> является пустой строкой.
   <li><a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">Префикс пространства имен</a>
   является "<code>xml</code>" и <var>namespace</var> не
   <a href="#xml-namespace">XML пространство имен</a>.
   <li><var>qualifiedName</var> или
   <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>
   является "<code>xmlns</code>" и <var>namespace</var> не
   <a href="#xmlns-namespace">XMLNS пространство имен</a>.
   <li><var>namespace</var> является <a href="#xmlns-namespace">XMLNS пространством имен</a> и ни
   <var>qualifiedName</var>, ни
   <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>
   не являются "<code>xmlns</code>".
  </ul>

 <dt><var>documentFragment</var> = <var>document</var> . <code title="dom-Document-createDocumentFragment"><a href="#dom-document-createdocumentfragment">createDocumentFragment()</a></code>
 <dd><p>Возвращает <code><a href="#documentfragment">DocumentFragment</a></code>
 <a href="#concept-node" title="concept-node">узел</a>.

 <dt><var>text</var> = <var>document</var> . <code title="dom-Document-createTextNode"><a href="#dom-document-createtextnode">createTextNode(<var>data</var>)</a></code>
 <dd><p>Возвращает <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>,
 чьи <a href="#concept-cd-data" title="concept-CD-data">данные</a> это <var>data</var>.

 <dt><var>comment</var> = <var>document</var> . <code title="dom-Document-createComment"><a href="#dom-document-createcomment">createComment(<var>data</var>)</a></code>
 <dd><p>Возвращает <a href="#concept-node" title="concept-node">узел</a> <code><a href="#comment">Comment</a></code>,
 чьи <a href="#concept-cd-data" title="concept-CD-data">данные</a> это <var>data</var>.

 <dt><var>processingInstruction</var> = <var>document</var> . <code title="dom-Document-createProcessingInstruction"><a href="#dom-document-createprocessinginstruction">createProcessingInstruction(<var>target</var>, <var>data</var>)</a></code>
 <dd>
  <p>Возвращает <code><a href="#processinginstruction">ProcessingInstruction</a></code>
  <a href="#concept-node" title="concept-node">узел</a>, чья
  <a href="#concept-pi-target" title="concept-PI-target">цель</a> является <var>target</var> и
  <a href="#concept-cd-data" title="concept-CD-data">данные</a> это <var>data</var>.
  <p>Если <var>target</var> не соответствует производному
  <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>, будет выдано исключение
  "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".
  <p>Если <var>data</var> содержит "<code>?&gt;</code>", будет выдано исключение
  "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".
</dl>

<p><dfn id="concept-element-interface" title="concept-element-interface">Элемент интерфейса</dfn> для любого
<var>name</var> и <var>namespace</var> это <code><a href="#element">Element</a></code>, если не указано другое.

<p class="note">Заметка: Стандарт HTML определит, к примеру, что для <code>html</code> и
<a href="#html-namespace">HTML пространства имен</a> используется интерфейс <code>HTMLHtmlElement</code>.
<a href="#biblio-HTML">[HTML]</a>

<p>Метод <dfn id="dom-document-createelement" title="dom-Document-createElement"><code>createElement(<var>localName</var>)</code></dfn> должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>localName</var> не соответствует любому производному
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li><p>Если <a href="#context-object">объект контекста</a> является <a href="#html-document">HTML документом</a>,
 сделать <var>localName</var>
 <a href="#converted-to-ascii-lowercase">конвертированным в ASCII строчные</a>.
 <!-- XXX why restrict this to HTML documents? -->

 <li><p>Сделать <var>interface</var>
 <a href="#concept-element-interface" title="concept-element-interface">элементом интерфейса</a> для
 <var>localName</var> и <a href="#html-namespace">HTML пространства имен</a>.

 <li><p>Возвращает новый <a href="#concept-element" title="concept-element">элемент</a>, который реализует <var>interface</var>,
 без атрибутов,
 <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> установленное к <a href="#html-namespace">HTML пространству имен</a> [смотрите <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=19431'>баг 19431</a>],
 <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> установленное к <var>localName</var>, и
 <a href="#concept-node-document" title="concept-node-document">узел документа</a> установленный к <a href="#context-object">объекту контекста</a>.
</ol>

<p>Метод
<dfn id="dom-document-createelementns" title="dom-Document-createElementNS"><code>createElementNS(<var>namespace</var>, <var>qualifiedName</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

 <li><p>Если <var>qualifiedName</var> не соответствует производному
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".
 <li><p>Если <var>qualifiedName</var> не соответствует производному
 <code class="external" data-anolis-spec="xmlns"><a href="http://www.w3.org/TR/xml-names/#NT-QName">QName</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".
 <li><p>Если <var>qualifiedName</var> содержит "<code>:</code>"
 (U+003E), то разделить строку на нем и сделать <var>prefix</var> первой частью, и <var>localName</var> второй частью. В другом случае,
 сделать <var>prefix</var> null и <var>localName</var>
 <var>qualifiedName</var>.
 <li><p>Если <var>prefix</var> не является null и
 <var>namespace</var> является null, <a href="#dfn-throw" title="concept-throw">выдать</a>
 a "<code><a href="#namespaceerror">NamespaceError</a></code>" исключение.
 <li><p>Если <var>prefix</var> это "<code>xml</code>" и
 <var>namespace</var> не является <a href="#xml-namespace">XML пространством имен</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".
 <li><p>Если <var>qualifiedName</var> или <var>prefix</var> это
 "<code>xmlns</code>" и <var>namespace</var> не является
 <a href="#xmlns-namespace">XMLNS пространством имен</a>, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".
 <li><p>Если <var>namespace</var> не <a href="#xmlns-namespace">XMLNS пространство имен</a>
 и ни <var>qualifiedName</var>, ни <var>prefix</var> не являются
 "<code>xmlns</code>", <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".

 <li><p>Сделать <var>interface</var> <a href="#concept-element-interface" title="concept-element-interface">элементом интерфейса</a> для
 <var>localName</var> и <var>namespace</var>.

 <li><p>Возвратить новый <a href="#concept-element" title="concept-element">элемент</a>, который реализует <var>interface</var>,
 без атрибутов,
 <a href="#concept-element-namespace" title="concept-element-namespace">пространством имен</a> установленным к <var>namespace</var>,
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префиксом пространства имен</a> установленным к <var>prefix</var>,
 <a href="#concept-element-local-name" title="concept-element-local-name">локальным именем</a> установленным к <var>localName</var>, и
 <a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к <a href="#context-object">объекту контекста</a>.
</ol>

<p>Метод
<dfn id="dom-document-createdocumentfragment" title="dom-Document-createDocumentFragment"><code>createDocumentFragment()</code></dfn>
должен возвратить новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#documentfragment">DocumentFragment</a></code> с его
<a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к
<a href="#context-object">объекту контекста</a>.

<p>Метод
<dfn id="dom-document-createtextnode" title="dom-Document-createTextNode"><code>createTextNode(<var>data</var>)</code></dfn>
должен возвратить новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code> с его
<a href="#concept-cd-data" title="concept-CD-data">данными</a> установленными к <var>data</var> и
<a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к
<a href="#context-object">объекту контекста</a>.
<p class="note">Заметка: Не выполняется проверка того что <var>data</var> состоит из
символов соответствующих производному <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code>.

<p>Метод
<dfn id="dom-document-createcomment" title="dom-Document-createComment"><code>createComment(<var>data</var>)</code></dfn>
должен возвратить новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#comment">Comment</a></code> с его
<a href="#concept-cd-data" title="concept-CD-data">данными</a> установленными к <var>data</var> и
<a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к
<a href="#context-object">объекту контекста</a>.
<p class="note">Заметка: Не производится проверка того что <var>data</var> состоит из
символов, которые соответствуют производному <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code> или что он содержит два смежных дефиса или оканчивается на дефис.

<p>Метод <dfn id="dom-document-createprocessinginstruction" title="dom-Document-createProcessingInstruction"><code>createProcessingInstruction(<var>target</var>, <var>data</var>)</code></dfn> должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>target</var> не соответствует производному
 <!--<code data-anolis-spec=xml>PITarget</code>-->
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>". <!-- DOM3 does not check for "xml" -->

 <li><p>Если <var>data</var> содержит строку
 "<code>?&gt;</code>", <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>". <!-- Gecko does this. -->

 <!--<li><p>If <var title>target</var> contains a U+003A COLON (":")
 character, <span title=concept-throw>throw</span> a
 "<code>NamespaceError</code>" exception.-->
 <!-- DOM3 didn't check this -->

 <li><p>Возвратить новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#processinginstruction">ProcessingInstruction</a></code>, с
 <a href="#concept-pi-target" title="concept-PI-target">целью</a> установленной к <var>target</var>,
 <a href="#concept-cd-data" title="concept-CD-data">данными</a> установленными к <var>data</var>, и
 <a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к
 <a href="#context-object">объекту контекста</a>.
</ol>

<p class="note">Заметка: Не выполняется проверка того что <var>target</var> содержит
"<code>xml</code>" или "<code>:</code>", или что
<var>data</var> содержит символы которые соответствуют производному
<code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Char">Char</a></code>.

<!--
[createAttribute]
<p>The <dfn title=dom-Document-createAttribute><code>createAttribute(<var title>name</var>)</code></dfn> method must run these steps:
<ol>
 <li><p>If <var title>name</var> does not match the <code data-anolis-spec=xml>Name</code> production in XML,
 <span title=concept-throw>throw</span> an
 "<code>InvalidCharacterError</code>"
 exception.
 <li><p>Return a new <code>Attr</code> node with its <code title=dom-Node-namespaceURI>namespaceURI</code> set to null, <code title=dom-Node-prefix>prefix</code> set to null, <code title=dom-Node-localName>localName</code> set to <var title>name</var>, and <span title=concept-node-document>node document</span> set to the <span>context object</span>.
</ol>-->
<!-- this is different from DOM3 -->
<!--<p class=note>No check is performed that the local name will match the <code
data-anolis-spec=xmlns>NCName</code> production in Namespaces in XML.-->

<hr>

<dl class="domintro">
 <dt><var>clone</var> = <var>document</var> . <code title="dom-Document-importNode"><a href="#dom-document-importnode">importNode(<var>node</var> [, <var>deep</var> = false])</a></code>
 <dd>
 <dd>
  <p>Возвращает копию <var>node</var>. Если
  <var>deep</var> является true, копия также включает
  <a href="#concept-tree-descendant" title="concept-tree-descendant">потомков</a> <var>node</var>.

  <p>Если <var>node</var> является
  <a href="#concept-document" title="concept-document">документом</a>, выдает исключение
  "<code><a href="#notsupportederror">NotSupportedError</a></code>".

 <dt><var>node</var> = <var>document</var> . <code title="dom-Document-adoptNode"><a href="#dom-document-adoptnode">adoptNode(<var>node</var>)</a></code>

 <dd>
  <p>Перемещает <var>node</var> из другого
  <a href="#concept-document" title="concept-document">документа</a> и возвращает его.

  <p>Если <var>node</var> является
  <a href="#concept-document" title="concept-document">документом</a>, выдает исключение
  "<code><a href="#notsupportederror">NotSupportedError</a></code>".
</dl>

<p>Метод
<dfn id="dom-document-importnode" title="dom-Document-importNode"><code>importNode(<var>node</var>, <var>deep</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>node</var> является
 <a href="#concept-document" title="concept-document">документом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#notsupportederror">NotSupportedError</a></code>".

 <li><p>Возвратить <a href="#concept-node-clone" title="concept-node-clone">клон</a>
 <var>node</var>, с <a href="#context-object">объектом контекста</a> и установленным
 <i>флагом клонирования дочерних</i> если <var>deep</var> является true.
</ol>

<p><a href="#other-applicable-specifications" title="Other applicable specifications">Спецификации</a> могут определять
<dfn id="concept-node-adopt-ext" title="concept-node-adopt-ext">шаги принятия</dfn> для всех или некоторых
<a href="#concept-node" title="concept-node">узлов</a>. Алгоритм передает <var>node</var> и
<var>oldDocument</var>, как указано в алгоритме
<a class="no-backref" href="#concept-node-adopt" title="concept-node-adopt">принятия</a>.

<p>Чтобы <dfn id="concept-node-adopt" title="concept-node-adopt">принять</dfn> <var>node</var> в <var>document</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>oldDocument</var> <a href="#concept-node-document" title="concept-node-document">узлом документа</a> <var>node</var>.

 <li><p>Если <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>node</var> не является null,
 <a href="#concept-node-remove" title="concept-node-remove">удалить</a> <var>node</var> из
 его <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

 <li><p>Установить <a href="#concept-node-document" title="concept-node-document">узел документа</a> <a href="#concept-tree-inclusive-descendant" title="concept-tree-inclusive-descendant">включительного потомка</a> <var>node</var> к <var>document</var>.
 <!--AttrExodus as well as any associated <code>Attr</code> nodes-->

 <li><p>Выполнить любые <a href="#concept-node-adopt-ext" title="concept-node-adopt-ext">шаги принятия</a> определенные для
 <var>node</var> в <a href="#other-applicable-specifications">других применимых спецификациях</a> и передать
 <var>node</var> и <var>oldDocument</var> в качестве параметров.
</ol>

<p>Метод
<dfn id="dom-document-adoptnode" title="dom-Document-adoptNode"><code>adoptNode(<var>node</var>)</code></dfn> должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>node</var> является
 <a href="#concept-document" title="concept-document">документом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#notsupportederror">NotSupportedError</a></code>".

 <li><p><a href="#concept-node-adopt" title="concept-node-adopt">Принять</a> <var>node</var>
 в <a href="#context-object">объект контекста</a>.

 <li><p>Возвратить <var>node</var>.
</ol>

<hr>

<p>Метод
<dfn id="dom-document-createevent" title="dom-Document-createEvent"><code>createEvent(<var>interface</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>constructor</var> null.

 <li>
  <p>Если <var>interface</var> является
  <a href="#ascii-case-insensitive">ASCII регистрозависимым</a>, сопоставить для любых строк из
  первой колонки таблицы ниже, установить <var>constructor</var> к
  интерфейсу из второй колонки того же ряда что и соответствующая строка:

  <table>
   <thead>
    <tr><th>Строка<th>Интерфейс<td>Заметки
   <tbody>
    <tr><td>"<code>customevent</code>"<td><code><a href="#customevent">CustomEvent</a></code><td>
    <tr><td>"<code>event</code>"<td><code><a href="#event">Event</a></code><td>
    <tr><td>"<code>events</code>"<td><code><a href="#event">Event</a></code><td>
    <tr><td>"<code>htmlevents</code>"<td><code><a href="#event">Event</a></code><td>
    <tr><td>"<code>keyboardevent</code>"<td><code>KeyboardEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
    <tr><td>"<code>keyevents</code>"<td><code>KeyboardEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
    <tr><td>"<code>messageevent</code>"<td><code>MessageEvent</code><td><a href="#biblio-HTML">[HTML]</a>
    <tr><td>"<code>mouseevent</code>"<td><code>MouseEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
    <tr><td>"<code>mouseevents</code>"<td><code>MouseEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
    <tr><td>"<code>touchevent</code>"<td><code>TouchEvent</code><td><a href="#biblio-TOUCHEVENTS">[TOUCHEVENTS]</a>
    <tr><td>"<code>uievent</code>"<td><code>UIEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
    <tr><td>"<code>uievents</code>"<td><code>UIEvent</code><td><a href="#biblio-UIEVENTS">[UIEVENTS]</a>
  </table>
  <!-- XXX WebKit's architecture is broken here and both browsers support more than DOM.
       http://trac.webkit.org/browser/trunk/Source/WebCore/dom/EventNames.in
       http://mxr.mozilla.org/mozilla-central/source/content/events/src/nsEventDispatcher.cpp#819 -->

 <li><p>Если <var>constructor</var> является null, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#notsupportederror">NotSupportedError</a></code>".

 <li><p>Сделать <var>event</var> результатом
 <a href="#concept-event-constructor" title="concept-event-constructor">вызова</a> изначального значения
 <var>constructor</var> с пустой строкой в качестве аргумента.
 <!-- "initial value" as in before script could get to it -->

 <li><p>Снять <a href="#initialized-flag">флаг инициализации</a> <var>event</var>.

 <li><p>Возвратить <var>event</var>.
</ol>

<p class="note">Заметка: Конструкторы <a href="#concept-event" title="concept-event">событий</a> могут использоваться вместо этого.

<hr>

<p>Метод <dfn id="dom-document-createrange" title="dom-Document-createRange"><code>createRange()</code></dfn>
должен возвратить новый <a href="#concept-range" title="concept-range">диапазон</a> с
(<a href="#context-object">объект контекста</a>, 0) в качестве его
<a href="#concept-range-start" title="concept-range-start">начала</a> и
<a href="#concept-range-end" title="concept-range-end">конца</a>.

<p class="note">Заметка: Конструктор <code title="dom-Range"><a href="#dom-range">Range()</a></code> может использоваться вместо этого.

<hr>

<p>Метод
<dfn id="dom-document-createnodeiterator" title="dom-Document-createNodeIterator"><code>createNodeIterator(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Создать объект <code><a href="#nodeiterator">NodeIterator</a></code>.
 <li><p>Установить <a href="#concept-traversal-root" title="concept-traversal-root">корень</a> и инициализировать
 атрибут <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code>
 к аргументу <var>root</var>.
 <li><p>Инициализировать атрибут
 <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code>
 к true.
 <li><p>Установить <a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> к
 аргументу <var>whatToShow</var>.
 <li><p>Установить <a href="#concept-traversal-filter" title="concept-traversal-filter">фильтр</a> к
 <var>filter</var>.
 <li><p>Возвратить только что созданный объект <code><a href="#nodeiterator">NodeIterator</a></code>.
</ol>

<p>Метод
<dfn id="dom-document-createtreewalker" title="dom-Document-createTreeWalker"><code>createTreeWalker(<var>root</var>, <var>whatToShow</var>, <var>filter</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Создать объект <code><a href="#treewalker">TreeWalker</a></code>.
 <li><p>Установить <a href="#concept-traversal-root" title="concept-traversal-root">корень</a> и инициализировать
 атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code> к аргументу <var>root</var>.
 <li><p>Установить <a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> к
 аргументу <var>whatToShow</var>.
 <li><p>Установить <a href="#concept-traversal-filter" title="concept-traversal-filter">фильтр</a> к
 <var>filter</var>.
 <li><p>Возвратить только что созданный объект <code><a href="#treewalker">TreeWalker</a></code>.
</ol>



<h4 id="interface-domimplementation"><span class="secno">4.5.1 </span>Интерфейс <code><a href="#domimplementation">DOMImplementation</a></code></h4>
<p>Пользовательские агенты должны создавать объект <code><a href="#domimplementation">DOMImplementation</a></code> всякий раз когда <a href="#concept-document" title="concept-document">документ</a> создан и ассоциировать
с этим <a href="#concept-document" title="concept-document">документом</a>.

<pre class="idl">[Exposed=Window]
interface <dfn id="domimplementation">DOMImplementation</dfn> {
  [NewObject] <a href="#documenttype">DocumentType</a> <a href="#dom-domimplementation-createdocumenttype" title="dom-DOMImplementation-createDocumentType">createDocumentType</a>(DOMString qualifiedName, DOMString publicId, DOMString systemId);
  [NewObject] <a href="#xmldocument">XMLDocument</a> <a href="#dom-domimplementation-createdocument" title="dom-DOMImplementation-createDocument">createDocument</a>(DOMString? <var>namespace</var>, [TreatNullAs=EmptyString] DOMString <var>qualifiedName</var>, optional <a href="#documenttype">DocumentType</a>? <var>doctype</var> = null);
  [NewObject] <a href="#document">Document</a> <a href="#dom-domimplementation-createhtmldocument" title="dom-DOMImplementation-createHTMLDocument">createHTMLDocument</a>(optional DOMString <var>title</var>);

  boolean <a href="#dom-domimplementation-hasfeature" title="dom-DOMImplementation-hasFeature">hasFeature</a>(); // useless; always returns true
};</pre>

<dl class="domintro">
 <dt><code><var>doctype</var> = <var>document</var> . <a href="#dom-document-implementation" title="dom-Document-implementation">implementation</a> . <a href="#dom-domimplementation-createdocumenttype" title="dom-DOMImplementation-createDocumentType">createDocumentType</a>(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code>

 <dd>
  <p>Возвращает <a href="#concept-doctype" title="concept-doctype">doctype</a>, с заданным
  <var>qualifiedName</var>, <var>publicId</var> и
  <var>systemId</var>. Если <var>qualifiedName</var> не соответствует производному <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>, выдается исключение
  "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>", и если он не соответствует производному
  <code class="external" data-anolis-spec="xmlns"><a href="http://www.w3.org/TR/xml-names/#NT-QName">QName</a></code>, выдается исключение
  "<code><a href="#namespaceerror">NamespaceError</a></code>".

 <dt><code><var>doc</var> = <var>document</var> . <a href="#dom-document-implementation" title="dom-Document-implementation">implementation</a> . <a href="#dom-domimplementation-createdocument" title="dom-DOMImplementation-createDocument">createDocument</a>(<var>namespace</var>, <var>qualifiedName</var> [, <var>doctype</var> = null])</code>

 <dd>
  <p>Возвращает <code><a href="#xmldocument">XMLDocument</a></code> [смотрите <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">баг 22960</a>], с
  <a href="#document-element">элементом документа</a> чье
  <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> это
  <var>qualifiedName</var> и чье
  <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> это
  <var>namespace</var> (кроме случая если <var>qualifiedName</var> является пустой строкой), и с <var>doctype</var>, если он задан, в качестве его
  <a href="#concept-doctype" title="concept-doctype">типа документа</a>.

  <p>Этот метод выдает те же исключения что и <code title="dom-Document-createElementNS"><a href="#dom-document-createelementns">createElementNS</a></code> метод, когда вызван с теми же аргументами.

 <dt><code><var>doc</var> = <var>document</var> . <a href="#dom-document-implementation" title="dom-Document-implementation">implementation</a> . <a href="#dom-domimplementation-createhtmldocument" title="dom-DOMImplementation-createHTMLDocument">createHTMLDocument</a>([<var>title</var>])</code>

 <dd>
  <p>Возвращает <a href="#concept-document" title="concept-document">документ</a>, с уже построенным базовым
  <a href="#concept-tree" title="concept-tree">деревом</a> включая элемент
  <code>title</code>, кроме случае если элемент <var>title</var> опущен.
</dl>

<div class="impl">

<p>Метод
<dfn id="dom-domimplementation-createdocumenttype" title="dom-DOMImplementation-createDocumentType"><code>createDocumentType(<var>qualifiedName</var>, <var>publicId</var>, <var>systemId</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>qualifiedName</var> не соответствует производному
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".
 <li><p>Если <var>qualifiedName</var> не соответствует производному <code class="external" data-anolis-spec="xmlns"><a href="http://www.w3.org/TR/xml-names/#NT-QName">QName</a></code>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".
 <!-- <li><p>If <var title>publicId</var> contains a character that does not
 match the <code data-anolis-spec=xml>PubidChar</code> production in XML,
 <span title=concept-throw>throw</span> an
 "<code>InvalidCharacterError</code>"
 exception. --> <!-- DOM3 didn't check this -->
 <!--<li><p>If <var title>systemId</var> contains both a U+0022 QUOTATION MARK ('"') and a U+0027 APOSTROPHE ("'") character,
 <span title=concept-throw>throw</span> an
 "<code>InvalidCharacterError</code>"
 exception.--> <!-- DOM3 didn't check this -->
 <li><p>Возвратить новый <a href="#concept-doctype" title="concept-doctype">тип документа</a>, с
 <var>qualifiedName</var> в качестве его
 <a href="#concept-doctype-name" title="concept-doctype-name">имени</a>, <var>publicId</var> в качестве <a href="#concept-doctype-publicid" title="concept-doctype-publicid">публичного ID</a> и
 <var>systemId</var> в качестве
 <a href="#concept-doctype-systemid" title="concept-doctype-systemid">системного ID</a>, и с его
 <a href="#concept-node-document" title="concept-node-document">документом узла</a> установленным к
 соответствующему <a href="#concept-document" title="concept-document">документу</a>
 <a href="#context-object">объекта контекста</a>.
</ol>
<p class="note">Заметка: Не производится проверка того что <var>publicId</var>
соответствует производному <code>PublicChar</code> или того что
<var>systemId</var> не содержит '<code>"</code>' и
"<code>'</code>".

<p>Метод
<dfn id="dom-domimplementation-createdocument" title="dom-DOMImplementation-createDocument"><code>createDocument(<var>namespace</var>, <var>qualifiedName</var>, <var>doctype</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li>
  <p>Сделать <var>document</var> новым <code><a href="#xmldocument">XMLDocument</a></code> [смотрите <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=22960">баг 22960</a>].

  <p class="note">Заметка: Этот метод создает <code><a href="#xmldocument">XMLDocument</a></code>, а не
  обычный <a href="#concept-document" title="concept-document">документ</a>. Они являются идентичными,
  за исключением метода развертывания контента
  <code class="external" data-anolis-spec="html" title="dom-XMLDocument-load"><a href="http://www.w3.org/TR/html51/dom.html#dom-xmldocument-load">load()</a></code>, на который он полагается.
  <a href="#biblio-HTML">[HTML]</a>

 <li><p>Сделать <var>element</var> null.

 <li><p>Если <var>qualifiedName</var> не является пустой строкой, установить
 <var>element</var> к результату вызова метода
 <code title="dom-Document-createElementNS"><a href="#dom-document-createelementns">createElementNS()</a></code> с аргументами <var>namespace</var> и
 <var>qualifiedName</var> на <var>document</var>. Заново выдать любые исключения.
 <!-- XXX needs cleanup -->

 <li><p>Если <var>doctype</var> не является null,
 <a href="#concept-node-append" title="concept-node-append">добавить</a>
 <var>doctype</var> к <var>document</var>.

 <li><p>Если <var>element</var> не является null,
 <a href="#concept-node-append" title="concept-node-append">добавить</a>
 <var>element</var> к <var>document</var>.

 <li><p><a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">Происхождение</a> <var>document</var>-а это
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркало</a>
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождения</a> ассоциированного
 <a href="#concept-document" title="concept-document">документа</a> <a href="#context-object">объекта контекста</a>, и
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> <var>document</var>-а это
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркало</a> к
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> ассоциированного <a href="#concept-document" title="concept-document">документа</a> <a href="#context-object">объекта контекста</a>.
 <a href="#biblio-HTML">[HTML]</a>

 <li><p>Возвратить <var>document</var>.
</ol>

<p>Метод
<dfn id="dom-domimplementation-createhtmldocument" title="dom-DOMImplementation-createHTMLDocument"><code>createHTMLDocument(<var>title</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>doc</var> новым
 <a href="#concept-document" title="concept-document">документом</a>, который является
 <a href="#html-document">HTML документом</a>.

 <li><p>Установить <a href="#concept-document-content-type" title="concept-document-content-type">тип контента</a> <var>doc</var>-а к
 "<code>text/html</code>".

 <li><p>Создать <a href="#concept-doctype" title="concept-doctype">тип документа</a>, с
 "<code>html</code>"
 в качестве его <a href="#concept-doctype-name" title="concept-doctype-name">имени</a> и с его
 <a href="#concept-node-document" title="concept-node-document">узлом документа</a> установленным к
 <var>doc</var>. <a href="#concept-node-append" title="concept-node-append">Добавить</a>
 созданный узел к <var>doc</var>.

 <li><p>Создать элемент <code>html</code> в <a href="#html-namespace">HTML
 пространстве имен</a> и <a href="#concept-node-append" title="concept-node-append">добавить</a>
 его к <var>doc</var>.

 <li><p>Создать элемент <code>head</code> в <a href="#html-namespace">HTML
 пространстве имен</a> и <a href="#concept-node-append" title="concept-node-append">добавить</a>
 его к элементу <code>html</code> созданному в предыдущем шаге.

 <li>
  <p>Если аргумент <var>title</var> не опущен:

  <ol>
   <li><p>Создать элемент <code>title</code> в
   <a href="#html-namespace">HTML пространстве имен</a> и
   <a href="#concept-node-append" title="concept-node-append">добавить</a> его к элементу
   <code>head</code> созданному в предыдущем шаге.

   <li><p>Создать <code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узел</a>,
   установить его <a href="#concept-cd-data" title="concept-CD-data">данные</a> к <var>title</var>
   (который может являться пустой строкой), и
   <a href="#concept-node-append" title="concept-node-append">добавить</a> его к элементу
   <code>title</code> созданному в предыдущем шаге.
  </ol>

 <li><p>Создать элемент <code>body</code> в
 <a href="#html-namespace">HTML пространстве имен</a> и
 <a href="#concept-node-append" title="concept-node-append">добавить</a> его к элементу
 <code>html</code> созданному в предыдущем шаге.

 <li><p><a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">Происхождение</a> <var>doc</var>-а является
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркалом</a> к
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#origin">происхождению</a> ассоциированного
 <a href="#concept-document" title="concept-document">документа</a> <a href="#context-object">объекта контекста</a>, и <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a>
 <var>doc</var>-а является
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#concept-origin-alias" title="concept-origin-alias">зеркалом</a> к
 <a class="external" data-anolis-spec="html" href="http://www.w3.org/TR/html5/browsers.html#effective-script-origin">effective script origin</a> ассоциированного <a href="#concept-document" title="concept-document">документа</a> <a href="#context-object">объекта контекста</a>.
 <a href="#biblio-HTML">[HTML]</a>

 <li><p>Возвратить <var>doc</var>.
</ol>

<p>Метод <dfn id="dom-domimplementation-hasfeature" title="dom-DOMImplementation-hasFeature"><code>hasFeature()</code></dfn> должен возвратить true.

<p class="note">Заметка: Изначально <code title="dom-DOMImplementation-hasFeature"><a href="#dom-domimplementation-hasfeature">hasFeature()</a></code>
сообщал поддерживает ли агент пользователя заданную функцию DOM, но опыт показал, что это даже не близко так надежно как
простая проверка существуют ли нужные объекты, атрибуты или методы.
Как таковой, он больше не должен использоваться, но продолжает существовать (и просто возвращать true), таким образом старые страницы не перестают работать.

</div>


<h3 id="interface-documentfragment"><span class="secno">4.6 </span>Интерфейс <code><a href="#documentfragment">DocumentFragment</a></code></h3>
<pre class="idl">[<a href="#dom-documentfragment" title="dom-DocumentFragment">Constructor</a>,
 Exposed=Window]
interface <dfn id="documentfragment">DocumentFragment</dfn> : <a href="#node">Node</a> {
};</pre>

<p><a href="#concept-node" title="concept-node">Узел</a> <code><a href="#documentfragment">DocumentFragment</a></code> может иметь ассоциированный <a href="#concept-element" title="concept-element">элемент</a> под названием
<dfn id="concept-documentfragment-host" title="concept-DocumentFragment-host">host</dfn>.

<p>Объект <var>A</var> является
<dfn id="concept-tree-host-including-inclusive-ancestor" title="concept-tree-host-including-inclusive-ancestor">хост-содержащим включительным предком</dfn>
объекта <var>B</var>, если <var>A</var> является
<a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
<var>B</var>, либо если <a href="#concept-tree-root" title="concept-tree-root">корень</a> <var>B</var>
имеет ассоциированный <a href="#concept-documentfragment-host" title="concept-DocumentFragment-host">хост</a> и
<var>A</var> имеет
<a href="#concept-tree-host-including-inclusive-ancestor" title="concept-tree-host-including-inclusive-ancestor">хост-содержащего включительного предка</a> <a href="#concept-documentfragment-host" title="concept-DocumentFragment-host">хоста</a> <a href="#concept-tree-root" title="concept-tree-root">корня</a> <var>B</var>.

<p class="note">Заметка: Концепт <a href="#concept-documentfragment-host" title="concept-DocumentFragment-host">хоста</a> <a href="#concept-node" title="concept-node">узла</a> <code><a href="#documentfragment">DocumentFragment</a></code> полезен для элемента
<code>template</code> HTML и объекта <code>ShadowRoot</code>, и влияет на алгоритмы
<a href="#concept-node-pre-insert" title="concept-node-pre-insert">предварительной вставки</a> и
<a href="#concept-node-replace" title="concept-node-replace">замены</a>.

<!-- XXX xref
     XXX ShadowRoot is a Node technically -->

<dl class="domintro">
 <dt><code><var>tree</var> = new <a href="#dom-documentfragment" title="dom-DocumentFragment">DocumentFragment</a>()</code>
 <dd><p>Возвращает новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#documentfragment">DocumentFragment</a></code>.
</dl>

<p>Конструктор <dfn id="dom-documentfragment" title="dom-DocumentFragment"><code>DocumentFragment()</code></dfn> должен вернуть новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#documentfragment">DocumentFragment</a></code>, чей
<a href="#concept-node-document" title="concept-node-document">документ узла</a> это ассоциированный
<a href="#concept-document" title="concept-document">документ</a> глобального объекта.


<h3 id="interface-documenttype"><span class="secno">4.7 </span>Интерфейс <code><a href="#documenttype">DocumentType</a></code></h3>
<pre class="idl">[Exposed=Window]
interface <dfn id="documenttype">DocumentType</dfn> : <a href="#node">Node</a> {
  readonly attribute DOMString <a href="#dom-documenttype-name" title="dom-DocumentType-name">name</a>;
  readonly attribute DOMString <a href="#dom-documenttype-publicid" title="dom-DocumentType-publicId">publicId</a>;
  readonly attribute DOMString <a href="#dom-documenttype-systemid" title="dom-DocumentType-systemId">systemId</a>;<!--
  readonly attribute DOMString internalSubset;-->
};</pre>

<p><a href="#concept-node" title="concept-node">Узлы</a> <code><a href="#documenttype">DocumentType</a></code> проще называются <dfn id="concept-doctype" title="concept-doctype">типом документа</dfn>.

<p><a href="#concept-doctype" title="concept-doctype">Типы документа</a> имеют ассоциированное
<dfn id="concept-doctype-name" title="concept-doctype-name">имя</dfn>,
<dfn id="concept-doctype-publicid" title="concept-doctype-publicid">публичный ID</dfn> и
<dfn id="concept-doctype-systemid" title="concept-doctype-systemid">системный ID</dfn>.

<p>Когда <a href="#concept-doctype" title="concept-doctype">тип документа</a> создан, его
<a href="#concept-doctype-name" title="concept-doctype-name">имя</a> всегда является заданным. Если оно явно не задано когда <a href="#concept-doctype" title="concept-doctype">тип документа</a> создан, его <a href="#concept-doctype-publicid" title="concept-doctype-publicid">публичный ID</a> и
<a href="#concept-doctype-systemid" title="concept-doctype-systemid">системный ID</a> являются пустой строкой.

<p>Атрибут <dfn id="dom-documenttype-name" title="dom-DocumentType-name"><code>name</code></dfn> должен возвратить <a href="#concept-doctype-name" title="concept-doctype-name">имя</a>.

<p>Атрибут <dfn id="dom-documenttype-publicid" title="dom-DocumentType-publicId"><code>publicId</code></dfn>
должен возвратить
<a href="#concept-doctype-publicid" title="concept-doctype-publicid">публичный ID</a>.

<p>Атрибут <dfn id="dom-documenttype-systemid" title="dom-DocumentType-systemId"><code>systemId</code></dfn>
должен возвратить
<a href="#concept-doctype-systemid" title="concept-doctype-systemid">системный ID</a>.



<!-- AttrExodus
<h3>Interface <code>Attr</code></h3>

<p>The tentative plan is to let <code>Attr</code> no longer have
child nodes and turn it into a very lightweight object that no longer
inherits from <code>Node</code> &mdash;
<a href=http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html>http://lists.w3.org/Archives/Public/public-webapps/2010JulSep/0797.html</a>

<pre class=idl>interface <dfn>Attr</dfn> : <span>Node</span> {
  readonly attribute DOMString <span title=dom-Attr-name>name</span>;
  readonly attribute boolean <span title=dom-Attr-specified>specified</span>;
           attribute DOMString <span title=dom-Attr-value>value</span>;
  readonly attribute <span>Element</span> <span title=dom-Attr-ownerElement>ownerElement</span>;<!- -
  readonly attribute boolean isId;- ->
};</pre>

<p><code>Attr</code> nodes represent <dfn
title=concept-attribute>attributes</dfn>. They have a <dfn
title=concept-attribute-name>name</dfn> and an <dfn
title=concept-attribute-element>element</dfn> associated with them when they are
created<!- -, or when they are passed as the argument to the <code
title=dom-Element-setAttributeNode>setAttributeNode</code> method.
[createAttribute]- ->. <code>Attr</code> nodes are not considered part of the
document tree, so their <code title=dom-Node-parentNode>parentNode</code>, <code
title=dom-Node-previousSibling>previousSibling</code> and <code
title=dom-Node-nextSibling>nextSibling</code> attributes return null. Also, its
child nodes can not be manipulated directly through the <code
title=dom-Node-insertBefore>insertBefore</code>, <code
title=dom-Node-replaceChild>replaceChild</code> and <code
title=dom-Node-appendChild>appendChild</code> methods.

<p>The <dfn title=dom-Attr-name><code>name</code></dfn> attribute must return
the <span title=concept-attribute-name>name</span> associated with the
<span>context object</span>.

<p>The <dfn title=dom-Attr-specified><code>specified</code></dfn> attribute must
return true.

<p>The <dfn title=dom-Attr-value><code>value</code></dfn> attribute must return the value of the <span>context object</span>'s
<code title=dom-Node-textContent>textContent</code> attribute and on
setting, must set the <span>context object</span>'s
<code title=dom-Node-textContent>textContent</code> attribute to the new
value.

<p>The <dfn title=dom-Attr-ownerElement><code>ownerElement</code></dfn>
attribute must return the <span title=concept-attribute-element>element</span>
associated with the <span>context object</span><!- -, if there is one, or null
otherwise [createAttribute]- ->.
-->


<h3 id="interface-element"><span class="secno">4.8 </span>Интерфейс <code><a href="#element">Element</a></code></h3>
<pre class="idl">[Exposed=Window]
interface <dfn id="element">Element</dfn> : <a href="#node">Node</a> {
  readonly attribute DOMString? <a href="#dom-element-namespaceuri" title="dom-Element-namespaceURI">namespaceURI</a>;
  readonly attribute DOMString? <a href="#dom-element-prefix" title="dom-Element-prefix">prefix</a>;
  readonly attribute DOMString <a href="#dom-element-localname" title="dom-Element-localName">localName</a>;
  readonly attribute DOMString <a href="#dom-element-tagname" title="dom-Element-tagName">tagName</a>;

           attribute DOMString <a href="#dom-element-id" title="dom-Element-id">id</a>;
           attribute DOMString <a href="#dom-element-classname" title="dom-Element-className">className</a>;
  [SameObject] readonly attribute <a href="#domtokenlist">DOMTokenList</a> <a href="#dom-element-classlist" title="dom-Element-classList">classList</a>;

  [SameObject] readonly attribute <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1780488922">NamedNodeMap</a> <a href="#dom-element-attributes" title="dom-Element-attributes">attributes</a>;
  DOMString? <a href="#dom-element-getattribute" title="dom-Element-getAttribute">getAttribute</a>(DOMString <var>name</var>);
  DOMString? <a href="#dom-element-getattributens" title="dom-Element-getAttributeNS">getAttributeNS</a>(DOMString? <var>namespace</var>, DOMString <var>localName</var>);
  void <a href="#dom-element-setattribute" title="dom-Element-setAttribute">setAttribute</a>(DOMString <var>name</var>, DOMString <var>value</var>);
  void <a href="#dom-element-setattributens" title="dom-Element-setAttributeNS">setAttributeNS</a>(DOMString? <var>namespace</var>, DOMString <var>name</var>, DOMString <var>value</var>);
  void <a href="#dom-element-removeattribute" title="dom-Element-removeAttribute">removeAttribute</a>(DOMString <var>name</var>);
  void <a href="#dom-element-removeattributens" title="dom-Element-removeAttributeNS">removeAttributeNS</a>(DOMString? <var>namespace</var>, DOMString <var>localName</var>);
  boolean <a href="#dom-element-hasattribute" title="dom-Element-hasAttribute">hasAttribute</a>(DOMString <var>name</var>);
  boolean <a href="#dom-element-hasattributens" title="dom-Element-hasAttributeNS">hasAttributeNS</a>(DOMString? <var>namespace</var>, DOMString <var>localName</var>);
<!--
  <span>Attr</span> <span title=dom-Element-getAttributeNode>getAttributeNode</span>(DOMString name);
  <span>Attr</span> <span title=dom-Element-getAttributeNodeNS>getAttributeNodeNS</span>(DOMString namespace, DOMString localName);
  <span>Attr</span> <span title=dom-Element-setAttributeNode>setAttributeNode</span>(Attr newAttr);
  <span>Attr</span> <span title=dom-Element-removeAttributeNode>removeAttributeNode</span>(Attr oldAttr);
-->

  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-element-getelementsbytagname" title="dom-Element-getElementsByTagName">getElementsByTagName</a>(DOMString <var>localName</var>);
  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-element-getelementsbytagnamens" title="dom-Element-getElementsByTagNameNS">getElementsByTagNameNS</a>(DOMString? <var>namespace</var>, DOMString <var>localName</var>);
  <a href="#htmlcollection">HTMLCollection</a> <a href="#dom-element-getelementsbyclassname" title="dom-Element-getElementsByClassName">getElementsByClassName</a>(DOMString <var>classNames</var>);
};</pre>

<p><a href="#concept-node" title="concept-node">Узлы</a> <code><a href="#element">Element</a></code> проще называются <dfn id="concept-element" title="concept-element">элементами</dfn>.</p>

<p><a href="#concept-element" title="concept-element">Элементы</a> имеют ассоциированное
<dfn id="concept-element-namespace" title="concept-element-namespace">пространство имен</dfn>,
<dfn id="concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</dfn> и
<dfn id="concept-element-local-name" title="concept-element-local-name">локальное имя</dfn>. Когда
<a href="#concept-element" title="concept-element">элемент</a> создан, его
<a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> всегда задано.
Если не заданы явно при создании <a href="#concept-element" title="concept-element">элемента</a>, его <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> и
<a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> являются
null.

<p><a href="#concept-element" title="concept-element">Элементы</a> также имеют упорядоченный
<dfn id="concept-element-attribute" title="concept-element-attribute">список атрибутов</dfn>. Если не задан явно при создании <a href="#concept-element" title="concept-element">элемента</a>, его
<a href="#concept-element-attribute" title="concept-element-attribute">список атрибутов</a> является пустым.
<a href="#concept-element" title="concept-element">Элемент</a>
<dfn id="concept-element-attribute-has" title="concept-element-attribute-has">имеет</dfn>
<a href="#concept-attribute" title="concept-attribute">атрибут</a> <var>A</var> если
<var>A</var> в его
<a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a>.

<p><a href="#other-applicable-specifications" title="Other applicable specifications">Применимые спецификации</a>
и эта спецификация (могут) использовать крюки <dfn id="attribute-is-set">атрибут установлен</dfn>,
<dfn id="attribute-is-changed">атрибут изменен</dfn>, <dfn id="attribute-is-added">атрибут добавлен</dfn> и
<dfn id="attribute-is-removed">атрибут удален</dfn>, для дальнейшей обработки <a href="#concept-attribute-value" title="concept-attribute-value">значения</a>
<a href="#concept-attribute" title="concept-attribute">атрибута</a>.

<p>Чтобы <dfn id="concept-element-attributes-get" title="concept-element-attributes-get">получить атрибут</dfn> для <a href="#concept-element" title="concept-element">элемента</a> <var>element</var>
при помощи <var>localName</var> и опционально
<var>namespace</var>, выполнить следующие шаги:

<ol>
 <li><p>Если <var>namespace</var> не задан, установить его к null.

 <li><p>Возвратить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a>
 <a href="#concept-attribute" title="concept-attribute">атрибута</a> в <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a> <var>element</var>-а, чье
 <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> является
 <var>namespace</var> и
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
 <var>localName</var>, если он имеет его, и null в другом случае.
</ol>

<p>Чтобы <dfn id="concept-element-attributes-set" title="concept-element-attributes-set">установить атрибут</dfn> для
<a href="#concept-element" title="concept-element">элемента</a> <var>element</var>
с помощью <var>localName</var> и <var>value</var>, и
опционально <var>name</var>, <var>prefix</var> и
<var>namespace</var>, выполнить следующие шаги:

<ol>
 <li><p>Если <var>name</var> не задан, установить его к
 <var>localName</var>.

 <li><p>Если <var>prefix</var> не задан, установить его к null.

 <li><p>Если <var>namespace</var> не задан, установить его к null.

 <li><p>Сделать <var>attribute</var>
 <a href="#concept-attribute" title="concept-attribute">атрибутом</a> в
 <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a> <var>element</var>-а,
 чье <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> является
 <var>namespace</var> и чье
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a>
 является <var>localName</var>, либо null если нет такого
 <a href="#concept-attribute" title="concept-attribute">атрибута</a>.

 <li><p>Если <var>attribute</var> является null, создать
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
 <var>localName</var>,
 <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> это <var>value</var>,
 <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> это <var>name</var>,
 <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> это
 <var>namespace</var> и
 <a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a> это
 <var>prefix</var>, и затем
 <a href="#concept-element-attributes-append" title="concept-element-attributes-append">добавить</a> этот
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> к <var>element</var> и прекратить данные шаги.

 <li><p><a href="#concept-element-attributes-change" title="concept-element-attributes-change">Изменить</a>
 <var>attribute</var> с <var>element</var> на
 <var>value</var>.
</ol>

<p>Чтобы <dfn id="concept-element-attributes-change" title="concept-element-attributes-change">изменить</dfn>
<a href="#concept-attribute" title="concept-attribute">атрибут</a> <var>attribute</var>
с <a href="#concept-element" title="concept-element">элемента</a> <var>element</var>
на <var>value</var>, выполнить следующие шаги:

<ol>
 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code>attributes</code>"
 для <var>element</var> с именем <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локального имени</a> <var>attribute</var>-а, пространством имен <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространства имен</a>
 <var>attribute</var>-а, и oldValue <a href="#concept-attribute-value" title="concept-attribute-value">значением</a>
 <var>attribute</var>-а.

 <li><p>Установить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> <var>attribute</var>-а к <var>value</var>.

 <li><p><a href="#attribute-is-set">Атрибут установлен</a> и
 <a href="#attribute-is-changed">атрибут изменен</a>.
</ol>

<p>Чтобы <dfn id="concept-element-attributes-append" title="concept-element-attributes-append">добавить</dfn>
<a href="#concept-attribute" title="concept-attribute">атрибут</a> <var>attribute</var> к
<a href="#concept-element" title="concept-element">элементу</a> <var>element</var>, выполнить следующие шаги:

<ol>
 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code>attributes</code>"
 для <var>element</var> с именем <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локального имени</a> <var>attribute</var>-а, пространством имен <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространства имен</a>
 <var>attribute</var>-а, и oldValue null.

 <li><p>Добавить <var>attribute</var> к <a href="#concept-element-attribute" title="concept-element-attribute">списку атрибутов</a> <var>element</var>-а.

 <li><p><a href="#attribute-is-set">Атрибут установлен</a> и
 <a href="#attribute-is-added">атрибут добавлен</a>.
</ol>

<p>Чтобы <dfn id="concept-element-attributes-remove" title="concept-element-attributes-remove">удалить</dfn>
<a href="#concept-attribute" title="concept-attribute">атрибут</a> <var>attribute</var>
из <a href="#concept-element" title="concept-element">элемента</a> <var>element</var>, выполнить следующие шаги:

<ol>
 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code>attributes</code>"
 для <var>element</var> с именем <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локального имени</a> <var>attribute</var>-а, пространством имен <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространства имен</a>
 <var>attribute</var>-а, и oldValue <a href="#concept-attribute-value" title="concept-attribute-value">значением</a>
 <var>attribute</var>-а.

 <li><p>Удалить <var>attribute</var> из <a href="#concept-element-attribute" title="concept-element-attribute">списка атрибутов</a>
 <var>element</var>-а.

 <li><p><a href="#attribute-is-removed">Атрибут удален</a>.
</ol>

<hr>

<p><a href="#concept-element" title="concept-element">Элементы</a> могут иметь ассоциированный
<dfn id="concept-id" title="concept-id">уникальный идентификатор (ID)</dfn> и иметь ассоциированный объект
<code><a href="#domtokenlist">DOMTokenList</a></code>. <a href="#concept-attribute-local-name" title="concept-attribute-local-name">Локальное имя</a> ассоциированного <a href="#concept-attribute" title="concept-attribute">атрибута</a> объекта <code><a href="#domtokenlist">DOMTokenList</a></code> это
<code>class</code>, и его ассоциированное упорядоченное множество токенов называется <dfn id="concept-class" title="concept-class">классами</dfn>
<a href="#concept-element" title="concept-element">element</a>-а.

<p class="note">Заметка: Исторически <a href="#concept-element" title="concept-element">элементы</a> могли
иметь несколько идентификаторов, например с помощью использования HTML <a href="#concept-attribute" title="concept-attribute">атрибута</a> <code>id</code> и DTD. Эта спецификация
делает <a href="#concept-id" title="concept-id">ID</a> концептом для DOM и позволяет
только один для <a href="#concept-element" title="concept-element">элемента</a>, заданный
<a href="#concept-named-attribute" title="concept-named-attribute">атрибутом <code>id</code></a>.

<p>Когда создан <a href="#concept-element" title="concept-element">элемент</a>,
<a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеющий</a>
<a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>id</code></a> чье
<a href="#concept-attribute-value" title="concept-attribute-value">значение</a> не является пустой строкой, либо
когда <a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>id</code></a> <a href="#concept-element" title="concept-element">element</a>-а является
<a href="#attribute-is-set" title="attribute is set">установленным</a> к
<a href="#concept-attribute-value" title="concept-attribute-value">значению</a> отличному от пустой строки, установить <a href="#concept-id" title="concept-id">ID</a> <a href="#concept-element" title="concept-element">элемента</a> к новому
<a href="#concept-attribute-value" title="concept-attribute-value">значению</a>.

<p>Когда <a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>id</code></a> <a href="#concept-element" title="concept-element">element</a>-а
<a href="#attribute-is-removed" title="attribute is removed">удален</a> или
<a href="#attribute-is-set" title="attribute is set">установлен</a> к пустой строке, снять <a href="#concept-id" title="concept-id">ID</a>
<a href="#concept-element" title="concept-element">element</a>-а.

<p>Когда создан <a href="#concept-element" title="concept-element">элемент</a>,
<a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеющий</a>
<a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>class</code></a>, либо
когда <a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>class</code></a> <a href="#concept-element" title="concept-element">элемента</a>
<a href="#attribute-is-set" title="attribute is set">установлен</a>, установить <a href="#concept-class" title="concept-class">классы</a>
<a href="#concept-element" title="concept-element">element</a>-а к новому
<a href="#concept-attribute-value" title="concept-attribute-value">значению</a>,
<a href="#concept-ordered-set-parser" title="concept-ordered-set-parser">обработанному</a>.

<p>Когда <a href="#concept-named-attribute" title="concept-named-attribute">атрибут <code>class</code></a> <a href="#concept-element" title="concept-element">element</a>-а
<a href="#attribute-is-removed" title="attribute is removed">удален</a>, установить <a href="#concept-class" title="concept-class">классы</a>
<a href="#concept-element" title="concept-element">element</a>-а к пустой строке.

<p class="note">Заметка: В то время как эта спецификация определяет требования к обработке пользовательскими агентами <a href="#concept-attribute" title="concept-attribute">атрибутов</a> <code>id</code> и <code>class</code> на любых
<a href="#concept-element" title="concept-element">элементах</a>, она не делает заявлений о соответствии их использования.

<hr>

<p><a href="#concept-tree-parent" title="concept-tree-parent">Родитель</a> <a href="#concept-node" title="concept-node">узла</a> типа
<code><a href="#element">Element</a></code> называется <dfn id="parent-element">родительским элементом</dfn>. Если
<a href="#concept-node" title="concept-node">узел</a> имеет
<a href="#concept-tree-parent" title="concept-tree-parent">родителя</a> другого типа, его
<a href="#parent-element">родительский элемент</a> является null.</p>

<p><dfn id="document-element">Элемент документа</dfn>
<a href="#concept-document" title="concept-document">документа</a> это
<a href="#concept-element" title="concept-element">элемент</a> чей
<a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> является этим
<a href="#concept-document" title="concept-document">документом</a>, если существует, и null в другом случае.

<p class="note">Заметка: Из-за ограничений <a href="#concept-node-tree" title="concept-node-tree">дерева узлов</a> может быть только один такой
<a href="#concept-element" title="concept-element">элемент</a>.

<p>Когда <a href="#concept-element" title="concept-element">элемент</a> или один из его
<a href="#concept-tree-ancestor" title="concept-tree-ancestor">предков</a> является
<a href="#document-element">элементом документа</a>, он <dfn id="in-a-document">в документе</dfn>.

<hr>

<dl class="domintro">
 <dt><var>namespace</var> = <var>element</var> . <code title="dom-Element-namespaceURI"><a href="#dom-element-namespaceuri">namespaceURI</a></code>
 <dd><p>Возвращает <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a>.

 <dt><var>prefix</var> = <var>element</var> . <code title="dom-Element-prefix"><a href="#dom-element-prefix">prefix</a></code>
 <dd><p>Возвращает
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a>.

 <dt><var>localName</var> = <var>element</var> . <code title="dom-Element-localName"><a href="#dom-element-localname">localName</a></code>
 <dd><p>Возвращает
 <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a>.

 <dt><var>qualifiedName</var> = <var>element</var> . <code title="dom-Element-tagName"><a href="#dom-element-tagname">tagName</a></code>
 <dd><p>Если
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> не является
 null, возвращает конкатенацию
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикса пространства имен</a>,
 "<code>:</code>" и
 <a href="#concept-element-local-name" title="concept-element-local-name">локального имени</a>. В другом случае он
 возвращает <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a>.
 (Возвращаемое значение капсом для <a href="#html-document">HTML документа</a>.)
</dl>

<p>Атрибут <dfn id="dom-element-namespaceuri" title="dom-Element-namespaceURI"><code>namespaceURI</code></dfn>
должен возвратить <a href="#concept-element-namespace" title="concept-element-namespace">пространство имен</a> <a href="#context-object">объекта контекста</a>.

<p>Атрибут <dfn id="dom-element-prefix" title="dom-Element-prefix"><code>prefix</code></dfn> должен возвратить <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> <a href="#context-object">объекта контекста</a>.

<p>Атрибут <dfn id="dom-element-localname" title="dom-Element-localName"><code>localName</code></dfn>
должен возвратить <a href="#concept-element-local-name" title="concept-element-local-name">локальное имя</a> <a href="#context-object">объекта контекста</a>.

<p>Атрибут <dfn id="dom-element-tagname" title="dom-Element-tagName"><code>tagName</code></dfn> должен выполнить следующие шаги:
<ol>
 <li><p>Если <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префикс пространства имен</a> <a href="#context-object">объекта контекста</a> не является
 null, сделать <var>qualified name</var> его
 <a href="#concept-element-namespace-prefix" title="concept-element-namespace-prefix">префиксом пространства имен</a>, идущим
 перед "<code>:</code>" (U+003A), который идет перед
 <a href="#concept-element-local-name" title="concept-element-local-name">локальным именем</a>. В другом случае, сделать
 <var>qualified name</var> его
 <a href="#concept-element-local-name" title="concept-element-local-name">локальным именем</a>.

 <li><p>Если <a href="#context-object">объект контекста</a> в <a href="#html-namespace">HTML пространстве имен</a> и
 его <a href="#concept-node-document" title="concept-node-document">узел документа</a> является
 <a href="#html-document">HTML документом</a>, сделать <var>qualified name</var>
 <a href="#converted-to-ascii-uppercase">конвертированным в ASCII верхний регистр</a>.

 <li><p>Возвратить <var>qualified name</var>.
</ol>

<hr>

<!--
 XXX This section argues for generic get/set attribute algorithms; might
 need more text for DOMTokenList explaining various reflecting conditions.
-->

<p>Некоторые атрибуты IDL должны <dfn id="concept-reflect" title="concept-reflect">отражать</dfn> конкретное содержание атрибута заданного имени. Это означает что при получении данные шаги должны быть выполнены:

<ol>
 <li><p><a href="#concept-element-attributes-get" title="concept-element-attributes-get">Получить атрибут</a>
 для <a href="#context-object">объекта контекста</a> используя имя атрибута содержимого и сделать
 <var>value</var> результатом.

 <li><p>Если <var>value</var> является null, возвратить пустую строку.

 <li><p>Возвратить <var>value</var>.
</ol>

<p>При установке,
<a href="#concept-element-attributes-set" title="concept-element-attributes-set">установить атрибут</a> для
<a href="#context-object">объекта контекста</a> используя имя атрибута и заданное значение.

<p>Атрибут <dfn id="dom-element-id" title="dom-Element-id"><code>id</code></dfn> должен
<a href="#concept-reflect" title="concept-reflect">отражать</a> атрибут содержимого "<code>id</code>".

<p>Атрибут <dfn id="dom-element-classname" title="dom-Element-className"><code>className</code></dfn>
должен <a href="#concept-reflect" title="concept-reflect">отражать</a> атрибут содержимого
"<code>class</code>".

<p>Атрибут <dfn id="dom-element-classlist" title="dom-Element-classList"><code>classList</code></dfn>
должен возвратить ассоциированный объект <code><a href="#domtokenlist">DOMTokenList</a></code>
представляющий <a href="#concept-class" title="concept-class">классы</a> <a href="#context-object">объекта контекста</a>.

<hr>

<!-- all members in this subsection are affected by AttrExodus -->

<p>Атрибут <dfn id="dom-element-attributes" title="dom-Element-attributes"><code>attributes</code></dfn>
должен возвратить <code><a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-1780488922">NamedNodeMap</a></code>.

<p>Метод <dfn id="dom-element-getattribute" title="dom-Element-getAttribute"><code>getAttribute(<var>name</var>)</code></dfn> должен выполнить следующие шаги:
<ol>
 <li><p>Если <a href="#context-object">объект контекста</a> я
 <a href="#html-namespace">HTML пространстве имен</a> и его
 <a href="#concept-node-document" title="concept-node-document">документ узла</a> в
 <a href="#html-document">HTML документе</a>, сделать <var>name</var>
 <a href="#converted-to-ascii-lowercase">конвертированным в ASCII строчные</a>.

 <li><p>Возвратить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a>
 первого <a href="#concept-attribute" title="concept-attribute">атрибута</a> в <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a>
 <a href="#context-object">объекта контекста</a> чье
 <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> является
 <var>name</var>, и null в другом случае.
</ol>

<p>Метод
<dfn id="dom-element-getattributens" title="dom-Element-getAttributeNS"><code>getAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
  <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

  <li><p>Возвратить
  <a href="#concept-element-attributes-get" title="concept-element-attributes-get">получение атрибута</a> для
  <a href="#context-object">объекта контекста</a> используя <var>localName</var> и
  <var>namespace</var>.
</ol>

<p>Метод
<dfn id="dom-element-setattribute" title="dom-Element-setAttribute"><code>setAttribute(<var>name</var>, <var>value</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>name</var> не соответствует производному
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> в XML,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li><p>Если <a href="#context-object">context object</a> is in the <a href="#html-namespace">HTML пространство имен</a>
 и его <a href="#concept-node-document" title="concept-node-document">документ узла</a> являются
 <a href="#html-document">HTML документом</a>, сделать <var>name</var>
 <a href="#converted-to-ascii-lowercase">конвертированным в ASCII строчные</a>.

 <li><p>Сделать <var>attribute</var> первым
 <a href="#concept-attribute" title="concept-attribute">атрибутом</a> в
 <a href="#concept-element-attribute" title="concept-element-attribute">списке атрибутов</a> <a href="#context-object">объекта контекста</a>
 чье <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> является
 <var>name</var>, либо null если нет такого
 <a href="#concept-attribute" title="concept-attribute">атрибута</a>.

 <li><p>Если <var>attribute</var> является null, создать
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
 <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> является
 <var>name</var> и
 <a href="#concept-attribute-value" title="concept-attribute-value">значение</a> это <var>value</var>,
 затем <a href="#concept-element-attributes-append" title="concept-element-attributes-append">добавить</a> этот
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> к
 <a href="#context-object">объекту контекста</a> и прекратить эти шаги.

 <li><p><a href="#concept-element-attributes-change" title="concept-element-attributes-change">Изменить</a>
 <var>attribute</var> с <a href="#context-object">объекта контекста</a> на
 <var>value</var>.
</ol>

<p>Метод
<dfn id="dom-element-setattributens" title="dom-Element-setAttributeNS"><code>setAttributeNS(<var>namespace</var>, <var>name</var>, <var>value</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

 <li><p>Если <var>name</var> не соответствует производному
 <code class="external" data-anolis-spec="xml"><a href="http://www.w3.org/TR/xml/#NT-Name">Name</a></code> в XML,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li><p>Если <var>name</var> не соответствует производному
 <code class="external" data-anolis-spec="xmlns"><a href="http://www.w3.org/TR/xml-names/#NT-QName">QName</a></code> в Пространствах имен XML,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".

 <li><p>Если <var>name</var> содержит "<code>:</code>" (U+003E),
 то разделить строку на нем и сделать <var>prefix</var> первой частью и <var>localName</var> второй частью. В другом случае, сделать
 <var>prefix</var> null и <var>localName</var>
 <var>name</var>.

 <li><p>Если <var>prefix</var> не является null и
 <var>namespace</var> является null, <a href="#dfn-throw" title="concept-throw">выдать</a>
 a "<code><a href="#namespaceerror">NamespaceError</a></code>" исключение.

 <li><p>Если <var>prefix</var> является "<code>xml</code>" и
 <var>namespace</var> не в <a href="#xml-namespace">XML пространстве имен</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#namespaceerror">NamespaceError</a></code>".

 <li><p>Если <var>name</var> или <var>prefix</var> является
 "<code>xmlns</code>" и <var>namespace</var> не
 <a href="#xmlns-namespace">XMLNS пространство имен</a>, <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#namespaceerror">NamespaceError</a></code>" исключение.

 <li><p>Если <var>namespace</var> является <a href="#xmlns-namespace">XMLNS пространством имен</a>,
 и ни <var>name</var>, ни <var>prefix</var> не являются
 "<code>xmlns</code>", <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#namespaceerror">NamespaceError</a></code>" исключение.

 <li><p><a href="#concept-element-attributes-set" title="concept-element-attributes-set">Установить атрибут</a>
 для <a href="#context-object">объекта контекста</a> используя
 <var>localName</var>, <var>value</var> и также
 <var>name</var>, <var>prefix</var>,
 <var>namespace</var>.
</ol>

<p>Метод
<dfn id="dom-element-removeattribute" title="dom-Element-removeAttribute"><code>removeAttribute(<var>name</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Если <a href="#context-object">объект контекста</a> в
 <a href="#html-namespace">HTML пространстве имен</a> и его
 <a href="#concept-node-document" title="concept-node-document">документ узла</a> это
 <a href="#html-document">HTML документ</a>, сделать <var>name</var>
 <a href="#converted-to-ascii-lowercase">конвертированным в ASCII строчные</a>.

 <li><p><a href="#concept-element-attributes-remove" title="concept-element-attributes-remove">Удалить</a>
 первый <a href="#concept-attribute" title="concept-attribute">атрибут</a> из
 <a href="#context-object">объекта контекста</a> чье
 <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> является <var>name</var>, если есть.
</ol>

<p>Метод
<dfn id="dom-element-removeattributens" title="dom-Element-removeAttributeNS"><code>removeAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
  <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

  <li><p><a href="#concept-element-attributes-remove" title="concept-element-attributes-remove">Удалить</a>
  <a href="#concept-attribute" title="concept-attribute">атрибут</a> из
  <a href="#context-object">объекта контекста</a> чье
  <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> является
  <var>namespace</var> и
  <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
  <var>localName</var>, если есть.
</ol>

<p>Метод
<dfn id="dom-element-hasattribute" title="dom-Element-hasAttribute"><code>hasAttribute(<var>name</var>)</code></dfn>
должен выполнить следующие шаги:
<ol>
 <li><p>Если <a href="#context-object">объект контекста</a> в
 <a href="#html-namespace">HTML пространстве имен</a> и его
 <a href="#concept-node-document" title="concept-node-document">документ узла</a> это
 <a href="#html-document">HTML документ</a>, сделать <var>name</var>
 <a href="#converted-to-ascii-lowercase">конвертированным в ASCII строчные</a>.

 <li><p>Возвратить true если <a href="#context-object">объект контекста</a>
 <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
 <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> это
 <var>name</var>, и false в другом случае.
</ol>

<p>Метод
<dfn id="dom-element-hasattributens" title="dom-Element-hasAttributeNS"><code>hasAttributeNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>namespace</var> является пустой строкой, установить его к null.

 <li><p>Возвратить true если <a href="#context-object">объект контекста</a>
 <a href="#concept-element-attribute-has" title="concept-element-attribute-has">имеет</a>
 <a href="#concept-attribute" title="concept-attribute">атрибут</a> чье
 <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> это <var>namespace</var>
 и <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
 <var>localName</var>, и false в другом случае.
</ol>

<!--<dfn title=dom-Element-getAttributeNode>getAttributeNode</dfn>: when the
Element.getAttributeNode() method is invoked on an HTML element, the name
argument must be converted to ASCII lowercase before the element's attributes
are examined. (In HTML documents.) -->

<!-- <dfn title=dom-Element-setAttributeNode>setAttributeNode</dfn>: when an
Attr node is set on an HTML element using Element.setAttributeNode(), it must
have its name converted to ASCII lowercase before the element is affected.
(In HTML documents.) -->

<hr>

<p>Метод
<dfn id="dom-element-getelementsbytagname" title="dom-Element-getElementsByTagName"><code>getElementsByTagName(<var>localName</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbytagname" title="concept-getElementsByTagName">список элементов с локальным именем <var>localName</var></a>
для <a href="#context-object">объекта контекста</a>.

<p>Метод
<dfn id="dom-element-getelementsbytagnamens" title="dom-Element-getElementsByTagNameNS"><code>getElementsByTagNameNS(<var>namespace</var>, <var>localName</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbytagnamens" title="concept-getElementsByTagNameNS">список элементов с пространством имен <var>namespace</var> и локальным именем <var>localName</var></a> для <a href="#context-object">объекта контекста</a>.

<p>Метод
<dfn id="dom-element-getelementsbyclassname" title="dom-Element-getElementsByClassName"><code>getElementsByClassName(<var>classNames</var>)</code></dfn>
должен возвратить
<a href="#concept-getelementsbyclassname" title="concept-getElementsByClassName">список элементов с именами классов <var>classNames</var></a>
для <a href="#context-object">объекта контекста</a>.
<!--
<h4 id="interface-namednodemap"><span class="secno">4.8.1 </span>Interface <code><a href="#namednodemap">NamedNodeMap</a></code></h4>
<pre class="idl">[Exposed=Window]
interface <dfn class="idl-code" data-dfn-type="interface" data-export="" id="namednodemap">NamedNodeMap<a class="self-link" href="#namednodemap"></a></dfn> {
  readonly attribute unsigned long <a class="idl-code" data-link-type="attribute" data-readonly="" data-type="unsigned long " href="#dom-namednodemap-length">length</a>;
  getter <a data-link-type="idl-name" href="#attr">Attr</a>? <a class="idl-code" data-link-type="method" href="#dom-namednodemap-item">item</a>(unsigned long <dfn class="idl-code" data-dfn-for="NamedNodeMap/item(index)" data-dfn-type="argument" data-export="" id="dom-namednodemap-item-index-index">index<a class="self-link" href="#dom-namednodemap-item-index-index"></a></dfn>);
  getter <a data-link-type="idl-name" href="#attr">Attr</a>? <a class="idl-code" data-link-type="method" href="#dom-namednodemap-getnameditem">getNamedItem</a>(DOMString <dfn class="idl-code" data-dfn-for="NamedNodeMap/getNamedItem(name)" data-dfn-type="argument" data-export="" id="dom-namednodemap-getnameditem-name-name">name<a class="self-link" href="#dom-namednodemap-getnameditem-name-name"></a></dfn>);
  <a data-link-type="idl-name" href="#attr">Attr</a>? <a id="dfnReturnLink-0" class="idl-code" data-link-type="method" href="#dom-namednodemap-getnameditemns">getNamedItemNS</a>(DOMString? <dfn class="idl-code" data-dfn-for="NamedNodeMap/getNamedItemNS(namespace, localName)" data-dfn-type="argument" data-export="" id="dom-namednodemap-getnameditemns-namespace-localname-namespace">namespace<a class="self-link" href="#dom-namednodemap-getnameditemns-namespace-localname-namespace"></a></dfn>, DOMString <dfn class="idl-code" data-dfn-for="NamedNodeMap/getNamedItemNS(namespace, localName)" data-dfn-type="argument" data-export="" id="dom-namednodemap-getnameditemns-namespace-localname-localname">localName<a class="self-link" href="#dom-namednodemap-getnameditemns-namespace-localname-localname"></a></dfn>);
  <a data-link-type="idl-name" href="#attr">Attr</a>? <a class="idl-code" data-link-type="method" href="#dom-namednodemap-setnameditem">setNamedItem</a>(<a data-link-type="idl-name" href="#attr">Attr</a> <dfn class="idl-code" data-dfn-for="NamedNodeMap/setNamedItem(attr)" data-dfn-type="argument" data-export="" id="dom-namednodemap-setnameditem-attr-attr">attr<a class="self-link" href="#dom-namednodemap-setnameditem-attr-attr"></a></dfn>);
  <a data-link-type="idl-name" href="#attr">Attr</a>? <a class="idl-code" data-link-type="method" href="#dom-namednodemap-setnameditemns">setNamedItemNS</a>(<a data-link-type="idl-name" href="#attr">Attr</a> <dfn class="idl-code" data-dfn-for="NamedNodeMap/setNamedItemNS(attr)" data-dfn-type="argument" data-export="" id="dom-namednodemap-setnameditemns-attr-attr">attr<a class="self-link" href="#dom-namednodemap-setnameditemns-attr-attr"></a></dfn>);
  <a data-link-type="idl-name" href="#attr">Attr</a> <a class="idl-code" data-link-type="method" href="#dom-namednodemap-removenameditem">removeNamedItem</a>(DOMString <dfn class="idl-code" data-dfn-for="NamedNodeMap/removeNamedItem(name)" data-dfn-type="argument" data-export="" id="dom-namednodemap-removenameditem-name-name">name<a class="self-link" href="#dom-namednodemap-removenameditem-name-name"></a></dfn>);
  <a data-link-type="idl-name" href="#attr">Attr</a> <a class="idl-code" data-link-type="method" href="#dom-namednodemap-removenameditemns">removeNamedItemNS</a>(DOMString? <dfn class="idl-code" data-dfn-for="NamedNodeMap/removeNamedItemNS(namespace, localName)" data-dfn-type="argument" data-export="" id="dom-namednodemap-removenameditemns-namespace-localname-namespace">namespace<a class="self-link" href="#dom-namednodemap-removenameditemns-namespace-localname-namespace"></a></dfn>, DOMString <dfn class="idl-code" data-dfn-for="NamedNodeMap/removeNamedItemNS(namespace, localName)" data-dfn-type="argument" data-export="" id="dom-namednodemap-removenameditemns-namespace-localname-localname">localName<a class="self-link" href="#dom-namednodemap-removenameditemns-namespace-localname-localname"></a></dfn>);
};
</pre>
<p>
A <code class="idl"><a data-link-type="idl" href="#namednodemap">NamedNodeMap</a></code> has an associated <dfn data-dfn-for="NamedNodeMap" data-dfn-type="dfn" data-export="" id="concept-NamedNodeMap-element">element<a class="self-link" href="#concept-NamedNodeMap-element"></a></dfn> (an <a data-link-type="dfn" href="#concept-element">element</a>).</p>
   <p>A <code class="idl"><a data-link-type="idl" href="#namednodemap">NamedNodeMap</a></code> object’s <dfn data-dfn-for="NamedNodeMap" data-dfn-type="dfn" data-export="" id="concept-NamedNodeMap-attribute">attribute list<a class="self-link" href="#concept-NamedNodeMap-attribute"></a></dfn> is its <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>’s <a data-link-type="dfn" href="#concept-element-attribute">attribute list</a>.</p>
   <hr>
   <p>A <code class="idl"><a data-link-type="idl" href="#namednodemap">NamedNodeMap</a></code> object’s <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-supported-property-indices">supported property indices</a> are the numbers in the
range zero to the number of <a data-link-type="dfn" href="#concept-attribute">attributes</a> in its <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a> map minus one, unless the <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a> is empty, in which case
there are no <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-supported-property-indices">supported property indices</a>.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="attribute" data-export="" id="dom-namednodemap-length">length<a class="self-link" href="#dom-namednodemap-length"></a></dfn> attribute’s getter
must return the number of <a data-link-type="dfn" href="#concept-attribute">attributes</a> in the <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a>.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-item">item(<var>index</var>)<a class="self-link" href="#dom-namednodemap-item"></a></dfn> method,
when invoked, must run these steps:</p>
   <ol>
    <li>If <var>index</var> is equal to or greater than the number of <a data-link-type="dfn" href="#concept-attribute">attributes</a> in the <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a>, return null.
    </li><li>Otherwise, return the <var>index</var>th <a data-link-type="dfn" href="#concept-attribute">attribute</a> in the <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a>.
   </li></ol>
   <p>A <code class="idl"><a data-link-type="idl" href="#namednodemap">NamedNodeMap</a></code> object’s <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-supported-property-names">supported property names</a>, all <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-unenumerable">unenumerable</a>, are the <a data-link-type="dfn" href="#concept-attribute-name">names</a> of the <a data-link-type="dfn" href="#concept-attribute">attributes</a> in the <a data-link-type="dfn" href="#concept-NamedNodeMap-attribute">attribute list</a>, in order.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-getnameditem">getNamedItem(<var>name</var>)<a class="self-link" href="#dom-namednodemap-getnameditem"></a></dfn> method, when invoked, must return the result of <a data-link-type="dfn" href="#concept-element-attributes-get-by-name">getting an attribute</a> given <var>name</var> and <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-getnameditemns">getNamedItemNS(<var>namespace</var>, <var>localName</var>)<a class="self-link" href="#dom-namednodemap-getnameditemns"></a></dfn> method, when invoked, must return the result of <a data-link-type="dfn" href="#concept-element-attributes-get-by-namespace">getting an attribute</a> given <var>namespace</var>, <var>localName</var>, and <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-setnameditem">setNamedItem(<var>attr</var>)<a class="self-link" href="#dom-namednodemap-setnameditem"></a></dfn> method, when invoked, must return the result of <a data-link-type="dfn" href="#concept-element-attributes-set">setting an attribute</a> given <var>attr</var> and <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>. Rethrow
any exceptions.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-setnameditemns">setNamedItemNS(<var>attr</var>)<a class="self-link" href="#dom-namednodemap-setnameditemns"></a></dfn> method, when invoked, must return the result of <a data-link-type="dfn" href="#concept-element-attributes-set">setting an attribute</a> given <var>attr</var>, <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>, and <i>namespace and local name flag</i> set. Rethrow any exceptions.</p>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-removenameditem">removeNamedItem(<var>name</var>)<a class="self-link" href="#dom-namednodemap-removenameditem"></a></dfn> method, when invoked, must run these steps:</p>
   <ol>
    <li>Let <var>attr</var> be the result of <a data-link-type="dfn" href="#concept-element-attributes-remove-by-name">removing an attribute</a> given <var>name</var> and <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>.
    </li><li>If <var>attr</var> is null, <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-throw">throw</a> a <code class="idl"><a data-link-type="idl" href="https://heycam.github.io/webidl/#notfounderror">NotFoundError</a></code> exception.
    </li><li>Return <var>attr</var>.
   </li></ol>
   <p>The <dfn class="idl-code" data-dfn-for="NamedNodeMap" data-dfn-type="method" data-export="" id="dom-namednodemap-removenameditemns">removeNamedItemNS(<var>namespace</var>, <var>localName</var>)<a class="self-link" href="#dom-namednodemap-removenameditemns"></a></dfn> method, when invoked, must run these steps:</p>
   <ol>
    <li>Let <var>attr</var> be the result of <a data-link-type="dfn" href="#concept-element-attributes-remove-by-namespace">removing an attribute</a> given <var>namespace</var>, <var>localName</var>, and <a data-link-type="dfn" href="#concept-NamedNodeMap-element">element</a>.
    </li><li>If <var>attr</var> is null, <a data-link-type="dfn" href="https://heycam.github.io/webidl/#dfn-throw">throw</a> a <code class="idl"><a data-link-type="idl" href="https://heycam.github.io/webidl/#notfounderror">NotFoundError</a></code> exception.
    </li><li>Return <var>attr</var>.
   </li></ol>
-->
<h4 id="interface-attr"><span class="secno">4.8.1 </span>Интерфейс <code><a href="#attr">Attr</a></code></h4>
<pre class="idl">[Exposed=Window]
interface <dfn id="attr">Attr</dfn> {
  readonly attribute DOMString? <a href="#dom-attr-namespaceuri" title="dom-Attr-namespaceURI">namespaceURI</a>;
  readonly attribute DOMString? <a href="#dom-attr-prefix" title="dom-Attr-prefix">prefix</a>;
  readonly attribute DOMString <a href="#dom-attr-localname" title="dom-Attr-localName">localName</a>;
  readonly attribute DOMString <a href="#dom-attr-name" title="dom-Attr-name">name</a>;
           attribute DOMString <a href="#dom-attr-value" title="dom-Attr-value">value</a>;

  readonly attribute boolean <a href="#dom-attr-specified" title="dom-Attr-specified">specified</a>; // useless; always returns true
};</pre>

<p>Объекты <code><a href="#attr">Attr</a></code> проще называются
<dfn id="concept-attribute" title="concept-attribute">атрибутами</dfn>. Их иногда называют
<em>атрибутами контента</em>, чтобы избежать путаницы с IDL атрибутами.

<p><a href="#concept-attribute" title="concept-attribute">Атрибуты</a> имеют
<dfn id="concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</dfn> (null или не-пустая строка),
<dfn id="concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</dfn> (null или не-пустая строка),
<dfn id="concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</dfn> (не-пустая строка),
<dfn id="concept-attribute-name" title="concept-attribute-name">имя</dfn> (не-пустая строка),
<dfn id="concept-attribute-value" title="concept-attribute-value">значение</dfn> (строка) и
<dfn id="concept-attribute-element" title="concept-attribute-element">элемент</dfn> (null или
<a href="#concept-element" title="concept-element">элемент</a>).

<p class="note">Заметка: Если бы были разработаны сегодня, они бы имели просто имя и значение.

<p>Когда <a href="#concept-attribute" title="concept-attribute">атрибут</a> создан, его
<a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> и
<a href="#concept-attribute-value" title="concept-attribute-value">значение</a> всегда заданы. Если не заданы явно
при создании <a href="#concept-attribute" title="concept-attribute">атрибута</a>, его <a href="#concept-attribute-name" title="concept-attribute-name">имя</a> идентично его <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальному имени</a>,
его <a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> и
<a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a> являются null.

<p>
<dfn id="concept-named-attribute" title="concept-named-attribute">Атрибут <code><var>A</var></code></dfn>
является <a href="#concept-attribute" title="concept-attribute">атрибутом</a>, чье
<a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> это
<code><var>A</var></code> и чьи
<a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a> и
<a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a> являются
null.

<p>Атрибут <dfn id="dom-attr-namespaceuri" title="dom-Attr-namespaceURI"><code>namespaceURI</code></dfn>
должен возвратить
<a href="#concept-attribute-namespace" title="concept-attribute-namespace">пространство имен</a>.

<p>Атрибут <dfn id="dom-attr-prefix" title="dom-Attr-prefix"><code>prefix</code></dfn> должен возвратить
<a href="#concept-attribute-namespace-prefix" title="concept-attribute-namespace-prefix">префикс пространства имен</a>.

<p>Атрибут <dfn id="dom-attr-localname" title="dom-Attr-localName"><code>localName</code></dfn>
должен возвратить <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a>.

<p>Получатель атрибута <dfn id="dom-attr-name" title="dom-Attr-name"><code>name</code></dfn> должен возвратить
<a href="#concept-attribute-name" title="concept-attribute-name">имя</a>.

<p>Получатель атрибута <dfn id="dom-attr-value" title="dom-Attr-value"><code>value</code></dfn> и получатель атрибута
<dfn id="dom-attr-textcontent" title="dom-Attr-textContent"><code>textContent</code></dfn> должны (оба)
возвратить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a>.

<p>Установка атрибута <code title="dom-Attr-value"><a href="#dom-attr-value">value</a></code> должна
<a href="#concept-element-attributes-change" title="concept-element-attributes-change">изменить</a>
<a href="#concept-attribute-value" title="concept-attribute-value">значение</a> к новому значению.

<p>Установщик атрибута <code title="dom-Attr-value"><a href="#dom-attr-value">value</a></code> и установщик атрибута
<code title="dom-Attr-textContent"><a href="#dom-attr-textcontent">textContent</a></code> должны (оба) выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#concept-attribute-element" title="concept-attribute-element">элемент</a> <a href="#context-object">объекта контекста</a> является null, установить <a href="#concept-attribute-value" title="concept-attribute-value">значение</a>
 <a href="#context-object">объекта контекста</a> к заданному значению.
<li>В другом случае, <a data-link-type="dfn" href="#concept-element-attributes-change">изменить</a> <a data-link-type="dfn" href="#context-object">объект контекста</a> с <a data-link-type="dfn" href="#concept-attribute-element">элемента</a> <a data-link-type="dfn" href="#context-object">объекта контекста</a> на заданное значение.
   </li></ol>
   <p class="note no-backref" role="note">В отличие от <a data-link-type="dfn" href="#concept-attribute-element">элемента</a> <a data-link-type="dfn" href="#concept-node">узла</a>, никакой специальной обработки null не требуется. </p>

<p>Атрибут <dfn id="dom-attr-specified" title="dom-Attr-specified"><code>specified</code></dfn> должен возвратить true.


<h3 id="interface-characterdata"><span class="secno">4.9 </span>Интерфейс <code><a href="#characterdata">CharacterData</a></code></h3>
<pre class="idl">[Exposed=Window]
interface <dfn id="characterdata">CharacterData</dfn> : <a href="#node">Node</a> {
  [TreatNullAs=EmptyString] attribute DOMString <a href="#dom-characterdata-data" title="dom-CharacterData-data">data</a>;
  readonly attribute unsigned long <a href="#dom-characterdata-length" title="dom-CharacterData-length">length</a>;
  DOMString <a href="#dom-characterdata-substringdata" title="dom-CharacterData-substringData">substringData</a>(unsigned long <var>offset</var>, unsigned long <var>count</var>);
  void <a href="#dom-characterdata-appenddata" title="dom-CharacterData-appendData">appendData</a>(DOMString <var>data</var>);
  void <a href="#dom-characterdata-insertdata" title="dom-CharacterData-insertData">insertData</a>(unsigned long <var>offset</var>, DOMString <var>data</var>);
  void <a href="#dom-characterdata-deletedata" title="dom-CharacterData-deleteData">deleteData</a>(unsigned long <var>offset</var>, unsigned long <var>count</var>);
  void <a href="#dom-characterdata-replacedata" title="dom-CharacterData-replaceData">replaceData</a>(unsigned long <var>offset</var>, unsigned long <var>count</var>, DOMString <var>data</var>);
};</pre>

<p class="note">Заметка: <code><a href="#characterdata">CharacterData</a></code> является абстрактным интерфейсом и не
существует в виде <a href="#concept-node" title="concept-node">узла</a>. Он используется <a href="#concept-node" title="concept-node">узлами</a>
<code><a href="#text">Text</a></code>, <code><a href="#comment">Comment</a></code> и
<code><a href="#processinginstruction">ProcessingInstruction</a></code>.

<p>Каждый <a href="#concept-node" title="concept-node">узел</a> наследующий интерфейс
<code><a href="#characterdata">CharacterData</a></code> имеет ассоциированную подверженную изменениям строку
под названием <dfn id="concept-cd-data" title="concept-CD-data">данные</dfn>.

<p>Чтобы <dfn id="concept-cd-replace" title="concept-CD-replace">заменить данные</dfn> узла
<var>node</var> на смещение <var>offset</var>, подсчет
<var>count</var> и данные <var>data</var>, выполнить следующие шаги:</p>

<ol>
 <li><p>Сделать <var>length</var> значением атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> <var>node</var>-ы.

 <li><p>Если <var>offset</var> больше чем <var>length</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>".

 <li><p>Если <var>offset</var> плюс <var>count</var> больше чем <var>length</var>, сделать <var>count</var> результатом
 <var>length</var> минус <var>offset</var>.

 <li><p><a href="#queue-a-mutation-record">Поставить в очередь запись изменения</a> "<code><a href="#characterdata">characterData</a></code>"
 для <var>node</var> с oldValue <a href="#concept-cd-data" title="concept-CD-data">данными</a> <var>node</var>.

 <li><p>Вставить <var>data</var> в <a href="#concept-cd-data" title="concept-CD-data">данные</a> <var>node</var>-ы после <var>offset</var>
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a>.

 <li><p>Сделать <var>delete offset</var> результатом <var>offset</var> плюс
 количество
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a> в
 <var>data</var>.

 <li><p>Начиная с <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a> <var>delete offset</var>, удалить
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единицы кода</a> <var>count</var> из <a href="#concept-cd-data" title="concept-CD-data">данных</a>
 <var>node</var>.

 <!-- ranges -->
 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
 <var>node</var> и
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> больше чем
 <var>offset</var>, но менее или равно <var>offset</var>
 плюс <var>count</var>, установить его
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> к
 <var>offset</var>.

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
 <var>node</var> и
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> больше чем
 <var>offset</var>, но менее или равно <var>offset</var>
 плюс <var>count</var>, установить его
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> к
 <var>offset</var>.

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
 <var>node</var> и
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> больше чем
 <var>offset</var> плюс <var>count</var>, увеличить его
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> на количество
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a> в
 <var>data</var>, затем уменьшить его на <var>count</var>.

 <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
 <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
 <var>node</var> и
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> больше чем
 <var>offset</var> плюс <var>count</var>, увеличить его
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> на количество
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a> в
 <var>data</var>, затем уменьшить его на <var>count</var>.
</ol>
<!-- delete happens after insert for better cursor positioning with editing
https://www.w3.org/Bugs/Public/show_bug.cgi?id=13153 -->

<!-- If you set a node's data to a new value (e.g., using the data
attribute):

IE 9: Acts like the node was deleted and recreated, moves the boundary
points up to the parent
Firefox 4: Resets the offset to 0, always
Chrome 11 dev: Resets the offset to 0, except it does nothing if the new
data is the same as the old data
Opera 11: Sets a start offset to 0 and an end offset to the end of the
data, always

The spec originally followed WebKit, since it seemed to make the most sense.
Opera's approach of setting end offsets to the length of the new data
arguably makes more sense, but that's debatable, and it's greatly
outnumbered. However, after some feedback by bzbarsky that checking for
equality is expensive, I removed the special case and matched Firefox:

https://www.w3.org/Bugs/Public/show_bug.cgi?id=13250

Authors who want WebKit-like behavior can always use replaceData() instead.

XXX replaceData is the same as setting data these days -->


<p>Чтобы <dfn id="concept-cd-substring" title="concept-CD-substring">извлечь данные</dfn> с узла
<var>node</var>, смещения <var>offset</var> и подсчета
<var>count</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>length</var> значением атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> <var>node</var>.

 <li><p>Если <var>offset</var> больше чем <var>length</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>" исключение.

 <li><p>Если <var>offset</var> плюс <var>count</var>
 больше чем <var>length</var>, возвратить строку чье значение это
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единицы кода</a> от
 <var>offset</var><sup>-й</sup>
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit">единицы кода</a> до конца
 <a href="#concept-cd-data" title="concept-CD-data">данных</a> <var>node</var>, и затем прекратить данные шаги.

 <li><p>Возвратить строку чье значение это
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единицы кода</a> от
 <var>offset</var><sup>-й</sup>
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit">единицы кода</a> до
 <var>offset</var>+<var>count</var><sup>-й</sup>
 <a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit">единицы кода</a> в <a href="#concept-cd-data" title="concept-CD-data">данных</a> <var>node</var>.
</ol>

<p>Атрибут <dfn id="dom-characterdata-data" title="dom-CharacterData-data"><code>data</code></dfn> должен возвратить <a href="#concept-cd-data" title="concept-CD-data">данные</a>, а при установке, должен
<a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
<a href="#context-object">объекта контекста</a> смещение 0, подсчет на значение атрибута
<code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> и данные на новое значение.

<p>Атрибут <dfn id="dom-characterdata-length" title="dom-CharacterData-length"><code>length</code></dfn>
должен возвратить количество
<a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-code-unit" title="code unit">единиц кода</a> в
<a href="#concept-cd-data" title="concept-CD-data">данных</a>.

<p>Метод
<dfn id="dom-characterdata-substringdata" title="dom-CharacterData-substringData"><code>substringData(<var>offset</var>, <var>count</var>)</code></dfn>
должен <a href="#concept-cd-substring" title="concept-CD-substring">извлечь данные</a> из узла
<a href="#context-object">объекта контекста</a>, смещения <var>offset</var> и подсчета <var>count</var>.

<p>Метод
<dfn id="dom-characterdata-appenddata" title="dom-CharacterData-appendData"><code>appendData(<var>data</var>)</code></dfn>
должен <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
<a href="#context-object">объекта контекста</a>, смещение на значение атрибута
<code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code>, подсчет 0, и данные <var>data</var>.

<p>Метод
<dfn id="dom-characterdata-insertdata" title="dom-CharacterData-insertData"><code>insertData(<var>offset</var>, <var>data</var>)</code></dfn>
должен <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
<a href="#context-object">объекта контекста</a>, смещение <var>offset</var>, подсчет 0, и данные <var>data</var>.

<p>Метод
<dfn id="dom-characterdata-deletedata" title="dom-CharacterData-deleteData"><code>deleteData(<var>offset</var>, <var>count</var>)</code></dfn>
должен <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
<a href="#context-object">объекта контекста</a>, смещение <var>offset</var>, подсчет
<var>count</var> и данные на пустую строку.

<p>Метод
<dfn id="dom-characterdata-replacedata" title="dom-CharacterData-replaceData"><code>replaceData(<var>offset</var>, <var>count</var>, <var>data</var>)</code></dfn>
должен <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
<a href="#context-object">объекта контекста</a>, смещение <var>offset</var>, подсчет
<var>count</var> и данные <var>data</var>.


<h3 id="interface-text"><span class="secno">4.10 </span>Интерфейс <code><a href="#text">Text</a></code></h3>
<pre class="idl">[<a href="#dom-text" title="dom-Text">Constructor</a>(optional DOMString <var>data</var> = ""),
 Exposed=Window]
interface <dfn id="text">Text</dfn> : <a href="#characterdata">CharacterData</a> {
  [NewObject] <a href="#text">Text</a> <a href="#dom-text-splittext" title="dom-Text-splitText">splitText</a>(unsigned long <var>offset</var>);
  readonly attribute DOMString <a href="#dom-text-wholetext" title="dom-Text-wholeText">wholeText</a>;
};</pre>

<dl class="domintro">
 <dt><code><var>text</var> = new <a href="#dom-documentfragment" title="dom-DocumentFragment">Text</a>([<var>data</var> = ""])</code>
 <dd><p>Возвращает новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>, чьи данные
 <a href="#concept-cd-data" title="concept-CD-data">data</a> это <var>data</var>.

 <dt><code><var>text</var> . <a href="#dom-text-splittext" title="dom-Text-splitText">splitText</a>(<var>offset</var>)</code>
 <dd><p>Разделяет <a href="#concept-cd-data" title="concept-CD-data">данные</a> на заданном
 <var>offset</var> и возвращает остальное как <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code>.

 <dt><code><var>text</var> . <a href="#dom-text-wholetext" title="dom-Text-wholeText">wholeText</a></code>
 <dd><p>Возвращает комбинированные <a href="#concept-cd-data" title="concept-CD-data">данные</a> всех прямых <a href="#concept-tree-sibling" title="concept-tree-sibling">сестринских</a> <a href="#concept-node" title="concept-node">узла</a>
 <code><a href="#text">Text</a></code>.
</dl>

<p>Конструктор <dfn id="dom-text" title="dom-Text"><code>Text(<var>data</var>)</code></dfn>
должен возвратить новый <a href="#concept-node" title="concept-node">node</a> <code><a href="#text">Text</a></code>, чьи
<a href="#concept-cd-data" title="concept-CD-data">данные</a> это <var>data</var> и
<a href="#concept-node-document" title="concept-node-document">документ узла</a> это ассоциированный <a href="#concept-document" title="concept-document">документ</a> глобального объекта.

<p>Чтобы <dfn id="concept-text-split" title="concept-Text-split">разделить</dfn> <a href="#concept-node" title="concept-node">узел</a> <code><a href="#text">Text</a></code> <var>node</var> со смещением
<var>offset</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>length</var> значением атрибута <code title="dom-CharacterData-length"><a href="#dom-characterdata-length">length</a></code> <var>node</var>.

 <li><p>Если <var>offset</var> больше чем <var>length</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>" исключение.

 <li><p>Сделать <var>count</var> результатом <var>length</var> минус
 <var>offset</var>.

 <li><p>Сделать <var>new data</var> результатом
 <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
 <var>node</var>, смещения <var>offset</var> и подсчета
 <var>count</var>.

 <li><p>Сделать <var>new node</var> новым <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#text">Text</a></code>, с тем же
 <a href="#concept-node-document" title="concept-node-document">документом узла</a> что и
 <var>node</var>. Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a> <var>new node</var> к <var>new data</var>.

 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li>
  <p>Если <var>parent</var> не является null, выполнить следующие шаги:

  <ol>
   <li><p><a href="#concept-node-insert" title="concept-node-insert">Вставить</a>
   <var>new node</var> в <var>parent</var> перед
   <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>node</var>.
   <!-- Do this before we replace data, so that the data replacement won't
   mutate ranges prematurely:
   https://www.w3.org/Bugs/Public/show_bug.cgi?id=15325 -->

   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
   <var>node</var> и
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> больше чем
   <var>offset</var>, установить его
   <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> к
   <var>new node</var> и уменьшить его
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> на
   <var>offset</var>.

   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
   <var>node</var> и
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> больше чем
   <var>offset</var>, установить его
   <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> к
   <var>new node</var> и уменьшить его
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> на
   <var>offset</var>.

   <!-- This shit is complicated:
        https://www.w3.org/Bugs/Public/show_bug.cgi?id=19968 -->
   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
   <var>parent</var> и
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> равняется
   <a href="#concept-tree-index" title="concept-tree-index">индексу</a>
   <var>node</var> + 1, увеличить его
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> на один.

   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
   <var>parent</var> и
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> равняется
   <a href="#concept-tree-index" title="concept-tree-index">индексу</a>
   <var>node</var> + 1, увеличить его
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> на один.
  </ol>

 <li><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
 <var>node</var>, смещение <var>offset</var>, подсчет
 <var>count</var> и данные на пустую строку.

 <li>
  <p>Если <var>parent</var> является null, выполнить следующие подшаги:</p>

  <ol>
   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> это
   <var>node</var> и
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> больше
   чем <var>offset</var>, установить его
   <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> к
   <var>offset</var>.

   <li><p>Для каждого <a href="#concept-range" title="concept-range">диапазона</a>, чей
   <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> это
   <var>node</var> и
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> больше чем
   <var>offset</var>, установить его
   <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> к
   <var>offset</var>.
  </ol>

 <li><p>Возвратить <var>new node</var>.
</ol>

<p>Метод
<dfn id="dom-text-splittext" title="dom-Text-splitText"><code>splitText(<var>offset</var>)</code></dfn>
должен <a href="#concept-text-split" title="concept-Text-split">разделить</a>
<a href="#context-object">объект контекста</a> со смещением <var>offset</var>.


<p><dfn id="contiguous-text-nodes">Смежные <code>Text</code> узлы</dfn> узла это сам узел, <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущий сестринский</a>
<code><a href="#text">Text</a></code> узел (если есть) и его
<a href="#contiguous-text-nodes">смежные <code>Text</code> узлы</a>, и
<a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующий сестринский</a> <code><a href="#text">Text</a></code>
узел (если есть) со своими <a href="#contiguous-text-nodes">смежными <code>Text</code> узлами</a>, избегая дубликатов.

<p>Атрибут <dfn id="dom-text-wholetext" title="dom-Text-wholeText"><code>wholeText</code></dfn>
должен возвратить конкатенацию
<a href="#concept-cd-data" title="concept-CD-data">данных</a>
<a href="#contiguous-text-nodes">смежных <code>Text</code> узлов</a>
<a href="#context-object">объекта контекста</a>, в
<a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.



<h3 id="interface-processinginstruction"><span class="secno">4.11 </span>Интерфейс <code><a href="#processinginstruction">ProcessingInstruction</a></code></h3>
<pre class="idl">[Exposed=Window]
interface <dfn id="processinginstruction">ProcessingInstruction</dfn> : <a href="#characterdata">CharacterData</a> {
  readonly attribute DOMString <a href="#dom-processinginstruction-target" title="dom-ProcessingInstruction-target">target</a>;
};</pre>

<p><a href="#concept-node" title="concept-node">Узлы</a> <code><a href="#processinginstruction">ProcessingInstruction</a></code>
имеют ассоциированную <dfn id="concept-pi-target" title="concept-PI-target">цель</dfn>.

<p>Атрибут <dfn id="dom-processinginstruction-target" title="dom-ProcessingInstruction-target"><code>target</code></dfn>
должен возвратить <a href="#concept-pi-target" title="concept-PI-target">цель</a>.



<h3 id="interface-comment"><span class="secno">4.12 </span>Интерфейс <code><a href="#comment">Comment</a></code></h3>
<pre class="idl">[<a href="#dom-comment" title="dom-Comment">Constructor</a>(optional DOMString <var>data</var> = ""),
 Exposed=Window]
interface <dfn id="comment">Comment</dfn> : <a href="#characterdata">CharacterData</a> {
};</pre>

<dl class="domintro">
 <dt><code><var>comment</var> = new <a href="#dom-comment" title="dom-Comment">Comment</a>([<var>data</var> = ""])</code>
 <dd><p>Возвращает новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#comment">Comment</a></code>, чьи
 <a href="#concept-cd-data" title="concept-CD-data">данные</a> являются <var>data</var>.
</dl>

<p>Конструктор <dfn id="dom-comment" title="dom-Comment"><code>Comment(<var>data</var>)</code></dfn>
должен возвратить новый <a href="#concept-node" title="concept-node">узел</a> <code><a href="#comment">Comment</a></code>, чьи <a href="#concept-cd-data" title="concept-CD-data">данные</a> являются <var>data</var> и
<a href="#concept-node-document" title="concept-node-document">документ узла</a> это ассоциированный <a href="#concept-document" title="concept-document">документ</a> глобального объекта.




<h2 id="ranges"><span class="secno">5 </span>Диапазоны</h2>

<h3 id="introduction-to-dom-ranges"><span class="secno">5.1 </span>Введение в "DOM Ranges"</h3>

<p>Объект <code><a href="#range">Range</a></code> (<a href="#concept-range" title="concept-range">диапазон</a>)
представляет собой последовательность содержания в
<a href="#concept-node-tree" title="concept-node-tree">дереве узлов</a>. Каждый
<a href="#concept-range" title="concept-range">диапазон</a> имеет
<a href="#concept-range-start" title="concept-range-start">начало</a> и
<a href="#concept-range-end" title="concept-range-end">конец</a>, которые являются
<a href="#concept-range-bp" title="concept-range-bp">конечными точками</a>.
<a href="#concept-range-bp" title="concept-range-bp">Конечная точка</a> является набором, содержащим
<a href="#concept-node" title="concept-node">узел</a> и не-отрицательное числовое
<a href="#concept-range-bp-offset" title="concept-range-bp-offset">смещение</a>. Так что другими словами,
<a href="#concept-range" title="concept-range">диапазон</a> представляет собой часть содержания внутри
<a href="#concept-node-tree" title="concept-node-tree">дерева элементов</a> между двумя
<a href="#concept-range-bp" title="concept-range-bp">конечными точками</a>.

<p><a href="#concept-range" title="concept-range">Диапазоны</a> часто используются при редактировании
для выделения и копирования контента.

<ul class="domTree">
 <li class="t1"><a href="#concept-element" title="concept-element">Element</a>: <code>p</code>
  <ul>
   <li class="t1"><a href="#concept-element" title="concept-element">Element</a>: <code>img</code> <span class="t2"><code class="attribute name">src</code>="<code class="attribute value">insanity-wolf</code>"</span> <span class="t2"><code class="attribute name">alt</code>="<code class="attribute value">Little-endian BOM; decode as big-endian!</code>"</span>
   <li class="t3"><code><a href="#text">Text</a></code>: <span> CSS 2.1 syndata is </span>
   <li class="t1"><a href="#concept-element" title="concept-element">Element</a>: <code>em</code>
    <ul>
     <li class="t3"><code><a href="#text">Text</a></code>: <span>awesome</span>
    </ul>
   <li class="t3"><code><a href="#text">Text</a></code>: <span>!</span>
  </ul>
</ul>
<!-- http://w3cmemes.tumblr.com/post/35332222321/css-2-1-syndata-is-awesome -->

<p>В <a href="#concept-node-tree" title="concept-node-tree">дереве узлов</a> выше,
<a href="#concept-range" title="concept-range">диапазон</a> может использоваться для представления предложения
“syndata is awes”. Предполагая, что <var>p</var> присваивается
<code>p</code> <a href="#concept-element" title="concept-element">элементу</a> и
<var>em</var> присваивается <code>em</code>
<a href="#concept-element" title="concept-element">элементу</a>, это можно сделать следующим образом:

<pre><code>var range = new Range(),
    firstText = p.childNodes[1],
    secondText = em.firstChild
range.setStart(firstText, 9) // не забудьте пробел
range.setEnd(secondText, 4)
// теперь диапазон принадлежит к вышеупомянутой цитате</code></pre>

<p class="note">Заметка: <a href="#concept-attribute" title="concept-attribute">Атрибуты</a> такие как
<code>src</code> и <code>alt</code> в
<a href="#concept-node-tree" title="concept-node-tree">дереве узлов</a> выше не могут быть представлены
с помощью <a href="#concept-range" title="concept-range">диапазона</a>. Концепт
<a href="#concept-range" title="concept-range">диапазонов</a> полезен только для
<a href="#concept-node" title="concept-node">узлов</a>.

<p><a href="#concept-range" title="concept-range">Диапазоны</a> подвержены изменениям в
<a href="#concept-node-tree" title="concept-node-tree">дереве узлов</a>. Такие изменения не будут
делать <a href="#concept-range" title="concept-range">диапазон</a> недействительным, и будут пытаться обеспечить,
что <a href="#concept-range" title="concept-range">диапазон</a> все еще представляет ту же
часть контента. При необходимости, <a href="#concept-range" title="concept-range">диапазон</a>
может сам быть изменен как часть изменения
<a href="#concept-node-tree" title="concept-node-tree">дерева узлов</a>, когда, к примеру, часть контента который он представляет изменена.

<p class="note">Заметка: Смотрите алгоритмы <a href="#concept-node-insert" title="concept-node-insert">вставки</a> и
<a href="#concept-node-remove" title="concept-node-remove">удаления</a>, метод
<code title="dom-Node-normalize"><a href="#dom-node-normalize">normalize()</a></code>, алгоритмы
<a href="#concept-cd-replace" title="concept-CD-replace">замены данных</a> и
<a href="#concept-text-split" title="concept-Text-split">разделения</a> для более подробных деталей.


<h3 id="interface-range"><span class="secno">5.2 </span>Интерфейс <code><a href="#range">Range</a></code></h3>
<pre class="idl">[<a href="#dom-range" title="dom-Range">Constructor</a>,
 Exposed=Window]
interface <dfn id="range">Range</dfn> {
  readonly attribute <a href="#node">Node</a> <a href="#dom-range-startcontainer" title="dom-Range-startContainer">startContainer</a>;
  readonly attribute unsigned long <a href="#dom-range-startoffset" title="dom-Range-startOffset">startOffset</a>;
  readonly attribute <a href="#node">Node</a> <a href="#dom-range-endcontainer" title="dom-Range-endContainer">endContainer</a>;
  readonly attribute unsigned long <a href="#dom-range-endoffset" title="dom-Range-endOffset">endOffset</a>;
  readonly attribute boolean <a href="#dom-range-collapsed" title="dom-Range-collapsed">collapsed</a>;
  readonly attribute <a href="#node">Node</a> <a href="#dom-range-commonancestorcontainer" title="dom-Range-commonAncestorContainer">commonAncestorContainer</a>;

  void <a href="#dom-range-setstart" title="dom-Range-setStart">setStart</a>(<a href="#node">Node</a> <var>node</var>, unsigned long <var>offset</var>);
  void <a href="#dom-range-setend" title="dom-Range-setEnd">setEnd</a>(<a href="#node">Node</a> <var>node</var>, unsigned long <var>offset</var>);
  void <a href="#dom-range-setstartbefore" title="dom-Range-setStartBefore">setStartBefore</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-setstartafter" title="dom-Range-setStartAfter">setStartAfter</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-setendbefore" title="dom-Range-setEndBefore">setEndBefore</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-setendafter" title="dom-Range-setEndAfter">setEndAfter</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-collapse" title="dom-Range-collapse">collapse</a>(optional boolean <var>toStart</var> = false);
  void <a href="#dom-range-selectnode" title="dom-Range-selectNode">selectNode</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-selectnodecontents" title="dom-Range-selectNodeContents">selectNodeContents</a>(<a href="#node">Node</a> <var>node</var>);

  const unsigned short <dfn id="dom-comparehow-start_to_start" title="dom-CompareHow-START_TO_START">START_TO_START</dfn> = 0;
  const unsigned short <dfn id="dom-comparehow-start_to_end" title="dom-CompareHow-START_TO_END">START_TO_END</dfn> = 1;
  const unsigned short <dfn id="dom-comparehow-end_to_end" title="dom-CompareHow-END_TO_END">END_TO_END</dfn> = 2;
  const unsigned short <dfn id="dom-comparehow-end_to_start" title="dom-CompareHow-END_TO_START">END_TO_START</dfn> = 3;
  short <a href="#dom-range-compareboundarypoints" title="dom-Range-compareBoundaryPoints">compareBoundaryPoints</a>(unsigned short <var>how</var>, <a href="#range">Range</a> <var>sourceRange</var>);

  void <a href="#dom-range-deletecontents" title="dom-Range-deleteContents">deleteContents</a>();
  [NewObject] <a href="#documentfragment">DocumentFragment</a> <a href="#dom-range-extractcontents" title="dom-Range-extractContents">extractContents</a>();
  [NewObject] <a href="#documentfragment">DocumentFragment</a> <a href="#dom-range-clonecontents" title="dom-Range-cloneContents">cloneContents</a>();
  void <a href="#dom-range-insertnode" title="dom-Range-insertNode">insertNode</a>(<a href="#node">Node</a> <var>node</var>);
  void <a href="#dom-range-surroundcontents" title="dom-Range-surroundContents">surroundContents</a>(<a href="#node">Node</a> <var>newParent</var>);

  [NewObject] <a href="#range">Range</a> <a href="#dom-range-clonerange" title="dom-Range-cloneRange">cloneRange</a>();
  void <a href="#dom-range-detach" title="dom-Range-detach">detach</a>();

  boolean <a href="#dom-range-ispointinrange" title="dom-Range-isPointInRange">isPointInRange</a>(<a href="#node">Node</a> <var>node</var>, unsigned long <var>offset</var>);
  short <a href="#dom-range-comparepoint" title="dom-Range-comparePoint">comparePoint</a>(<a href="#node">Node</a> <var>node</var>, unsigned long <var>offset</var>);

  boolean <a href="#dom-range-intersectsnode" title="dom-Range-intersectsNode">intersectsNode</a>(<a href="#node">Node</a> <var>node</var>);

  <a href="#dom-range-stringifier" title="dom-Range-stringifier">stringifier</a>;
};</pre>

<p>Объекты <code><a href="#range">Range</a></code> проще называются
<dfn id="concept-range" title="concept-range">диапазонами</dfn>.

<p><dfn id="concept-range-bp" title="concept-range-bp">Граничная точка</dfn> это
(<a href="#concept-node" title="concept-node">узел</a>,
<dfn id="concept-range-bp-offset" title="concept-range-bp-offset">смещение</dfn>) набор, в котором
<a href="#concept-range-bp-offset" title="concept-range-bp-offset">смещение</a> это не-негативное целое число.

<p class="note">Заметка: В общем говоря, <a href="#concept-range-bp-offset" title="concept-range-bp-offset">смещение</a>
<a href="#concept-range-bp" title="concept-range-bp">граничной точки</a> будет между нолем и <a href="#concept-node-length" title="concept-node-length">длиной</a>
<a href="#concept-node" title="concept-node">узла</a> <a href="#concept-range-bp" title="concept-range-bp">граничной точки</a>, включительно. Алгоритмы которые изменяют <a href="#concept-tree" title="concept-tree">дерево</a> (в частности алгоритмы
<a href="#concept-node-insert" title="concept-node-insert">вставки</a>,
<a href="#concept-node-remove" title="concept-node-remove">удаления</a>,
<a href="#concept-cd-replace" title="concept-CD-replace">замены данных</a> и
<a href="#concept-text-split" title="concept-Text-split">разделения</a>) также изменяют
<a href="#concept-range" title="concept-range">диапазоны</a> связанные с этим
<a href="#concept-tree" title="concept-tree">деревом</a>.

<p>Если два <a href="#concept-node" title="concept-node">узла</a> от
<a href="#concept-range-bp" title="concept-range-bp">граничных точек</a>
(<var>узел A</var>, <var>смещение A</var>) и
(<var>узел B</var>, <var>смещение B</var>) имеют тот же
<a href="#concept-tree-root" title="concept-tree-root">корень</a>,
<dfn id="concept-range-bp-position" title="concept-range-bp-position">положение</dfn> первого по отношению ко второму
является <dfn id="concept-range-bp-before" title="concept-range-bp-before">перед</dfn>,
<dfn id="concept-range-bp-equal" title="concept-range-bp-equal">равно</dfn> или
<dfn id="concept-range-bp-after" title="concept-range-bp-after">после</dfn>,
как возвращается следующим алгоритмом:

<ol>
 <li><p>Если <var>node A</var> тот же что и <var>node B</var>,
 возвратить <a href="#concept-range-bp-equal" title="concept-range-bp-equal">equal</a> если
 <var>offset A</var> тот же что и <var>offset B</var>,
 <a href="#concept-range-bp-before" title="concept-range-bp-before">before</a> если
 <var>offset A</var> меньше чем <var>offset B</var>, и
 <a href="#concept-range-bp-after" title="concept-range-bp-after">after</a> если
 <var>offset A</var> больше чем <var>offset B</var>.

 <li><p>Если <var>node A</var> является
 <a href="#concept-tree-following" title="concept-tree-following">следующей</a> за
 <var>node B</var>, вычислить
 <a href="#concept-range-bp-position" title="concept-range-bp-position">положение</a>
 (<var>node B</var>, <var>offset B</var>) по отношению к
 (<var>node A</var>, <var>offset A</var>). Если оно
 <a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a>, возвратить
 <a href="#concept-range-bp-after" title="concept-range-bp-after">after</a>. Если оно
 <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a>, возвратить
 <a href="#concept-range-bp-before" title="concept-range-bp-before">before</a>.

 <li>
  <p>Если <var>node A</var> является
  <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a> для
  <var>node B</var>:

  <ol>
   <li><p>Сделать <var>child</var> равным <var>node B</var>.

   <li><p>Пока <var>child</var> не является
   <a href="#concept-tree-child" title="concept-tree-child">дочерним</a> от <var>node A</var>,
   установить <var>child</var> к его
   <a href="#concept-tree-parent" title="concept-tree-parent">родительскому</a>.

   <li><p>Если <a href="#concept-tree-index" title="concept-tree-index">индекс</a>
   <var>child</var>-а меньше чем <var>offset A</var>, возвратить
   <a href="#concept-range-bp-after" title="concept-range-bp-after">after</a>.
  </ol>

 <li><p>Возвратить <a href="#concept-range-bp-before" title="concept-range-bp-before">before</a>.
</ol>

<p>Каждый <a href="#concept-range" title="concept-range">диапазон</a> имеет две соответствующих
<a href="#concept-range-bp" title="concept-range-bp">граничных точки</a> —
<dfn id="concept-range-start" title="concept-range-start">начальная</dfn> и
<dfn id="concept-range-end" title="concept-range-end">конечная</dfn>.

<p>Для удобства, <dfn id="concept-range-start-node" title="concept-range-start-node">начальный узел</dfn> это <a href="#concept-node" title="concept-node">узел</a>
<a href="#concept-range-start" title="concept-range-start">начала</a>,
<dfn id="concept-range-start-offset" title="concept-range-start-offset">начальное смещение</dfn> это <a href="#concept-range-bp-offset" title="concept-range-bp-offset">смещение</a>
<a href="#concept-range-start" title="concept-range-start">начала</a>,
<dfn id="concept-range-end-node" title="concept-range-end-node">конечный узел</dfn> это <a href="#concept-node" title="concept-node">узел</a>
<a href="#concept-range-end" title="concept-range-end">конца</a>,  и
<dfn id="concept-range-end-offset" title="concept-range-end-offset">конечное смещение</dfn> это <a href="#concept-range-bp-offset" title="concept-range-bp-offset">узел</a>
<a href="#concept-range-end" title="concept-range-end">конца</a>.

<p><dfn id="concept-range-root" title="concept-range-root">Корень</dfn>
<a href="#concept-range" title="concept-range">диапазона</a> это
<a href="#concept-tree-root" title="concept-tree-root">корень</a> его
<a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a>.
<!-- start and end have an identical root -->

<p><a href="#concept-node" title="concept-node">Узел</a> <var>node</var>
<dfn id="contained">содержится</dfn> в <a href="#concept-range" title="concept-range">диапазоне</a>
<var>range</var> если <a href="#concept-tree-root" title="concept-tree-root">корень</a> <var>node</var> тот же, что и <a href="#concept-range-root" title="concept-range-root">корень</a> <var>диапазона</var>, и (<var>node</var>, 0)
идет <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a> <a href="#concept-range-start" title="concept-range-start">начала</a> <var>range</var>, и (<var>node</var>,
<a href="#concept-node-length" title="concept-node-length">длина</a> <var>node</var>) идет
<a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a> <a href="#concept-range-end" title="concept-range-end">концом</a> <var>range</var>.

<p><a href="#concept-node" title="concept-node">Узел</a> <dfn id="partially-contained">частично содержится</dfn>
в <a href="#concept-range" title="concept-range">диапазоне</a> если он является
<a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a> <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a> <a href="#concept-range" title="concept-range">диапазона</a>, но не его
<a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>, и наоборот.

<div class="note">
 <p>Некоторые факты, чтобы лучше понять эти определения:

 <ul>
  <li><p>Содержание находящееся внутри
  <a href="#concept-range" title="concept-range">диапазона</a> состоит из всех
  <a href="#contained">содержащихся</a> <a href="#concept-node" title="concept-node">узлов</a>, плюс
  возможно некоторые содержания
  <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a> и
  <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>, если они являются
  <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
  <code><a href="#comment">Comment</a></code> <a href="#concept-node" title="concept-node">узлами</a>.

  <li><p><a href="#concept-node" title="concept-node">Узлы</a>, которые содержатся в
  <a href="#concept-range" title="concept-range">диапазоне</a>, обычно будут не смежными,
  потому что <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a>
  <a href="#contained">содержащегося</a> <a href="#concept-node" title="concept-node">узла</a> не всегда будет <a href="#contained">содержащимся</a>.

  <li><p>Тем не менее, <a href="#concept-tree-descendant" title="concept-tree-descendant">потомки</a>
  <a href="#contained">содержащегося</a> <a href="#concept-node" title="concept-node">узла</a> являются
  <a href="#contained">содержащимися</a>, и если два
  <a href="#concept-tree-sibling" title="concept-tree-sibling">сестринских</a> являются
  <a href="#contained">содержащимися</a>, такими являются любые
  <a href="#concept-tree-sibling" title="concept-tree-sibling">сестринские</a> которые лежат между ними.

  <li><p>Первый <a href="#contained">содержащийся</a>
  <a href="#concept-node" title="concept-node">узел</a> (если таковой имеется) всегда будет
  идти после <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a>, а
  последний <a href="#contained">содержащийся</a> <a href="#concept-node" title="concept-node">узел</a> всегда будет равен либо идти перед последним
  <a href="#concept-tree-descendant" title="concept-tree-descendant">потомком</a> <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>.

  <li><p><a href="#concept-range-start-node" title="concept-range-start-node">Начальный узел</a> и
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a>
  <a href="#concept-range" title="concept-range">диапазона</a> никогда не <a href="#contained">содержится</a> внутри него.

  <li><p>Существуют частично содержащиеся узлы
  <a href="#concept-node" title="concept-node">node</a>, если только
  <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> и
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> являются разными.

  <li><p>Значение атрибута
  <code title="dom-Range-commonAncestorContainer"><a href="#dom-range-commonancestorcontainer">commonAncestorContainer</a></code>
  не является ни <a href="#contained">содержащимся</a>, ни
  <a href="#partially-contained">частично содержащимся</a>.

  <li>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> является
  <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a>
  <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>, их общий
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительный предок</a> будет
  <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a>. Только один
  их <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> будет
  <a href="#partially-contained">частично содержащимся</a>, и
  <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> будет <a href="#contained">содержащимся</a>
  если только его <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующий</a> это
  <a href="#partially-contained">частично содержащийся</a>
  <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>. Если
  <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
  <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a>
  <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a>, справедливо обратное.

  <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> не является ни
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a> <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>, ни наоборот,
  то общий
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительный предок</a> будет
  отличаться от них обоих. Только двое из его
  <a href="#concept-tree-child" title="concept-tree-child">дочерних</a> будут
  <a href="#partially-contained">частично содержаться</a>, и
  <a href="#concept-tree-child" title="concept-tree-child">дочерний</a> будет содержаться только если он лежит между этими двумя.
 </ul>
</div>

<hr>

<dl class="domintro">
 <dt><code><var>range</var> = new <a href="#dom-range" title="dom-Range">Range</a>()</code>
 <dd><p>Возвращает новый <a href="#concept-range" title="concept-range">диапазон</a>.
</dl>

<p>Конструктор <dfn id="dom-range" title="dom-Range"><code>Range()</code></dfn> должен возвратить новый
<a href="#concept-range" title="concept-range">диапазон</a> с
(соответствующим <a href="#concept-document" title="concept-document">документом</a> главного объекта, 0) как его
<a href="#concept-range-start" title="concept-range-start">начало</a> и
<a href="#concept-range-end" title="concept-range-end">конец</a>.

<hr>

<dl class="domintro">
 <dt><var>node</var> = <var>range</var> . <code title="dom-Range-startContainer"><a href="#dom-range-startcontainer">startContainer</a></code>
 <dd><p>Возвращает <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> <var>диапазона</var>.

 <dt><var>offset</var> = <var>range</var> . <code title="dom-Range-startOffset"><a href="#dom-range-startoffset">startOffset</a></code>
 <dd><p>Возвращает <a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a> <var>диапазона</var>.

 <dt><var>node</var> = <var>range</var> . <code title="dom-Range-endContainer"><a href="#dom-range-endcontainer">endContainer</a></code>
 <dd><p>Возвращает <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> <var>диапазона</var>.

 <dt><var>offset</var> = <var>range</var> . <code title="dom-Range-endOffset"><a href="#dom-range-endoffset">endOffset</a></code>
 <dd><p>Возвращает <a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a> <var>диапазона</var>.

 <dt><var>collapsed</var> = <var>range</var> . <code title="dom-Range-collapsed"><a href="#dom-range-collapsed">collapsed</a></code>
 <dd><p>Возвращает true если <a href="#concept-range-start" title="concept-range-start">начало</a> <var>диапазона</var> и
 <a href="#concept-range-end" title="concept-range-end">конец</a> являются одним и тем же, и false в другом случае.

 <dt><var>container</var> = <var>range</var> . <code title="dom-Range-commonAncestorContainer"><a href="#dom-range-commonancestorcontainer">commonAncestorContainer</a></code>
 <dd><p>Возвращает <a href="#concept-node" title="concept-node">узел</a> дальний от <a href="#concept-document" title="concept-document">документа</a>, который является
 <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предком</a> <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a> и <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a> <var>диапазона</var>.
</dl>

<p>Атрибут <dfn id="dom-range-startcontainer" title="dom-Range-startContainer"><code>startContainer</code></dfn>
должен возвратить
<a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a>.

<p>Атрибут <dfn id="dom-range-startoffset" title="dom-Range-startOffset"><code>startOffset</code></dfn>
должен возвратить
<a href="#concept-range-start-offset" title="concept-range-start-offset">начальное смещение</a>.

<p>Атрибут <dfn id="dom-range-endcontainer" title="dom-Range-endContainer"><code>endContainer</code></dfn>
должен возвратить
<a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a>.

<p>Атрибут <dfn id="dom-range-endoffset" title="dom-Range-endOffset"><code>endOffset</code></dfn>
должен возвратить
<a href="#concept-range-end-offset" title="concept-range-end-offset">конечное смещение</a>.

<p>Атрибут <dfn id="dom-range-collapsed" title="dom-Range-collapsed"><code>collapsed</code></dfn> должен возвратить true если <a href="#concept-range-start" title="concept-range-start">начало</a> является тем же что и <a href="#concept-range-end" title="concept-range-end">конец</a>, и false в другом случае.

<p>Атрибут
<dfn id="dom-range-commonancestorcontainer" title="dom-Range-commonAncestorContainer"><code>commonAncestorContainer</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>container</var>
 <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a>.

 <li><p>Пока <var>container</var> не является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <a href="#concept-range-end-node" title="concept-range-end-node">конечного узла</a>, сделать
 <var>container</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>container</var>-а.

 <li><p>Возвратить <var>container</var>.
</ol>

<hr>

<p>Чтобы <dfn id="concept-range-bp-set" title="concept-range-bp-set">установить начало или конец</dfn>
<var>диапазона</var> к
<a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
(<var>node</var>, <var>offset</var>), выполнить следующие шаги:

<ol>
 <li><p>Если <var>node</var> является
 <a href="#concept-doctype" title="concept-doctype">doctype</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".

 <li><p>Если <var>offset</var> больше чем
 <a href="#concept-node-length" title="concept-node-length">длина</a> <var>node</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>".

 <li><p>Сделать <var>bp</var> <a href="#concept-range-bp" title="concept-range-bp">граничной точкой</a>
 (<var>node</var>, <var>offset</var>).

 <li>
  <dl class="switch">
   <dt>Если эти шаги были вызваны как "установка начала"
   <dd>
    <ol>
     <li><p>Если <var>bp</var> идет
     <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a> <a href="#concept-range-end" title="concept-range-end">конца</a> <var>диапазона</var>, или
     если <a href="#concept-range-root" title="concept-range-root">корень</a> <var>диапазона</var>
     не равен <a href="#concept-tree-root" title="concept-tree-root">корню</a>
     <var>узла</var>, установить <a href="#concept-range-end" title="concept-range-end">конец</a>
     <var>диапазона</var> к
     <var>bp</var>.

     <li><p>Установить <a href="#concept-range-start" title="concept-range-start">начало</a> <var>диапазона</var>
     к <var>bp</var>.
    </ol>
   <dt>Если эти шаги были вызваны как "установка конца"
   <dd>
    <ol>
     <li><p>Если <var>bp</var> идет
     <a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a> <a href="#concept-range-start" title="concept-range-start">началом</a>
     <var>диапазона</var>,
     или если <a href="#concept-range-root" title="concept-range-root">корень</a> <var>диапазона</var>
     является <a href="#concept-tree-root" title="concept-tree-root">корнем</a>
     <var>узла</var>, установить <a href="#concept-range-start" title="concept-range-start">начало</a>
     <var>диапазона</var> к <var>bp</var>.

     <li><p>Установить <a href="#concept-range-end" title="concept-range-end">конец</a> <var>диапазона</var> к <var>bp</var>.
    </ol>
  </dl>
</ol>

<p>Метод
<dfn id="dom-range-setstart" title="dom-Range-setStart"><code>setStart(<var>node</var>, <var>offset</var>)</code></dfn>
должен <a href="#concept-range-bp-set" title="concept-range-bp-set">установить начало</a>
<a href="#context-object">объекта контекста</a> к
<a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
(<var>node</var>, <var>offset</var>).

<p>Метод
<dfn id="dom-range-setend" title="dom-Range-setEnd"><code>setEnd(<var>node</var>, <var>offset</var>)</code></dfn>
должен <a href="#concept-range-bp-set" title="concept-range-bp-set">установить конец</a>
<a href="#context-object">объекта контекста</a> к
<a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
(<var>node</var>, <var>offset</var>).

<p>Метод
<dfn id="dom-range-setstartbefore" title="dom-Range-setStartBefore"><code>setStartBefore(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>" исключение.

 <li><p><a href="#concept-range-bp-set" title="concept-range-bp-set">Установить начало</a>
 <a href="#context-object">объекта контекста</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <a href="#concept-tree-index" title="concept-tree-index">индексу</a> <var>node</var>).
</ol>

<p>Метод
<dfn id="dom-range-setstartafter" title="dom-Range-setStartAfter"><code>setStartAfter(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".

 <li><p><a href="#concept-range-bp-set" title="concept-range-bp-set">Установить начало</a>
 <a href="#context-object">объекта контекста</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <a href="#concept-tree-index" title="concept-tree-index">индексу</a> <var>node</var> плюс один).
</ol>

<p>Метод
<dfn id="dom-range-setendbefore" title="dom-Range-setEndBefore"><code>setEndBefore(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".

 <li><p><a href="#concept-range-bp-set" title="concept-range-bp-set">Установить конец</a>
 <a href="#context-object">объекта контекста</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <a href="#concept-tree-index" title="concept-tree-index">индексу</a> <var>node</var>).
</ol>

<p>Метод
<dfn id="dom-range-setendafter" title="dom-Range-setEndAfter"><code>setEndAfter(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>" исключение.

 <li><p><a href="#concept-range-bp-set" title="concept-range-bp-set">Установить конец</a>
 <a href="#context-object">объекта контекста</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <a href="#concept-tree-index" title="concept-tree-index">индексу</a> <var>node</var> плюс один).
</ol>


<p>Метод
<dfn id="dom-range-collapse" title="dom-Range-collapse"><code>collapse(<var>toStart</var>)</code></dfn>, когда вызван, должен если <var>toStart</var> является true, установить
<a href="#concept-range-end" title="concept-range-end">конец</a> к
<a href="#concept-range-start" title="concept-range-start">началу</a>, или установить
<a href="#concept-range-start" title="concept-range-start">начало</a> к
<a href="#concept-range-end" title="concept-range-end">концу</a> в другом случае.

<p>Чтобы <dfn id="concept-range-select" title="concept-range-select">выбрать</dfn> <a href="#concept-node" title="concept-node">узел</a>
<var>node</var> внутри <a href="#concept-range" title="concept-range">диапазона</a>
<var>range</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null, <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".

 <li><p>Сделать <var>index</var> <a href="#concept-tree-index" title="concept-tree-index">индексом</a> <var>node</var>.

 <li><p>Установить <a href="#concept-range-start" title="concept-range-start">начало</a> <var>диапазона</var> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <var>index</var>).

 <li><p>Установить <a href="#concept-range-end" title="concept-range-end">конец</a> <var>диапазона</var> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>parent</var>, <var>index</var> плюс один).
</ol>

<p>Метод
<dfn id="dom-range-selectnode" title="dom-Range-selectNode"><code>selectNode(<var>node</var>)</code></dfn>
должен <a href="#concept-range-select" title="concept-range-select">выбрать</a> <var>node</var> внутри
<a href="#context-object">объекта контекста</a>.

<p>Метод
<dfn id="dom-range-selectnodecontents" title="dom-Range-selectNodeContents"><code>selectNodeContents(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>node</var> является
 <a href="#concept-doctype" title="concept-doctype">doctype</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".

 <li><p>Сделать <var>length</var> <a href="#concept-node-length" title="concept-node-length">длиной</a> <var>node</var>.

 <li><p>Установить <a href="#concept-range-start" title="concept-range-start">начало</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>node</var>, 0).

 <li><p>Установить <a href="#concept-range-end" title="concept-range-end">конец</a> к
 <a href="#concept-range-bp" title="concept-range-bp">граничной точке</a>
 (<var>node</var>, <var>length</var>).
</ol>

<hr>

<p>Метод
<dfn id="dom-range-compareboundarypoints" title="dom-Range-compareBoundaryPoints"><code>compareBoundaryPoints(<var>how</var>, <var>sourceRange</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li>
  <p>Если <var>how</var> не является одним из
  <ul>
   <li><code title="dom-CompareHow-START_TO_START"><a href="#dom-comparehow-start_to_start">START_TO_START</a></code>,
   <li><code title="dom-CompareHow-START_TO_END"><a href="#dom-comparehow-start_to_end">START_TO_END</a></code>,
   <li><code title="dom-CompareHow-END_TO_END"><a href="#dom-comparehow-end_to_end">END_TO_END</a></code> и
   <li><code title="dom-CompareHow-END_TO_START"><a href="#dom-comparehow-end_to_start">END_TO_START</a></code>,
  </ul>
  <p><a href="#dfn-throw" title="concept-throw">выдать</a> исключение
  "<code><a href="#notsupportederror">NotSupportedError</a></code>".
 <!--
 Apparent behaviors from black-box testing:

 IE9: Converts to unsigned short per WebIDL, then throws "Error: Invalid
 argument." if it's not 0-3.

 Firefox 12.0a1: Converts to unsigned short per WebIDL, then throws
 NS_ERROR_ILLEGAL_VALUE if it's not 0-3.

 Chrome 17 dev: Converts to unsigned *long* per WebIDL, and treats bad values
 as 0.  Never throws.

 Opera Next 12.00 alpha: Throws NotSupportedError unless the value is -0, 0, 1,
 2, 3, or an integer equal to one of these modulo 2^32.  (In particular, it
 throws on NaN, Infinity, and -Infinity instead of treating them as 0 per
 WebIDL.)

 The spec follows IE9/Gecko, except that we throw NotSupportedError (like
 Opera) instead of a nonstandard exception type.
 -->

 <li><p>Если <a href="#concept-range-root" title="concept-range-root">корень</a> <a href="#context-object">объекта контекста</a> не тот же что и <a href="#concept-range-root" title="concept-range-root">корень</a>
 <var>sourceRange</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#wrongdocumenterror">WrongDocumentError</a></code>".

 <li>
  <p>Если <var>how</var> является:
  <dl class="switch">
   <dt><code title="dom-CompareHow-START_TO_START"><a href="#dom-comparehow-start_to_start">START_TO_START</a></code>:
   <dd>
    <p>Сделать <var>эту точку</var> <a href="#concept-range-start" title="concept-range-start">началом</a> <a href="#context-object">объекта контекста</a>.
    <p>Сделать <var>другую точку</var> <a href="#concept-range-start" title="concept-range-start">началом</a> <var>sourceRange</var>.

   <dt><code title="dom-CompareHow-START_TO_END"><a href="#dom-comparehow-start_to_end">START_TO_END</a></code>:
   <dd>
    <p>Сделать <var>эту точку</var> <a href="#concept-range-end" title="concept-range-end">концом</a> <a href="#context-object">объекта контекста</a>.
    <p>Сделать <var>другую точку</var> <a href="#concept-range-start" title="concept-range-start">началом</a> <var>sourceRange</var>.

    <dt><code title="dom-CompareHow-END_TO_END"><a href="#dom-comparehow-end_to_end">END_TO_END</a></code>:
    <dd>
     <p>Сделать <var>эту точку</var> <a href="#concept-range-end" title="concept-range-end">концом</a> <a href="#context-object">объекта контекста</a>.
     <p>Сделать <var>другую точку</var> <a href="#concept-range-end" title="concept-range-end">концом</a> <var>sourceRange</var>.

    <dt><code title="dom-CompareHow-END_TO_START"><a href="#dom-comparehow-end_to_start">END_TO_START</a></code>:
    <dd>
     <p>Сделать <var>эту точку</var> <a href="#concept-range-start" title="concept-range-start">началом</a> <a href="#context-object">объекта контекста</a>.
     <p>Сделать <var>другую точку</var> <a href="#concept-range-end" title="concept-range-end">концом</a> <var>sourceRange</var>.
   </dl>

  <li>
   <p>Если <a href="#concept-range-bp-position" title="concept-range-bp-position">положение</a>
   <var>этой точки</var> по отношению к <var>другой точке</var> является

   <dl class="switch">
    <dt><a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a>
    <dd>Возвратить −1.

    <dt><a href="#concept-range-bp-equal" title="concept-range-bp-equal">равно</a>
    <dd>Возвратить 0.

    <dt><a href="#concept-range-bp-after" title="concept-range-bp-after">после</a>
    <dd>Возвратить 1.
   </dl>
</ol>

<p>Метод <dfn id="dom-range-deletecontents" title="dom-Range-deleteContents"><code>deleteContents()</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <a href="#concept-range-start" title="concept-range-start">начало</a> равняется
 <a href="#concept-range-end" title="concept-range-end">концу</a>, прекратить данные шаги.
 <!-- This might actually make no difference, but it's not immediately
 obvious what would happen otherwise if the start/end were text/comment:
 are all the substeps of the next step actually no-ops, or could some have
 side effects? -->

 <li><p>Сделать <var>original start node</var>,
 <var>original start offset</var>, <var>original end node</var> и <var>original end offset</var> <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a>, <a href="#concept-range-start-offset" title="concept-range-start-offset">начальным смещением</a>, <a href="#concept-range-end-node" title="concept-range-end-node">конечным узлом</a> и <a href="#concept-range-end-offset" title="concept-range-end-offset">конечным смещением</a> <a href="#context-object">объекта контекста</a> соответственно.

 <li><p>Если <var>original start node</var> и
 <var>original end node</var> являются одним и тем же, и они являются <a href="#concept-node" title="concept-node">узлами</a>
 <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
 <code><a href="#comment">Comment</a></code>,
 <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
 <var>original start node</var>, смещение
 <var>original start offset</var>, подсчет
 <var>original end offset</var> минус
 <var>original start offset</var>, и данные на пустую строку, и затем прекратить данные шаги.

 <li><p>Сделать <var>nodes to remove</var> списком всех
 <a href="#concept-node" title="concept-node">узлов</a> которые <a href="#contained">содержатся</a> в
 <a href="#context-object">объекте контекста</a>, в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>, минуя любые
 <a href="#concept-node" title="concept-node">узлы</a> чьи
 <a href="#concept-tree-parent" title="concept-tree-parent">родители</a> также
 <a href="#contained">содержатся</a> в <a href="#context-object">объекте контекста</a>.

 <li><p>Если <var>original start node</var> является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить
 <var>new node</var> к <var>original start node</var> и
 <var>new offset</var> к <var>original start offset</var>.

 <li>
  <p>В другом случае:
  <ol>
   <li><p>Сделать <var>reference node</var> равным
   <var>original start node</var>.

   <li><p>Пока <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>reference node</var> не является null и не является
   <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
   <var>original end node</var>, установить <var>reference node</var>
   к его <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a>.

   <li>
    <p>Установить <var>new node</var> к
    <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a>
    <var>reference node</var>, и <var>new offset</var> к одному плюс
    <a href="#concept-tree-index" title="concept-tree-index">индекс</a>
    <var>reference node</var>.

    <p class="note">Заметка: Если бы <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>reference node</var> был null, он был бы
    <a href="#concept-range-root" title="concept-range-root">корнем</a>
    <a href="#context-object">объекта контекста</a>, таким образом был бы
    <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
    <var>original end node</var>, и мы не смогли бы достичь этой точки.
  </ol>

 <li><p>Если <var>original start node</var> является <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#text">Text</a></code>,
 <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>,
 <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
 <var>original start node</var>, смещение
 <var>original start offset</var>, подсчет на <a href="#concept-node-length" title="concept-node-length">длину</a>
 <var>original start node</var> минус
 <var>original start offset</var>, и данные на пустую строку.

 <li><p>Для каждого <var>узла</var> в <var>nodes to remove</var>,
 в <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>,
 <a href="#concept-node-remove" title="concept-node-remove">удалить</a> <var>узел</var> с его <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

 <li><p>Если <var>original end node</var> является <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#text">Text</a></code>,
 <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>,
 <a href="#concept-cd-replace" title="concept-CD-replace">заменить данные</a> на узел
 <var>original end node</var>, смещение на 0, подсчет
 <var>original end offset</var> и данные на пустую строку.

 <li><p>Установить <a href="#concept-range-start" title="concept-range-start">начало</a> и
 <a href="#concept-range-end" title="concept-range-end">конец</a> к
 (<var>new node</var>, <var>new offset</var>).
</ol>

<p>Чтобы <dfn id="concept-range-extract" title="concept-range-extract">извлечь</dfn>
<a href="#concept-range" title="concept-range">диапазон</a> <var>range</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>fragment</var> новым <code><a href="#documentfragment">DocumentFragment</a></code>
 <a href="#concept-node" title="concept-node">узла</a> чей
 <a href="#concept-node-document" title="concept-node-document">документ узла</a> является <a href="#concept-node-document" title="concept-node-document">документом узла</a> <a href="#concept-range-start-node" title="concept-range-start-node">стартового узла</a> <var>диапазона</var>.

 <li><p>Если <a href="#concept-range-start" title="concept-range-start">начало</a> <var>диапазона</var> равняется
 его <a href="#concept-range-end" title="concept-range-end">концу</a>, возвратить <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li><p>Сделать <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var> и <var>original end offset</var> <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a>,
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальным смещением</a>,
 <a href="#concept-range-end-node" title="concept-range-end-node">конечным узлом</a> и
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечным смещением</a> <var>диапазона</var> соответственно.

 <li>
  <p>Если <var>original start node</var> равняется
  <var>original end node</var>, и они являются <a href="#concept-node" title="concept-node">узлами</a> <code><a href="#text">Text</a></code>,
  <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>:

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a> <var>original start node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
   <var>original start node</var>, смещения
   <var>original start offset</var>, и подсчета
   <var>original end offset</var> минус
   <var>original start offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
   <var>original start node</var>, смещение
   <var>original start offset</var>, подсчет
   <var>original end offset</var> минус
   <var>original start offset</var>, и данные на пустую строку.

   <li><p>Возвратить <var>fragment</var>.
  </ol>

 <li><p>Сделать <var>общий предок</var>
 <var>original start node</var>.

 <li><p>Пока <var>общий предок</var> не является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить <var>общий предок</var> к
 его собственному <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a>.

 <li><p>Сделать <var>первый частично содержащийся дочерний</var> null.

 <li><p>Если <var>original start node</var> <em>не</em> является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить <var>первый частично содержащийся дочерний</var>
 к первому <a href="#concept-tree-child" title="concept-tree-child">дочернему</a>
 <var>общего предка</var> который <a href="#partially-contained">частично содержится</a> в
 <var>диапазоне</var>.

 <li><p>Сделать <var>первый частично содержащийся дочерний</var> null.

 <li>
  <p>Если <var>original end node</var> <em>не</em> является
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original start node</var>, установить
  <var>первый частично содержащийся дочерний</var> к последнему
  <a href="#concept-tree-child" title="concept-tree-child">дочернему</a> <var>общего предка</var> который
  <a href="#partially-contained">частично содержится</a> в <var>диапазоне</var>.

  <p class="note no-backref">Заметка: Эти назначения переменных фактически всегда имеют смысл.
  Например, если <var>original start node</var> не является
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original end node</var>, сам <var>original start node</var>
  <a href="#partially-contained">частично содержится</a> в <var>диапазоне</var>, и также все его
  <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предки</a> вплоть до
  <a href="#concept-tree-child" title="concept-tree-child">дочернего</a> <var>common ancestor</var>.
  <var>common ancestor</var> не может быть <var>original start node</var>, потому что
  он должен быть <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original end node</var>. Другой случай аналогичен. Также заметьте, что два
  <a href="#concept-tree-child" title="concept-tree-child">дочерних</a> никогда не равны, если оба являются определенными.

 <li><p>Сделать <var>contained children</var> списком всех
 <a href="#concept-tree-child" title="concept-tree-child">дочерних</a>
 <var>common ancestor</var> которые <a href="#contained">содержатся</a> в
 <var>range</var>, в <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

 <li>
  <p>Если любой член <var>contained children</var> является
  <a href="#concept-doctype" title="concept-doctype">doctype</a>, <a href="#dfn-throw" title="concept-throw">выдать</a>
  "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>" исключение.
  <!-- Firefox 4.0 actually removes the non-DocumentType nodes before
  throwing the exception. Opera 11.00 removes the DocumentType too, and
  doesn't throw. I go with IE9 and Chrome 12 dev, which don't remove any
  nodes. DOM 2 Range doesn't specify what exactly happens here, except that
  an exception should be thrown. -->

  <p class="note no-backref">Заметка: Мы не должны волноваться о первом или последнем частично содержащемся узле, потому что <a href="#concept-doctype" title="concept-doctype">doctype</a> никогда не может частично содержаться. Он не может быть граничной точкой диапазона и не может быть предком ничего.

 <li><p>Если <var>original start node</var> является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить <var>new node</var> к
 <var>original start node</var> и <var>new offset</var> к
 <var>original start offset</var>.

 <li>
  <p>В другом случае:
  <ol>
   <li><p>Сделать <var>reference node</var> равной <var>original start node</var>.

   <li><p>Пока <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>reference node</var> не null и не
   <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительный предок</a>
   <var>original end node</var>, установить <var>reference node</var> к его
   <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a>.

   <li>
    <p>Установить <var>new node</var> к
    <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a> <var>reference node</var>, и
    <var>new offset</var> к одному плюс <a href="#concept-tree-index" title="concept-tree-index">индекс</a> <var>reference node</var>.

    <p class="note">Заметка: Если <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>reference node</var> был бы null, он бы был
    <a href="#concept-range-root" title="concept-range-root">корнем</a> <var>range</var>, таким образом
    <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
    <var>original end node</var>, и мы не смогли бы достигнуть этой точки.
  </ol>

  <!-- Now we start with mutations, so we can't refer to the context object
  anymore unless we carefully consider how it will have mutated. -->

 <li>
  <p>Если <var>first partially contained child</var> является
  <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
  <code><a href="#comment">Comment</a></code> <a href="#concept-node" title="concept-node">узлом</a>:

  <p class="note">Заметка: В этом случае <var>first partially contained child</var> является
  <var>original start node</var>.

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>original start node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
   <var>original start node</var>, смещения
   <var>original start offset</var>, и подсчета на <a href="#concept-node-length" title="concept-node-length">длину</a>
   <var>original start node</var> минус
   <var>original start offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
   <var>original start node</var>, смещение
   <var>original start offset</var>, подсчет на <a href="#concept-node-length" title="concept-node-length">длину</a>
   <var>original start node</var> минус
   <var>original start offset</var>, и данные на пустую строку.
  </ol>

 <li>
  <p>В другом случае, если <var>first partially contained child</var> не является
  null:

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>first partially contained child</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p>Сделать <var>subrange</var> новым <a href="#concept-range" title="concept-range">диапазоном</a>,
   чье <a href="#concept-range-start" title="concept-range-start">начало</a> является
   (<var>original start node</var>, <var>original start offset</var>) и
   чей <a href="#concept-range-end" title="concept-range-end">конец</a> является
   (<var>first partially contained child</var>, <a href="#concept-node-length" title="concept-node-length">длина</a> <var>first partially contained child</var>).

   <li><p>Сделать <var>subfragment</var> результатом
   <a href="#concept-range-extract" title="concept-range-extract">извлечения</a> <var>subrange</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>subfragment</var> к
   <var>clone</var>.
  </ol>

 <li><p>Для каждого <var>contained child</var> в <var>contained children</var>,
 <a href="#concept-node-append" title="concept-node-append">добавить</a> <var>contained child</var> к
 <var>fragment</var>.

 <li>
  <p>Если <var>last partially contained child</var> является
  <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
  <code><a href="#comment">Comment</a></code> <a href="#concept-node" title="concept-node">узлом</a>:

  <p class="note">Заметка: В этом случае <var>last partially contained child</var> является
  <var>original end node</var>.

  <ol>
   <li><p>Сделать <var>clone</var> <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>original end node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> на узел
   <var>original end node</var>, смещение 0, и подсчет
   <var>original end offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p><a href="#concept-cd-replace" title="concept-CD-replace">Заменить данные</a> на узел
   <var>original end node</var>, смещение 0, подсчет
   <var>original end offset</var>, и данные на пустую строку.
  </ol>

 <li>
  <p>В другом случае, если <var>last partially contained child</var> не является
  null:

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>last partially contained child</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p>Сделать <var>subrange</var> новым <a href="#concept-range" title="concept-range">диапазоном</a>,
   чье <a href="#concept-range-start" title="concept-range-start">начало</a> является
   (<var>last partially contained child</var>, 0) и чей
   <a href="#concept-range-end" title="concept-range-end">конец</a> является
   (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Сделать <var>subfragment</var> результатом
   <a href="#concept-range-extract" title="concept-range-extract">извлечения</a> <var>subrange</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>subfragment</var> к
   <var>clone</var>.
  </ol>

 <li><p>Установить <a href="#concept-range-start" title="concept-range-start">начало</a> и
 <a href="#concept-range-end" title="concept-range-end">конец</a> <var>range</var> к
 (<var>new node</var>, <var>new offset</var>).

 <li><p>Возвратить <var>fragment</var>.
</ol>

<p>Метод <dfn id="dom-range-extractcontents" title="dom-Range-extractContents"><code>extractContents()</code></dfn>
должен возвратить результат <a href="#concept-range-extract" title="concept-range-extract">извлечения</a>
<a href="#context-object">объекта контекста</a>.

<p>Чтобы <dfn id="concept-range-clone" title="concept-range-clone">клонировать</dfn> <a href="#concept-range" title="concept-range">диапазон</a>
<var>range</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>fragment</var> новым <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#documentfragment">DocumentFragment</a></code>, чей
 <a href="#concept-node-document" title="concept-node-document">документ узла</a> является <a href="#concept-node-document" title="concept-node-document">документом узла</a> <a href="#concept-range-start-node" title="concept-range-start-node">стартового узла</a> <var>range</var>.

 <li><p>Если <a href="#concept-range-start" title="concept-range-start">начало</a> <var>range</var> равняется
 его <a href="#concept-range-end" title="concept-range-end">концу</a>, возвратить <var>fragment</var>.
 <!-- This is only really needed when the start and end nodes are
 text/comment, to avoid creating an empty clone as the child of the
 fragment. (Opera 11 actually does include such an empty clone, it seems,
 but Gecko and WebKit do not as of March 2011, so we follow them.)
 Otherwise, the following steps are all no-ops. But it's simplest to include
 this step anyway. -->

 <li><p>Сделать <var>original start node</var>, <var>original start offset</var>,
 <var>original end node</var> и <var>original end offset</var> <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a>,
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальным смещением</a>,
 <a href="#concept-range-end-node" title="concept-range-end-node">конечным узлом</a> и
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечным смещением</a> <var>range</var> соответственно.

 <li>
  <p>Если <var>original start node</var> равняется
  <var>original end node</var>, и они являются <code><a href="#text">Text</a></code>,
  <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>
  <a href="#concept-node" title="concept-node">узлами</a>:

  <ol>
   <li><p>Сделать <var>clone</var> <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>original start node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
   <var>original start node</var>, смещения
   <var>original start offset</var>, и подсчета
   <var>original end offset</var> минус
   <var>original start offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p>Возвратить <var>fragment</var>.
  </ol>

 <li><p>Сделать <var>original start node</var> <var>общим предком</var>.

 <li><p>Пока <var>common ancestor</var> не является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить
 <var>common ancestor</var> к его собственному
 <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a>.

 <li><p>Сделать <var>first partially contained child</var> null.

 <li><p>Если <var>original start node</var> <em>не</em> является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
 <var>original end node</var>, установить <var>first partially contained child</var>
 к первому <a href="#concept-tree-child" title="concept-tree-child">дочернему</a>
 <var>common ancestor</var> который <a href="#partially-contained">частично содержится</a> в
 <var>range</var>.

 <li><p>Сделать <var>last partially contained child</var> null.

 <li>
  <p>Если <var>original end node</var> <em>не</em> является
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original start node</var>, установить
  <var>last partially contained child</var> к последнему
  <a href="#concept-tree-child" title="concept-tree-child">дочернему</a> <var>common ancestor</var>-а, который
  <a href="#partially-contained">частично содержится</a> в <var>range</var>.

  <p class="note no-backref">Заметка: Эти назначения переменных фактически всегда имеют смысл.
  Например, если <var>original start node</var> не является
  <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original end node</var>, сам <var>original start node</var>
  <a href="#partially-contained">частично содержится</a> в <var>range</var>, и также все его
  <a href="#concept-tree-ancestor" title="concept-tree-ancestor">предки</a> вплоть до
  <a href="#concept-tree-child" title="concept-tree-child">дочернего</a> <var>common ancestor</var>.
  <var>common ancestor</var> не может быть <var>original start node</var>, потому что
  он должен быть <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
  <var>original end node</var>. Другой случай аналогичен. Также заметьте, что два
  <a href="#concept-tree-child" title="concept-tree-child">дочерних</a> никогда не равны, если оба являются определенными.

 <li><p>Сделать <var>contained children</var> списком всех
 <a href="#concept-tree-child" title="concept-tree-child">дочерних</a>
 <var>common ancestor</var>, которые <a href="#contained">содержатся</a> в
 <var>range</var>, в <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>.

 <li>
  <p>Если любой член <var>contained children</var> является
  <a href="#concept-doctype" title="concept-doctype">doctype</a>, <a href="#dfn-throw" title="concept-throw">выдать</a>
  "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>" исключение.

  <p class="note no-backref">Заметка: Мы не должны беспокоиться о первом или последнем частично содержащемся узле, потому что <a href="#concept-doctype" title="concept-doctype">doctype</a> никогда не может
  частично содержаться. Он не может быть граничной точкой диапазона и не может быть предком ничего.

 <li>
  <p>Если <var>first partially contained child</var> является
  <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
  <code><a href="#comment">Comment</a></code> <a href="#concept-node" title="concept-node">узлом</a>:

  <p class="note">Заметка: В этом случае <var>first partially contained child</var> является
  <var>original start node</var>.

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>original start node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
   <var>original start node</var>, смещения
   <var>original start offset</var> и подсчета на <a href="#concept-node-length" title="concept-node-length">длину</a>
   <var>original start node</var> минус
   <var>original start offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.
  </ol>

 <li>
  <p>В другом случае, если <var>first partially contained child</var> не является
  null:

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>first partially contained child</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p>Сделать <var>subrange</var> новым <a href="#concept-range" title="concept-range">диапазоном</a>, чье <a href="#concept-range-start" title="concept-range-start">начало</a> является
   (<var>original start node</var>, <var>original start offset</var>) и
   чей <a href="#concept-range-end" title="concept-range-end">конец</a> является
   (<var>first partially contained child</var>, <a href="#concept-node-length" title="concept-node-length">длина</a> <var>first partially contained child</var>).

   <li><p>Сделать <var>subfragment</var> результатом
   <a href="#concept-range-clone" title="concept-range-clone">клонирования</a> <var>subrange</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>subfragment</var> к
   <var>clone</var>.
  </ol>

 <li>
  <p>Для каждого <var>contained child</var> в
  <var>contained children</var>:

  <ol>
   <li><p>Сделать <var>clone</var> <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>contained child</var> с установленным <i>clone children флагом</i>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var> к
   <var>fragment</var>.
  </ol>

 <li>
  <p>Если <var>last partially contained child</var> является
  <code><a href="#text">Text</a></code>, <code><a href="#processinginstruction">ProcessingInstruction</a></code> или
  <code><a href="#comment">Comment</a></code> <a href="#concept-node" title="concept-node">узлом</a>:

  <p class="note">Заметка: В этом случае <var>last partially contained child</var> является
  <var>original end node</var>.

  <ol>
   <li><p>Сделать <var>clone</var> <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>original end node</var>.

   <li><p>Установить <a href="#concept-cd-data" title="concept-CD-data">данные</a>
   <var>clone</var> к результату
   <a href="#concept-cd-substring" title="concept-CD-substring">извлечения данных</a> с узла
   <var>original end node</var>, смещения 0, и подсчета
   <var>original end offset</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var> к
   <var>fragment</var>.
  </ol>

 <li>
  <p>В другом случае, если <var>last partially contained child</var> не является
  null:

  <ol>
   <li><p>Сделать <var>clone</var>
   <a href="#concept-node-clone" title="concept-node-clone">клоном</a>
   <var>last partially contained child</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>clone</var>
   к <var>fragment</var>.

   <li><p>Сделать <var>subrange</var> новым <a href="#concept-range" title="concept-range">диапазоном</a>, чье <a href="#concept-range-start" title="concept-range-start">начало</a> является
   (<var>last partially contained child</var>, 0) и чей
   <a href="#concept-range-end" title="concept-range-end">конец</a> является
   (<var>original end node</var>, <var>original end offset</var>).

   <li><p>Сделать <var>subfragment</var> результатом
   <a href="#concept-range-clone" title="concept-range-clone">клонирования</a> <var>subrange</var>.

   <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>subfragment</var> к
   <var>clone</var>.
  </ol>

 <li><p>Возвратить <var>fragment</var>.
</ol>

<p>Метод <dfn id="dom-range-clonecontents" title="dom-Range-cloneContents"><code>cloneContents()</code></dfn>
должен возвратить результат <a href="#concept-range-clone" title="concept-range-clone">клонирования</a>
<a href="#context-object">объекта контекста</a>.

<p>Чтобы <dfn id="concept-range-insert" title="concept-range-insert">вставить</dfn> <a href="#concept-node" title="concept-node">узел</a>
<var>node</var> в <a href="#concept-range" title="concept-range">диапазон</a>
<var>range</var>, выполнить следующие шаги:

<ol>
  <!-- Chrome 12 dev throws "HierarchyRequestError" if node is the same
  as the start node (at least for text nodes). This doesn't seem to make
  much sense, since insertBefore() works fine to move a node to its current
  position, and other browsers disagree, so the spec follows the majority.
  -->
 <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> <var>range</var>
 является <code><a href="#processinginstruction">ProcessingInstruction</a></code> или <code><a href="#comment">Comment</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>, или <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#text">Text</a></code> чей <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a>
 является null, <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#hierarchyrequesterror">HierarchyRequestError</a></code>".

 <!--
 Behavior for Text node with null parent:

 IE9: Allows it to go through, resulting in the text/comment node having a non-null previousSibling but a null parentNode. (?!)
 Firefox 4.0: Throws non-standard exception
 Chrome 12 dev: Throws "HierarchyRequestError"
 Opera 11.00: Doesn't come up, doesn't allow ranges on detached nodes

 IE is clearly crazy, and non-standard exceptions are no good, so we go with
 WebKit.

 For a Comment node, see https://www.w3.org/Bugs/Public/show_bug.cgi?id=15350.
 IE9, Firefox 12.0a1, and Chrome 17 dev all agree on throwing a
 HierarchyRequestError.  Opera Next 12.00 alpha splits the comment, same as a
 text node.
 -->
 <li><p>Сделать <var>referenceNode</var> null.

 <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> <var>range</var>
 является <a href="#concept-node" title="concept-node">узлом</a> <code><a href="#text">Text</a></code>,
 установить <var>referenceNode</var> к этому <code><a href="#text">Text</a></code>
 <a href="#concept-node" title="concept-node">узлу</a>. <!-- This will change when we split
 it. -->

 <li><p>В другом случае, установить <var>referenceNode</var>
 <a href="#concept-tree-child" title="concept-tree-child">дочерним</a>
 <a href="#concept-range-start-node" title="concept-range-start-node">начального узла</a>, чей
 <a href="#concept-tree-index" title="concept-tree-index">индекс</a> является
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальным смещением</a>, и null если
 такого <a href="#concept-tree-child" title="concept-tree-child">дочернего</a> нет.

 <li><p>Сделать <var>parent</var> <a href="#concept-range-start-node" title="concept-range-start-node">начальным узлом</a> <var>range</var> если <var>referenceNode</var> является null, и <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>referenceNode</var> в другом случае.

 <!-- IE9 and Chrome 12 dev throw an exception before splitting the text
 node if the insertBefore() is going to throw an exception (at least if the
 new node is the parent of the start node, for instance). Firefox 4.0 and
 Opera 11.00 don't.  Now that we have "ensure pre-insertion validity," we go
 with the IE/Chrome behavior because it's more correct.

 IE9 doesn't call splitText() if the offset is 0. This makes sense, but I go
 with what all other browsers do. -->
 <li><p><a href="#concept-node-ensure-pre-insertion-validity" title="concept-node-ensure-pre-insertion-validity">Обеспечить валидность предварительной вставки</a> <var>node</var> в <var>parent</var> перед
 <var>referenceNode</var>.

 <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> <var>range</var>
 является<code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#concept-text-split" title="concept-Text-split">разделить</a> его со смещением равным
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальному смещению</a> <var>range</var>,
 установить <var>referenceNode</var> к результату, и установить
 <var>parent</var> к <a href="#concept-tree-parent" title="concept-tree-parent">родителю</a> <var>referenceNode</var>.

 <li><p>Если <var>node</var> равняется <var>referenceNode</var>, установить
 <var>referenceNode</var> к его
 <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующему сестринскому</a>. <!-- Because we're
 about to remove node from its parent. -->

 <li><p>Если <a href="#concept-tree-parent" title="concept-tree-parent">родитель</a> <var>node</var> не является
 null, <a href="#concept-node-remove" title="concept-node-remove">удалить</a> <var>node</var> из его
 <a href="#concept-tree-parent" title="concept-tree-parent">родителя</a>.

 <!-- Browsers disagree on how to handle the case where the range is
 collapsed: do you increment the end offset so the node is now included, or
 not?  DOM 2 Range says no, and Firefox 12.0a1 follows that, but IE9, Chrome
 17 dev, and Opera Next 12.00 alpha all do increment.  Apparently this
 traces back to Acid3 at one point requiring the non-standard behavior.
 Previously the spec matched DOM 2 Range, but it changed to match the
 majority of browsers.  See
 https://www.w3.org/Bugs/Public/show_bug.cgi?id=15297.

 We have to be careful here, because if node is a DocumentFragment, we might
 have inserted any number of nodes, including zero.  One corner case is if
 we insert an empty DocumentFragment and the range is collapsed in a text
 node.  In that case, the text node gets split, but browsers disagree on
 what to do with the range's end.  IE9 leaves it in place; Chrome 17 dev
 moves it to the parent element, before the reference node; Opera Next 12.00
 alpha moves it to the beginning of the new text node.  The spec follows
 WebKit just because it happens to be easier for me to spec.

 The logic for how much to increment the position by is copied from the
 "insert" algorithm.  Getting the new offset right was surprisingly tricky.
 -->
 <li><p>Сделать <var>newOffset</var> <a href="#concept-node-length" title="concept-node-length">длиной</a> <var>parent</var> если <var>referenceNode</var> является null,
 и <a href="#concept-tree-index" title="concept-tree-index">индексом</a> <var>referenceNode</var> в другом случае.

 <li><p>Увеличинь <var>newOffset</var> на <a href="#concept-node-length" title="concept-node-length">длину</a> <var>node</var>, если <var>node</var> является
 <code><a href="#documentfragment">DocumentFragment</a></code> <a href="#concept-node" title="concept-node">узлом</a>, и на один в другом случае.

 <li><p><a href="#concept-node-pre-insert" title="concept-node-pre-insert">Предварительно вставить</a>
 <var>node</var> в <var>parent</var> перед <var>referenceNode</var>.

 <li><p>Если <a href="#concept-range-start" title="concept-range-start">начало</a> и
 <a href="#concept-range-end" title="concept-range-end">конец</a> <var>range</var> являются одним и тем же, установить <a href="#concept-range-end" title="concept-range-end">конец</a> <var>range</var> к
 (<var>parent</var>, <var>newOffset</var>).
</ol>

<p>Метод <dfn id="dom-range-insertnode" title="dom-Range-insertNode"><code>insertNode(<var>node</var>)</code></dfn>
должен <a href="#concept-range-insert" title="concept-range-insert">вставить</a> <var>node</var> в
<a href="#context-object">объект контекста</a>.

<p>Метод
<dfn id="dom-range-surroundcontents" title="dom-Range-surroundContents"><code>surroundContents(<var>newParent</var>)</code></dfn>
должен выполнить следующие шаги:

<!--
IE9 and Chrome 12 dev throw exceptions before doing any DOM mutations in at
least some cases, so they don't wind up modifying the DOM halfway. Like if you
try surrounding a selection with an ancestor. As with insertNode(), this is
slightly nicer, but Firefox 4.0 and Opera 11.00 don't do this, and their
behavior is slightly easier to spec, so I go with them for exceptions that are
thrown by things we call, like insertNode(). However, for
BAD_BOUNDARYPOINTS_ERR/INVALID_NODE_TYPE_ERR that we throw ourselves, I do the
check first thing, which matches everyone but Firefox.
-->

<ol>
 <li><p>Если не-<code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узел</a>
 <a href="#partially-contained">частично содержится</a> в <a href="#context-object">объекте контекста</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidstateerror">InvalidStateError</a></code>".
 <!-- Makes some sense: otherwise we'd clone a bunch of containers, which is
 unexpected. -->
 <!-- XXX Could we rephrase this condition to be more algorithmic and less
 declarative?-->

 <li><p>Если <var>newParent</var> является <code><a href="#document">Document</a></code>,
 <code><a href="#documenttype">DocumentType</a></code> или <code><a href="#documentfragment">DocumentFragment</a></code>
 <a href="#concept-node" title="concept-node">узлом</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>".
 <!-- But for Comment, Text, and ProcessingInstruction, we just fall through
 and throw a HIERARCHY_REQUEST_ERR when we try appendChild(). This makes
 absolutely no sense, but it's what DOM 2 Range specifies, and it's what
 IE9, Chrome 12 dev, and Opera 11.00 implement. Firefox 4.0 only throws
 INVALID_NODE_TYPE_ERR on DocumentFragments, it falls through to
 HIERARCHY_REQUEST_ERR for Documents and DocumentTypes.

 Firefox 4.0 does this check later on, so it will do DOM mutations of some
 type if passed a DocumentFragment. We match IE9, Chrome 12 dev, and Opera
 11.00 in doing the check early.

 If newParent is a Document/DocumentType/DocumentFragment, and some node is
 also partially contained, DOM 2 Range doesn't say whether to throw
 BAD_BOUNDARYPOINTS_ERR or INVALID_NODE_TYPE_ERR. IE9 and Chrome 12 dev
 throw INVALID_NODE_TYPE_ERR, while Firefox 4.0 and Opera 11.00 throw
 BAD_BOUNDARYPOINTS_ERR. I chose the latter because it's the first thing I
 happened to write down and it makes no real difference, with the even
 split. -->

 <li><p>Сделать <var>fragment</var> результатом
 <a href="#concept-range-extract" title="concept-range-extract">извлечения</a> <a href="#context-object">объекта контекста</a>.
 <!-- If the range contains a DocumentType, Firefox 4.0 and Opera 11.00 don't
 immediately throw here. Firefox removes the non-DocumentType nodes and
 throws, Opera removes all nodes and doesn't throw. This applies to
 extractContents() proper, and also affects surroundContents(). I match DOM 2
 Range, IE9, and Chrome 12 dev. -->

 <li><p>Если <var>newParent</var> имеет
 <a href="#concept-tree-child" title="concept-tree-child">дочерние</a>,
 <a href="#concept-node-replace-all" title="concept-node-replace-all">заменить все</a> на null внутри
 <var>newParent</var>.

 <li><p><a href="#concept-range-insert" title="concept-range-insert">Вставить</a> <var>newParent</var> в
 <a href="#context-object">объект контекста</a>.

 <li><p><a href="#concept-node-append" title="concept-node-append">Добавить</a> <var>fragment</var> к
 <var>newParent</var>.

 <li><p><a href="#concept-range-select" title="concept-range-select">Выбрать</a> <var>newParent</var> внутри
 <a href="#context-object">объекта контекста</a>.
 <!-- Generally this isn't needed, because insertNode() will already do it,
 but it makes a difference in at least one corner case (when the original
 range lies in a single text node). -->
</ol>

<p>Метод <dfn id="dom-range-clonerange" title="dom-Range-cloneRange"><code>cloneRange()</code></dfn>
должен возвратить новый <a href="#concept-range" title="concept-range">диапазон</a> с
тем же <a href="#concept-range-start" title="concept-range-start">началом</a> и
<a href="#concept-range-end" title="concept-range-end">концом</a> как и у <a href="#context-object">объекта контекста</a>.

<p>Метод <dfn id="dom-range-detach" title="dom-Range-detach"><code>detach()</code></dfn> должен не делать ничего. <span class="note">Заметка: Его функциональность (отключение объекта
<code><a href="#range">Range</a></code>) была удалена, но сам метод остается для совместимости.</span>

<hr>

<dl class="domintro">
 <dt><var>position</var> = <var>range</var> . <code title="dom-Range-comparePoint"><a href="#dom-range-comparepoint">comparePoint</a></code>( <var>parent</var>, <var>offset</var> )
 <dd><p>Возвращает −1 если точка перед диапазоном, 0 если точка внутри диапазона, и 1 если точка после диапазона.

 <dt><var>intersects</var> = <var>range</var> . <code title="dom-Range-intersectsNode"><a href="#dom-range-intersectsnode">intersectsNode</a></code>( <var>node</var> )
 <dd><p>Возвращает пересекает ли <var>range</var>
 <var>node</var>-у.
</dl>

<div class="impl">

<p>Метод
<dfn id="dom-range-ispointinrange" title="dom-Range-isPointInRange"><code>isPointInRange(<var>node</var>, <var>offset</var>)</code></dfn>
должен выполнить следующие шаги:
<!-- Tested October 2011 on Firefox 9.0a2 and Chrome 16 dev.  IE9 and Opera
11.50 don't support the method. -->

<ol>
 <li><p>Если <a href="#concept-tree-root" title="concept-tree-root">корень</a> <var>node</var>
 отличается от <a href="#concept-range-root" title="concept-range-root">корня</a> <a href="#context-object">объекта контекста</a>, возвратить false.
 <!-- This happens even if the offset is negative or too large, or if the node
 is a doctype, in both Firefox 9.0a2 and Chrome 16 dev. -->

 <li><p>Если <var>node</var> является
 <a href="#concept-doctype" title="concept-doctype">doctype</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>" исключение.
 <!-- Firefox 9.0a2 doesn't throw.  It ignores the offset and returns true or
 false depending on whether the doctype itself is in the range.  This makes
 some sense, but it doesn't match how other Range APIs handle doctypes, and
 having the second argument mandatory but ignored is just weird.  Thus I go
 with Chrome 16 dev, although I can see the merit in how Gecko works here. -->

 <li><p>Если <var>offset</var> больше чем <a href="#concept-node-length" title="concept-node-length">длина</a>
 <var>node</var>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>" исключение.
 <!-- Firefox 9.0a2 doesn't throw.  It seems to return true if the node is
 completely contained in the range, like with selectNode(), and false otherwise
 - even if all boundary points in the node are contained in the range, like
 with selectNodeContents().  This is weird, and inconsistent with other Range
 APIs, so I go with Chrome 16 dev.  This is probably an authoring bug, so it's
 best to throw anyway. -->

 <li><p>Если (<var>node</var>, <var>offset</var>) идет
 <a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a>
 <a href="#concept-range-start" title="concept-range-start">началом</a> или
 <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a>
 <a href="#concept-range-end" title="concept-range-end">конца</a>, возвратить false.

 <li><p>Возвратить true.
</ol>


<p>Метод
<dfn id="dom-range-comparepoint" title="dom-Range-comparePoint"><code>comparePoint(<var>node</var>, <var>offset</var>)</code></dfn>
должен выполнить следующие шаги:
<!-- IE9 doesn't support this method at all.  Firefox 12.0a1, Chrome 17 dev,
and Opera Next 12.00 alpha all do. -->

<ol>
 <li><p>Если <a href="#concept-tree-root" title="concept-tree-root">корень</a> <var>node</var>
 отличается от <a href="#concept-range-root" title="concept-range-root">корня</a> <a href="#context-object">объекта контекста</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#wrongdocumenterror">WrongDocumentError</a></code>".
 <!-- Opera Next 12.00 alpha seems to return -1 in this case.  The spec matches
 Firefox 12.0a1 and Chrome 17 dev. -->

 <li><p>Если <var>node</var> является
 <a href="#concept-doctype" title="concept-doctype">doctype</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidnodetypeerror">InvalidNodeTypeError</a></code>" исключение.
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw and seem to just ignore the offset instead.  See
 comment for isPointInRange(). -->

 <li><p>Если <var>offset</var> больше чем
 <var>node</var> <a href="#concept-node-length" title="concept-node-length">длина</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#indexsizeerror">IndexSizeError</a></code>".
 <!-- This matches Chrome 17 dev instead of Firefox 12.0a1 and Opera Next 12.00
 alpha, which don't throw.  See comment for isPointInRange(). -->

 <li><p>Если (<var>node</var>, <var>offset</var>) идет
 <a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a>
 <a href="#concept-range-start" title="concept-range-start">началом</a>, возвратить −1.

 <li><p>Если (<var>node</var>, <var>offset</var>) идет
 <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a>
 <a href="#concept-range-end" title="concept-range-end">конца</a>, возвратить 1.

 <li><p>Возвратить 0.
</ol>

<hr>

<p>Метод
<dfn id="dom-range-intersectsnode" title="dom-Range-intersectsNode"><code>intersectsNode(<var>node</var>)</code></dfn>
должен выполнить следующие шаги:
<!-- Supported by Chrome 17 dev and Opera Next 12.00 alpha, but not IE9 or
Firefox 12.0a1. -->

<ol>
 <li><p>Если <a href="#concept-tree-root" title="concept-tree-root">корень</a> <var>node</var>
 отличается от <a href="#concept-range-root" title="concept-range-root">корня</a> <a href="#context-object">объекта контекста</a>, возвратить false.
 <!-- It seems like for doctypes, Opera Next 12.00 alpha throws
 InvalidNodeTypeError instead of returning false.  The spec follows Chrome
 17 dev. -->

 <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родителем</a> <var>node</var>.

 <li><p>Если <var>parent</var> является null, возвратить true.
 <!-- browsers currently throw, but are willing to change
      https://www.w3.org/Bugs/Public/show_bug.cgi?id=16759 -->

 <li><p>Сделать <var>offset</var> <a href="#concept-tree-index" title="concept-tree-index">индексом</a> <var>node</var>.

 <li><p>Если (<var>parent</var>, <var>offset</var>) идет
 <a href="#concept-range-bp-before" title="concept-range-bp-before">перед</a>
 <a href="#concept-range-end" title="concept-range-end">концом</a> и (<var>parent</var>,
 <var>offset</var> + 1) идет
 <a href="#concept-range-bp-after" title="concept-range-bp-after">после</a>
 <a href="#concept-range-start" title="concept-range-start">начала</a>, возвратить true.

 <li><p>Возвратить false.
</ol>

</div>

<hr>

<p>Метод <dfn id="dom-range-stringifier" title="dom-Range-stringifier">stringifier</dfn> должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>s</var> пустой строкой.

 <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> равняется
 <a href="#concept-range-end-node" title="concept-range-end-node">конечным узлом</a> и
 <code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узлом</a>, возвратить
 извлечение <a href="#concept-cd-data" title="concept-CD-data">данных</a> этого <code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узла</a>, начиная на
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начальном смещении</a> и заканчивая на
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечном смещении</a>.

 <li><p>Если <a href="#concept-range-start-node" title="concept-range-start-node">начальный узел</a> является
 <code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узлом</a>, добавить к
 <var>s</var> извлечение <a href="#concept-cd-data" title="concept-CD-data">данных</a> этого
 <a href="#concept-node" title="concept-node">узла</a> от
 <a href="#concept-range-start-offset" title="concept-range-start-offset">начального смещения</a> до конца.

 <li><p>Добавить к <var>s</var> конкатенацию, в
 <a href="#concept-tree-order" title="concept-tree-order">порядке дерева</a>,
 <a href="#concept-cd-data" title="concept-CD-data">данных</a> всех <code><a href="#text">Text</a></code>
 <a href="#concept-node" title="concept-node">узлов</a>, которые <a href="#contained">содержатся</a> в
 <a href="#context-object">объекте контекста</a>.

 <li><p>Если <a href="#concept-range-end-node" title="concept-range-end-node">конечный узел</a> является
 <code><a href="#text">Text</a></code> <a href="#concept-node" title="concept-node">узлом</a>, добавить к
 <var>s</var> извлечение <a href="#concept-cd-data" title="concept-CD-data">данных</a> этого
 <a href="#concept-node" title="concept-node">узла</a> от начала до
 <a href="#concept-range-end-offset" title="concept-range-end-offset">конечного смещения</a>.

 <li><p>Возвратить <var>s</var>.
</ol>

<hr>

<p class="note">Заметка: Методы
<code class="external" data-anolis-spec="domps" title="createContextualFragment"><a href="http://www.w3.org/TR/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment">createContextualFragment()</a></code>,
<code class="external" data-anolis-spec="cssom-view" title="dom-Range-getClientRects"><a href="http://www.w3.org/TR/cssom-view/#the-getclientrects%28%29-and-getboundingclientrect%28%29-methods">getClientRects()</a></code> и
<code class="external" data-anolis-spec="cssom-view" title="dom-Range-getBoundingClientRect"><a href="http://www.w3.org/TR/cssom-view/#the-getclientrects%28%29-and-getboundingclientrect%28%29-methods">getBoundingClientRect()</a></code>
определены в других спецификациях.
<a class="informative" href="#biblio-DOMPS">[DOMPS]</a>
<a class="informative" href="#biblio-CSSOMVIEW">[CSSOMVIEW]</a>



<h2 id="traversal"><span class="secno">6 </span>Обход</h2>

<p>Объекты <code><a href="#nodeiterator">NodeIterator</a></code> и <code><a href="#treewalker">TreeWalker</a></code> могут использоваться
для фильтрации и обхода <a href="#concept-tree" title="concept-tree">деревьев</a> <a href="#concept-node" title="concept-node">узлов</a>.

<p>Каждый объект <code><a href="#nodeiterator">NodeIterator</a></code> и <code><a href="#treewalker">TreeWalker</a></code> также имеет соответствующий <dfn id="concept-traversal-root" title="concept-traversal-root">корневой</dfn>
<a href="#concept-node" title="concept-node">узел</a>,
<dfn id="concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</dfn> битмаск и
<dfn id="concept-traversal-filter" title="concept-traversal-filter">filter</dfn> приемник (callback).

<p>Чтобы <dfn id="concept-node-filter" title="concept-node-filter">фильтровать</dfn> <var>узел</var>, выполните следующие шаги:

<ol>
 <li><p>Сделать <var>n</var> значением атрибута <code title="dom-Node-nodeType"><a href="#dom-node-nodetype">nodeType</a></code> <var>узла</var> минус 1.
 <li><p>Если <var>n</var><sup>-й</sup> бит (где 0 является последним значительным битом) от
 <a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> не установлен,
 возвратить <code title="dom-NodeFilter-FILTER_SKIP"><a href="#dom-nodefilter-filter_skip">FILTER_SKIP</a></code>.
 <!-- !((1 << (node.nodeType - 1)) & whatToShow) -->
 <li><p>Если <a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a> равен null,
 возвратить <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>.
 <li><p>Сделать <var>result</var> возвращенным значением вызова <code title="dom-NodeFilter-acceptNode">acceptNode</code>
 <a href="#concept-traversal-filter" title="concept-traversal-filter">фильтра</a> с <var>node</var> в качестве аргумента. Повторно выбросить какие-либо исключения.
 <!-- no need to pass callback this value; it's undefined which becomes the global object -->
 <li><p>Возвратить <var>result</var>.
</ol>


<h3 id="interface-nodeiterator"><span class="secno">6.1 </span>Интерфейс <code><a href="#nodeiterator">NodeIterator</a></code></h3>

<pre class="idl">[Exposed=Window]
interface <dfn id="nodeiterator">NodeIterator</dfn> {
  [SameObject] readonly attribute <a href="#node">Node</a> <a href="#dom-nodeiterator-root" title="dom-NodeIterator-root">root</a>;
  readonly attribute <a href="#node">Node</a> <a href="#dom-nodeiterator-referencenode" title="dom-NodeIterator-referenceNode">referenceNode</a>;
  readonly attribute boolean <a href="#dom-nodeiterator-pointerbeforereferencenode" title="dom-NodeIterator-pointerBeforeReferenceNode">pointerBeforeReferenceNode</a>;
  readonly attribute unsigned long <a href="#dom-nodeiterator-whattoshow" title="dom-NodeIterator-whatToShow">whatToShow</a>;
  readonly attribute <a href="#nodefilter">NodeFilter</a>? <a href="#dom-nodeiterator-filter" title="dom-NodeIterator-filter">filter</a>;<!--
  readonly attribute boolean <span title=dom-NodeIterator-expandEntityReferences>expandEntityReferences</span>;-->

  <a href="#node">Node</a>? <a href="#dom-nodeiterator-nextnode" title="dom-NodeIterator-nextNode">nextNode</a>();
  <a href="#node">Node</a>? <a href="#dom-nodeiterator-previousnode" title="dom-NodeIterator-previousNode">previousNode</a>();

  void <a href="#dom-nodeiterator-detach" title="dom-NodeIterator-detach">detach</a>();
};</pre>

<p class="note">Заметка: объекты <code><a href="#nodeiterator">NodeIterator</a></code> могут быть созданы использованием метода
<code title="dom-Document-createNodeIterator"><a href="#dom-document-createnodeiterator">createNodeIterator()</a></code>.

<p>Каждый объект <code><a href="#nodeiterator">NodeIterator</a></code> имеет соответствующий
<dfn id="iterator-collection">набор итераторов</dfn>, который представляет собой
<a href="#concept-collection" title="concept-collection">коллекцию</a> с корнем в
<a href="#concept-traversal-root" title="concept-traversal-root">корне</a>, чей фильтр соответствует любому
<a href="#concept-node" title="concept-node">узлу</a>.

<p>Каждый объект <code><a href="#nodeiterator">NodeIterator</a></code> имеет следующие
<a href="#concept-node-remove-ext" title="concept-node-remove-ext">шаги удаления</a> с <var>oldNode</var>,
<var>oldParent</var> и <var>oldPreviousSibling</var>:

<ol>
 <li><p>Если <var>oldNode</var> не является
 <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a> значения атрибута
 <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code>,
 прекратить данные шаги.

 <li>
  <p>Если значение атрибута
  <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code>
  является true, выполнить следующие подшаги:

  <ol>
   <li><p>Сделать <var>nextSibling</var> <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим дочерним</a> <var>oldPreviousSibling</var>-а, если
   <var>oldPreviousSibling</var> не является null, и <a href="#concept-tree-first-child" title="concept-tree-first-child">первого дочернего</a> <var>oldParent</var>-а в другом случае.

   <li><p>Если <var>nextSibling</var> не является null, установить атрибут
   <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code> к
   <var>nextSibling</var> и прекратить данные шаги.

   <li><p>Сделать <var>next</var> первым <a href="#concept-node" title="concept-node">узлом</a>
   <a href="#concept-tree-following" title="concept-tree-following">следующего</a> <var>oldParent</var>.

   <li><p>Если <var>next</var> не является
   <a href="#concept-tree-inclusive-ancestor" title="concept-tree-inclusive-ancestor">включительным предком</a>
   <a href="#concept-traversal-root" title="concept-traversal-root">корня</a>, установить атрибут
   <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code> к
   <var>next</var> и прекратить данные шаги.

   <li>
    <p>В другом случае, установить атрибут
    <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code>
    к false.

    <p class="note">Заметка: Шаги не прерываются здесь.
  </ol>

 <li><p>Установить атрибут <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code> к первому <a href="#concept-node" title="concept-node">узлу</a>
 <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующему</a> <var>oldPreviousSibling</var>, если
 <var>oldPreviousSibling</var> не является null, и к <var>oldParent</var> в другом случае.
</ol>

<p class="note">Заметка: Как упоминалось ранее, объекты <code><a href="#nodeiterator">NodeIterator</a></code> имеют соответствующий <a href="#concept-traversal-root" title="concept-traversal-root">корневой</a>
<a href="#concept-node" title="concept-node">узел</a>,
<a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> битмаск и
<a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a> приемник (callback) также.

<hr>

<p>Атрибут <dfn id="dom-nodeiterator-root" title="dom-NodeIterator-root"><code>root</code></dfn> должен возвратить <a href="#concept-traversal-root" title="concept-traversal-root">корень</a>.</p>

<p>Атрибуты
<dfn id="dom-nodeiterator-referencenode" title="dom-NodeIterator-referenceNode"><code>referenceNode</code></dfn>
и
<dfn id="dom-nodeiterator-pointerbeforereferencenode" title="dom-NodeIterator-pointerBeforeReferenceNode"><code>pointerBeforeReferenceNode</code></dfn>
должны возвратить то к чему они инициализированы.</p>

<p>Атрибут <dfn id="dom-nodeiterator-whattoshow" title="dom-NodeIterator-whatToShow"><code>whatToShow</code></dfn>
должен возвратить
<a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a>.

<p>Атрибут <dfn id="dom-nodeiterator-filter" title="dom-NodeIterator-filter"><code>filter</code></dfn>
должен возвратить <a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a>.

<p>Чтобы <dfn id="concept-nodeiterator-traverse" title="concept-NodeIterator-traverse">обойти</dfn> в направлении
<var>direction</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута
 <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code>.

 <li><p>Сделать <var>before node</var> значением
 <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code> атрибута.

 <li>
  <p>Выполнить следующие подшаги:
  <ol>
   <li>
    <dl class="switch">
     <dt>Если направление является next</dt>
     <dd>
      <p>Если <var>before node</var> равняется false, сделать <var>node</var>
      первым <a href="#concept-node" title="concept-node">узлом</a>
      <a href="#concept-tree-following" title="concept-tree-following">следующим</a>
      <var>node</var> в <a href="#iterator-collection">наборе итераторов</a>. Если
      нет такого <a href="#concept-node" title="concept-node">узла</a>, возвратить null.
      <p>Если <var>before node</var> равняется true, установить ее к false.
     <dt>Если направление является previous</dt>
     <dd>
      <p>Если <var>before node</var> является true, сделать <var>node</var>
      первым <a href="#concept-node" title="concept-node">узлом</a>
      <a href="#concept-tree-preceding" title="concept-tree-preceding">предшествующим</a>
      <var>узлу</var> в <a href="#iterator-collection">наборе итераторов</a>. Если
      нет такого <a href="#concept-node" title="concept-node">узла</a>, возвратить null.
      <p>Если <var>before node</var> является false, установить ее к true.
    </dl>
   <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
   <var>node</var> и сделать <var>result</var> возвращаемым значением.
   <li>
    <p>Если <var>result</var> является
    <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, перейти к следующему шагу в общем наборе шагов.
    <p>В другом случае, выполнить эти подшаги заново.
  </ol>
 <li><p>Установить атрибут
 <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code> к <var>node</var>, установить атрибут
 <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code>
 к <var>before node</var>, и возвратить
 <var>node</var>.
</ol>

<p>Метод <dfn id="dom-nodeiterator-nextnode" title="dom-NodeIterator-nextNode"><code>nextNode()</code></dfn>
должен <a href="#concept-nodeiterator-traverse" title="concept-NodeIterator-traverse">обойти</a> в направлении next.

<p>Метод
<dfn id="dom-nodeiterator-previousnode" title="dom-NodeIterator-previousNode"><code>previousNode()</code></dfn>
должен <a href="#concept-nodeiterator-traverse" title="concept-NodeIterator-traverse">обойти</a> в направлении previous.

<p>Метод <dfn id="dom-nodeiterator-detach" title="dom-NodeIterator-detach"><code>detach()</code></dfn>
должен не делать ничего. <span class="note">Заметка: Его функциональность (отключение объекта
<code><a href="#nodeiterator">NodeIterator</a></code>) была удалена, но сам метод остается для совместимости.</span>


<h3 id="interface-treewalker"><span class="secno">6.2 </span>Интерфейс <code><a href="#treewalker">TreeWalker</a></code></h3>

<pre class="idl">[Exposed=Window]
interface <dfn id="treewalker">TreeWalker</dfn> {
  [SameObject] readonly attribute <a href="#node">Node</a> <a href="#dom-treewalker-root" title="dom-TreeWalker-root">root</a>;
  readonly attribute unsigned long <a href="#dom-treewalker-whattoshow" title="dom-TreeWalker-whatToShow">whatToShow</a>;
  readonly attribute <a href="#nodefilter">NodeFilter</a>? <a href="#dom-treewalker-filter" title="dom-TreeWalker-filter">filter</a>;<!--
  readonly attribute boolean <span title=dom-TreeWalker-expandEntityReferences>expandEntityReferences</span>;-->
           attribute <a href="#node">Node</a> <a href="#dom-treewalker-currentnode" title="dom-TreeWalker-currentNode">currentNode</a>;

  <a href="#node">Node</a>? <a href="#dom-treewalker-parentnode" title="dom-TreeWalker-parentNode">parentNode</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-firstchild" title="dom-TreeWalker-firstChild">firstChild</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-lastchild" title="dom-TreeWalker-lastChild">lastChild</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-previoussibling" title="dom-TreeWalker-previousSibling">previousSibling</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-nextsibling" title="dom-TreeWalker-nextSibling">nextSibling</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-previousnode" title="dom-TreeWalker-previousNode">previousNode</a>();
  <a href="#node">Node</a>? <a href="#dom-treewalker-nextnode" title="dom-TreeWalker-nextNode">nextNode</a>();
};</pre>

<p class="note">Заметка: Объекты <code><a href="#treewalker">TreeWalker</a></code> могут быть созданы использованием метода
<code title="dom-Document-createTreeWalker"><a href="#dom-document-createtreewalker">createTreeWalker()</a></code>.

<p class="note">Заметка: Как упоминалось ранее, объекты <code><a href="#treewalker">TreeWalker</a></code> имеют
соответствующий <a href="#concept-traversal-root" title="concept-traversal-root">корневой</a>
<a href="#concept-node" title="concept-node">узел</a>,
<a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> битмаск и
<a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a> приемник (callback).

<p>Атрибут <dfn id="dom-treewalker-root" title="dom-TreeWalker-root"><code>root</code></dfn> должен возвратить <a href="#concept-traversal-root" title="concept-traversal-root">root</a>.</p>

<p>Атрибут <dfn id="dom-treewalker-whattoshow" title="dom-TreeWalker-whatToShow"><code>whatToShow</code></dfn>
должен возвратить
<a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a>.

<p>Атрибут <dfn id="dom-treewalker-filter" title="dom-TreeWalker-filter"><code>filter</code></dfn> должен возвратить <a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a>.

<p>Атрибут <dfn id="dom-treewalker-currentnode" title="dom-TreeWalker-currentNode"><code>currentNode</code></dfn>
должен возвратить то к чему был инициализирован.</p>

<p>Установка атрибута <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
должна установить его к новому значению.</p>


<p>Метод <dfn id="dom-treewalker-parentnode" title="dom-TreeWalker-parentNode"><code>parentNode()</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута
 <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>.

 <li>
  <p>Пока <var>node</var> не является null и не является
  <a href="#concept-traversal-root" title="concept-traversal-root">корнем</a>, выполнить следующие подшаги:

  <ol>
   <li><p>Сделать <var>node</var> <a href="#concept-tree-parent" title="concept-tree-parent">родительским</a> для <var>node</var>.

   <li><p>Если <var>node</var> не является null и
   <a href="#concept-node-filter" title="concept-node-filter">фильтрация</a> <var>узла</var>
   возвращает <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>,
   то установить атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
   к <var>node</var>, возвратить <var>node</var>.
  </ol>

 <li><p>Возвратить null.
</ol>

<p>Чтобы <dfn id="concept-traverse-children" title="concept-traverse-children">обойти дочерние</dfn> типа
<var>type</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>.

 <li><p>Установить <var>node</var> к <a href="#concept-tree-first-child" title="concept-tree-first-child">первому дочернему</a> <var>узла</var> если
 <var>type</var> является первым, и <a href="#concept-tree-last-child" title="concept-tree-last-child">последним дочерним</a> <var>узла</var> если <var>type</var> является последним.

 <li>
  <p><dfn id="concept-traverse-children-main" title="concept-traverse-children-main">Главный</dfn>:
  Пока <var>node</var> не является null, выполнить следующие подшаги:

  <ol>
   <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
   <var>node</var> и сделать <var>result</var> возвращаемым значением.

   <li><p>Если <var>result</var> является
   <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить
   атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
   к <var>node</var> и возвратить <var>node</var>.

   <li>
    <p>Если <var>result</var> является
    <code title="dom-NodeFilter-FILTER_SKIP"><a href="#dom-nodefilter-filter_skip">FILTER_SKIP</a></code>, выполнить следующие подшаги:

    <ol>
     <li><p>Сделать <var>child</var> <a href="#concept-tree-first-child" title="concept-tree-first-child">первым дочерним</a> <var>узла</var>если
     <var>type</var> является первым, и <a href="#concept-tree-last-child" title="concept-tree-last-child">последним дочерним</a> <var>узла</var> если
     <var>type</var> является последним.

     <li><p>Если <var>child</var> не является null, установить <var>node</var>
     к <var>child</var> и перейти к
     <a href="#concept-traverse-children-main" title="concept-traverse-children-main">Главному</a>.
    </ol>

   <li>
    <p>Пока <var>node</var> не является null, выполнить следующие шаги:

    <ol>
     <li><p>Сделать <var>sibling</var> <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>узла</var> если
     <var>type</var> является первым, и <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>узла</var>
      если
     <var>type</var> является последним.

     <li><p>Если <var>сестринский</var> не является null, установить
     <var>node</var> к <var>sibling</var> и перейти к
     <a href="#concept-traverse-children-main" title="concept-traverse-children-main">Главному</a>.

     <li><p>Сделать <var>parent</var> <a href="#concept-tree-parent" title="concept-tree-parent">родительским</a> <var>узла</var>.

     <li><p>Если <var>parent</var> не является null, <var>parent</var> является
     <a href="#concept-traversal-root" title="concept-traversal-root">root</a> или
     <var>parent</var> является значением атрибута
     <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>, возвратить null.

     <li><p>В другом случае, установить <var>node</var> к <var>parent</var>.
    </ol>
  </ol>
 <li><p>Возвратить null.
</ol>

<p>Метод <dfn id="dom-treewalker-firstchild" title="dom-TreeWalker-firstChild"><code>firstChild()</code></dfn>
должен <a href="#concept-traverse-children" title="concept-traverse-children">обойти дочерние</a>
первого типа.

<p>Метод <dfn id="dom-treewalker-lastchild" title="dom-TreeWalker-lastChild"><code>lastChild()</code></dfn>
должен <a href="#concept-traverse-children" title="concept-traverse-children">обойти дочерние</a>
последнего типа.

<p>Чтобы <dfn id="concept-traverse-siblings" title="concept-traverse-siblings">обойти дочерние</dfn> типа
<var>type</var>, выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута
 <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>.

 <li><p>Если <var>node</var> является
 <a href="#concept-traversal-root" title="concept-traversal-root">корневым</a>, возвратить null.

 <li>
  <p>Выполнить следующие подшаги:

  <ol>
   <li><p>Сделать <var>sibling</var> <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующим сестринским</a> <var>узла</var> если
   <var>type</var> является следующим, и <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>узла</var> если
   <var>type</var> является предыдущим.

   <li>
    <p>Пока <var>sibling</var> не является null, выполнить следующие подшаги:

    <ol>
     <li><p>Установить <var>node</var> к <var>sibling</var>.

     <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
     <var>node</var> и сделать <var>result</var> возвращаемым значением.

     <li><p>Если <var>result</var> является
     <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить атрибут
     the <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
     к <var>node</var> и возвратить <var>node</var>.

     <li><p>Установить <var>sibling</var> к <a href="#concept-tree-first-child" title="concept-tree-first-child">первому дочернему</a> <var>узла</var> если
     <var>type</var> является следующим, и <a href="#concept-tree-last-child" title="concept-tree-last-child">последним дочерним</a> <var>узла</var> если
     <var>type</var> является предыдущим.

     <li><p>Если <var>result</var> является
     <code title="dom-NodeFilter-FILTER_REJECT"><a href="#dom-nodefilter-filter_reject">FILTER_REJECT</a></code> или
     <var>sibling</var> является null, то установить <var>sibling</var> к <a href="#concept-tree-next-sibling" title="concept-tree-next-sibling">следующему сестринскому</a>
     <var>узла</var> если
     <var>type</var> является следующим, и <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущий сестринский</a> <var>узла</var> если
     <var>type</var> является предыдущим.
    </ol>

   <li><p>Установить <var>node</var> к его
   <a href="#concept-tree-parent" title="concept-tree-parent">родительскому</a>.

   <li><p>Если <var>node</var> является null или является
   <a href="#concept-traversal-root" title="concept-traversal-root">корнем</a> возвратить null.

   <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
   <var>node</var> и если возвращаемое значение является
   <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то
   возвратить null.
   <!-- XXX WTF? -->

   <li><p>Выполнить данные подшаги заново.
  </ol>
</ol>

<p>Метод
<dfn id="dom-treewalker-nextsibling" title="dom-TreeWalker-nextSibling"><code>nextSibling()</code></dfn>
должен <a href="#concept-traverse-siblings" title="concept-traverse-siblings">обойти сестринские</a>
последнего типа.

<p>Метод
<dfn id="dom-treewalker-previoussibling" title="dom-TreeWalker-previousSibling"><code>previousSibling()</code></dfn>
должен <a href="#concept-traverse-siblings" title="concept-traverse-siblings">обойти сестринские</a>
предыдущего типа.

<p>Метод
<dfn id="dom-treewalker-previousnode" title="dom-TreeWalker-previousNode"><code>previousNode()</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута
 <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>.

 <li>
  <p>Пока <var>node</var> не является
  <a href="#concept-traversal-root" title="concept-traversal-root">корневым</a>, выполнить следующие шаги:

  <ol>
   <li><p>Сделать <var>sibling</var>
   <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущим сестринским</a> <var>узла</var>.

   <li>
    <p>Пока <var>sibling</var> не является null, выполнить следующие подшаги:

    <ol>
     <li><p>Установить <var>node</var> к <var>sibling</var>.

     <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
     <var>node</var> и сделать <var>result</var> возвращаемым значением.

     <li><p>Пока <var>result</var> не является
     <code title="dom-NodeFilter-FILTER_REJECT"><a href="#dom-nodefilter-filter_reject">FILTER_REJECT</a></code> и
     <var>node</var> имеет
     <a href="#concept-tree-child" title="concept-tree-child">дочерний</a>, установить <var>node</var>
     к своему <a href="#concept-tree-last-child" title="concept-tree-last-child">последнему дочернему</a> и затем
     <a href="#concept-node-filter" title="concept-node-filter">filter</a> <var>node</var> and
     установить <var>result</var> как возвращаемое значение.

     <li><p>Если <var>result</var> является
     <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить
     атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
     к <var>node</var> и возвратить <var>node</var>.

     <li><p>Установить <var>sibling</var> к
     <a href="#concept-tree-previous-sibling" title="concept-tree-previous-sibling">предыдущему сестринскому</a>
     <var>узла</var>.
    </ol>

   <li><p>Если <var>node</var> является
   <a href="#concept-traversal-root" title="concept-traversal-root">корнем</a> или <a href="#concept-tree-parent" title="concept-tree-parent">родительский</a> <var>узла</var> является null, возвратить null.

   <li><p>Установить <var>node</var> к его
   <a href="#concept-tree-parent" title="concept-tree-parent">родительскому</a>.

   <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
   <var>node</var> и если возвращаемое значение
   <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить
   атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code> к
   <var>node</var> и возвратить <var>node</var>.
  </ol>

 <li><p>Возвратить null.
</ol>

<p>Метод <dfn id="dom-treewalker-nextnode" title="dom-TreeWalker-nextNode"><code>nextNode()</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Сделать <var>node</var> значением атрибута
 <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>.

 <li><p>Сделать <var>result</var>
 <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>.

 <li>
  <p>Выполнить следующие подшаги:

  <ol>
   <li>
    <p>Пока <var>result</var> не является
    <code title="dom-NodeFilter-FILTER_REJECT"><a href="#dom-nodefilter-filter_reject">FILTER_REJECT</a></code> и
    <var>node</var> имеет <a href="#concept-tree-child" title="concept-tree-child">child</a>,
    выполнить следующие подшаги:

    <ol>
     <li><p>Установить <var>node</var> к его
     <a href="#concept-tree-first-child" title="concept-tree-first-child">первому дочернему</a>.

     <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
     <var>node</var> и установить <var>result</var> к возвращаемому значению.

     <li><p>Если <var>result</var> является
     <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить
     атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code>
     к <var>node</var> и возвратить <var>node</var>.
    </ol>

   <li>
    <p>Если <a href="#concept-node" title="concept-node">node</a> является
    <a href="#concept-tree-following" title="concept-tree-following">следующим</a>
    <var>узлом</var> и не является
    <a href="#concept-tree-following" title="concept-tree-following">следующим</a>
    <a href="#concept-traversal-root" title="concept-traversal-root">корня</a>, установить
    <var>node</var> к первому такому
    <a href="#concept-node" title="concept-node">узлу</a>.
    <p>В другом случае, возвратить null.
    <!-- Implemented as iterating over parent/nextSibling -->

   <li><p><a href="#concept-node-filter" title="concept-node-filter">Фильтровать</a>
   <var>node</var> и установить <var>result</var> как возвращаемое значение.

   <li><p>Если <var>result</var> является
   <code title="dom-NodeFilter-FILTER_ACCEPT"><a href="#dom-nodefilter-filter_accept">FILTER_ACCEPT</a></code>, то установить
   атрибут <code title="dom-TreeWalker-currentNode"><a href="#dom-treewalker-currentnode">currentNode</a></code> к <var>node</var> и возвратить <var>node</var>.

   <li><p>Выполнить эти подшаги заново.
  </ol>
</ol>



<h3 id="interface-nodefilter"><span class="secno">6.3 </span>Интерфейс <code><a href="#nodefilter">NodeFilter</a></code></h3>

<pre class="idl">[Exposed=Window]
callback interface <dfn id="nodefilter">NodeFilter</dfn> {
  // Constants for <span title="dom-NodeFilter-acceptNode">acceptNode()</span>
  const unsigned short <a href="#dom-nodefilter-filter_accept" title="dom-NodeFilter-FILTER_ACCEPT">FILTER_ACCEPT</a> = 1;
  const unsigned short <a href="#dom-nodefilter-filter_reject" title="dom-NodeFilter-FILTER_REJECT">FILTER_REJECT</a> = 2;
  const unsigned short <a href="#dom-nodefilter-filter_skip" title="dom-NodeFilter-FILTER_SKIP">FILTER_SKIP</a> = 3;

  // Constants for <a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a>
  const unsigned long <a href="#dom-nodefilter-show_all" title="dom-NodeFilter-SHOW_ALL">SHOW_ALL</a> = 0xFFFFFFFF;
  const unsigned long <a href="#dom-nodefilter-show_element" title="dom-NodeFilter-SHOW_ELEMENT">SHOW_ELEMENT</a> = 0x1;
  const unsigned long <span title="dom-NodeFilter-SHOW_ATTRIBUTE">SHOW_ATTRIBUTE</span> = 0x2; // historical
  const unsigned long <a href="#dom-nodefilter-show_text" title="dom-NodeFilter-SHOW_TEXT">SHOW_TEXT</a> = 0x4;
  const unsigned long <span title="dom-NodeFilter-SHOW_CDATA_SECTION">SHOW_CDATA_SECTION</span> = 0x8; // historical
  const unsigned long <span title="dom-NodeFilter-SHOW_ENTITY_REFERENCE">SHOW_ENTITY_REFERENCE</span> = 0x10; // historical
  const unsigned long <span title="dom-NodeFilter-SHOW_ENTITY">SHOW_ENTITY</span> = 0x20; // historical
  const unsigned long <a href="#dom-nodefilter-show_processing_instruction" title="dom-NodeFilter-SHOW_PROCESSING_INSTRUCTION">SHOW_PROCESSING_INSTRUCTION</a> = 0x40;
  const unsigned long <a href="#dom-nodefilter-show_comment" title="dom-NodeFilter-SHOW_COMMENT">SHOW_COMMENT</a> = 0x80;
  const unsigned long <a href="#dom-nodefilter-show_document" title="dom-NodeFilter-SHOW_DOCUMENT">SHOW_DOCUMENT</a> = 0x100;
  const unsigned long <a href="#dom-nodefilter-show_document_type" title="dom-NodeFilter-SHOW_DOCUMENT_TYPE">SHOW_DOCUMENT_TYPE</a> = 0x200;
  const unsigned long <a href="#dom-nodefilter-show_document_fragment" title="dom-NodeFilter-SHOW_DOCUMENT_FRAGMENT">SHOW_DOCUMENT_FRAGMENT</a> = 0x400;
  const unsigned long <span title="dom-NodeFilter-SHOW_NOTATION">SHOW_NOTATION</span> = 0x800; // historical

  unsigned short <span title="dom-NodeFilter-acceptNode">acceptNode</span>(<a href="#node">Node</a> <var>node</var>);
};</pre>

<p>Объекты <code><a href="#nodefilter">NodeFilter</a></code> могут использоваться как
<a href="#concept-traversal-filter" title="concept-traversal-filter">filter</a> приемники и предоставлять
константы для <a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a>
битмаска.

<p class="note">Заметка: Это обычно реализуется в виде JavaScript функции.

<p>Данные константы могут использоваться как возвращаемое значение приемника (callback):

<ul class="brief">
 <li><dfn id="dom-nodefilter-filter_accept" title="dom-NodeFilter-FILTER_ACCEPT"><code>FILTER_ACCEPT</code></dfn> (1);
 <li><dfn id="dom-nodefilter-filter_reject" title="dom-NodeFilter-FILTER_REJECT"><code>FILTER_REJECT</code></dfn> (2);
 <li><dfn id="dom-nodefilter-filter_skip" title="dom-NodeFilter-FILTER_SKIP"><code>FILTER_SKIP</code></dfn> (3).
</ul>

<p>Данные константы могут использоваться для
<a href="#concept-traversal-whattoshow" title="concept-traversal-whatToShow">whatToShow</a> битмаска:

<ul class="brief">
 <li><dfn id="dom-nodefilter-show_all" title="dom-NodeFilter-SHOW_ALL"><code>SHOW_ALL</code></dfn> (4294967295, FFFFFFFF в шестнадцатеричном);
 <li><dfn id="dom-nodefilter-show_element" title="dom-NodeFilter-SHOW_ELEMENT"><code>SHOW_ELEMENT</code></dfn> (1);
 <!-- AttrExodus
 <li><dfn title=dom-NodeFilter-SHOW_ATTRIBUTE><code>SHOW_ATTRIBUTE</code></dfn> (2, historical);
 -->
 <li><dfn id="dom-nodefilter-show_text" title="dom-NodeFilter-SHOW_TEXT"><code>SHOW_TEXT</code></dfn> (4);
 <!-- XXX still questionable
 <li><dfn title=dom-NodeFilter-SHOW_CDATA_SECTION><code>SHOW_CDATA_SECTION</code></dfn> (8; historical);
 -->
 <li><dfn id="dom-nodefilter-show_processing_instruction" title="dom-NodeFilter-SHOW_PROCESSING_INSTRUCTION"><code>SHOW_PROCESSING_INSTRUCTION</code></dfn> (64, 40 в шестнадцатеричном);
 <li><dfn id="dom-nodefilter-show_comment" title="dom-NodeFilter-SHOW_COMMENT"><code>SHOW_COMMENT</code></dfn> (128, 80 в шестнадцатеричном);
 <li><dfn id="dom-nodefilter-show_document" title="dom-NodeFilter-SHOW_DOCUMENT"><code>SHOW_DOCUMENT</code></dfn> (256, 100 в шестнадцатеричном);
 <li><dfn id="dom-nodefilter-show_document_type" title="dom-NodeFilter-SHOW_DOCUMENT_TYPE"><code>SHOW_DOCUMENT_TYPE</code></dfn> (512, 200 в шестнадцатеричном);
 <li><dfn id="dom-nodefilter-show_document_fragment" title="dom-NodeFilter-SHOW_DOCUMENT_FRAGMENT"><code>SHOW_DOCUMENT_FRAGMENT</code></dfn> (1024, 400 в шестнадцатеричном).
</ul>

<h2 id="sets"><span class="secno">7 </span>Множества</h2>

<p class="note">Заметка: Да, имена <code><a href="#domtokenlist">DOMTokenList</a></code> и
<code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code> это не очень удачно унаследованные казусы.

<h3 id="interface-domtokenlist"><span class="secno">7.1 </span>Интерфейс <code><a href="#domtokenlist">DOMTokenList</a></code></h3>

<pre class="idl">interface <dfn id="domtokenlist">DOMTokenList</dfn> {
  readonly attribute unsigned long <a href="#dom-domtokenlist-length" title="dom-DOMTokenList-length">length</a>;
  getter DOMString? <a href="#dom-domtokenlist-item" title="dom-DOMTokenList-item">item</a>(unsigned long <var>index</var>);
  boolean <a href="#dom-domtokenlist-contains" title="dom-DOMTokenList-contains">contains</a>(DOMString <var>token</var>);
  void <a href="#dom-domtokenlist-add" title="dom-DOMTokenList-add">add</a>(DOMString... <var>tokens</var>);
  void <a href="#dom-domtokenlist-remove" title="dom-DOMTokenList-remove">remove</a>(DOMString... <var>tokens</var>);
  boolean <a href="#dom-domtokenlist-toggle" title="dom-DOMTokenList-toggle">toggle</a>(DOMString <var>token</var>, optional boolean <var>force</var>);
  <a href="#dom-domtokenlist-stringifier" title="dom-DOMTokenList-stringifier">stringifier</a>;
  iterable&lt;DOMString&gt;;
};</pre>

<p>Объект <code><a href="#domtokenlist">DOMTokenList</a></code> имеет соответствующий упорядоченный набор
<dfn id="concept-dtl-tokens" title="concept-DTL-tokens">токенов</dfn>, который изначально пуст.

<p>Объект <code><a href="#domtokenlist">DOMTokenList</a></code> также имеет соответствующий
<a href="#concept-element" title="concept-element">элемент</a> и <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> <a href="#concept-attribute" title="concept-attribute">атрибута</a>.

<p><dfn id="concept-dtl-update" title="concept-DTL-update">Шаги обновления</dfn> объекта <code><a href="#domtokenlist">DOMTokenList</a></code> это:

<ol>
 <li><p>Если нет соответствующего
 <a href="#concept-attribute" title="concept-attribute">атрибута</a> (когда объект является
 <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code>), прекратить эти шаги.

 <li><p><a href="#concept-element-attributes-set" title="concept-element-attributes-set">Установить атрибут</a>
 для соответствующего <a href="#concept-element" title="concept-element">элемента</a> используя
 соответствующее <a href="#concept-attribute-local-name" title="concept-attribute-local-name">локальное имя</a> <a href="#concept-attribute" title="concept-attribute">атрибута</a> и результат выполнения <a href="#concept-ordered-set-serializer" title="concept-ordered-set-serializer">сериализатора упорядоченных множеств</a>
 для <a href="#concept-dtl-tokens" title="concept-DTL-tokens">токенов</a>.
</ol>

<dl class="domintro">
 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-length" title="dom-DOMTokenList-length">length</a></code>
 <dd><p>Возвращает количество токенов.

 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-item" title="dom-DOMTokenList-item">item</a>(<var>index</var>)</code>
 <dt><code><var>tokenlist</var>[<var>index</var>]</code>
 <dd><p>Возвращает токен с индексом <var>index</var>.

 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-contains" title="dom-DOMTokenList-contains">contains</a>(<var>token</var>)</code>
 <dd>
  <p>Возвращает true если <var>token</var> присутствует, и false в другом случае.
  <p>Выдает исключение "<code><a href="#syntaxerror">SyntaxError</a></code>" если <var>token</var>
  является пустой строкой.
  <p>Выдает исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>" если
  <var>token</var> содержит любые
  <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>.

 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-add" title="dom-DOMTokenList-add">add</a>(<var>tokens</var>…)</code>
 <dd>
  <p>Добавляет все переданные аргументы, кроме тех которые уже присутствуют.
  <p>Выдает исключение "<code><a href="#syntaxerror">SyntaxError</a></code>" если один из аргументов является пустой строкой.
  <p>Выдает исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>" если один из аргументов содержит любые
  <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>.

 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-remove" title="dom-DOMTokenList-remove">remove</a>(<var>tokens</var>…)</code>
 <dd>
  <p>Удаляет переданные аргументы, если они присутствуют.
  <p>Выдает исключение "<code><a href="#syntaxerror">SyntaxError</a></code>" если один из аргументов является пустой строкой.
  <p>Выдает исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>" если один из аргументов содержит любые
  <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>.

 <dt><code><var>tokenlist</var> . <a href="#dom-domtokenlist-toggle" title="dom-DOMTokenList-toggle">toggle</a>(<var>token</var> [, <var>force</var>])</code>
 <dd>
  <p>Если <var>force</var> не задано, "переключает"
  <var>token</var>, удаляя его если он присутствует, и добавляет если нет. Если <var>force</var> равняется true, добавляет <var>token</var> (то же что и <code title="dom-DOMTokenList-add"><a href="#dom-domtokenlist-add">add()</a></code>). Если
  <var>force</var> равняется false, удаляет <var>token</var> (то же что и
  <code title="dom-DOMTokenList-remove"><a href="#dom-domtokenlist-remove">remove()</a></code>).
  <p>Возвращает true если <var>token</var> теперь присутствует, и false
  в другом случае.
  <p>Выдает исключение "<code><a href="#syntaxerror">SyntaxError</a></code>" если <var>token</var> является пустым.
  <p>Выдает исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>" если <var>token</var> содержит любые пробелы.
</dl>

<div class="impl">

<p>Атрибут <dfn id="dom-domtokenlist-length" title="dom-DOMTokenList-length"><code>length</code></dfn>
возвращает количество токенов
<a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.

<p><a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">Индексы поддерживаемых свойств</a> объекта это числа в диапазоне от нуля до количества
<a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a> минус один, кроме случая если
<a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a> пуст, тогда нет
<a class="external" data-anolis-spec="webidl" href="http://www.w3.org/TR/WebIDL-1/#dfn-supported-property-indices">индекса поддерживаемых свойств</a>.

<p>Метод
<dfn id="dom-domtokenlist-item" title="dom-DOMTokenList-item"><code>item(<var>index</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>index</var> равен или более чем количество токенов в
 tokens in <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, возвратить null.

 <li><p>Возвратить <var>index</var>-й токен в
 <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.
</ol>

<p>Метод
<dfn id="dom-domtokenlist-contains" title="dom-DOMTokenList-contains"><code>contains(<var>token</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>token</var> является пустой строкой, то
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#syntaxerror">SyntaxError</a></code>".

 <li><p>Если <var>token</var> содержит любые
 <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>, то
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 исключение "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li><p>Возвратить true если <var>token</var> находится в
 <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, и false в другом случае.
</ol>

<p>Метод
<dfn id="dom-domtokenlist-add" title="dom-DOMTokenList-add"><code>add(<var>tokens</var>…)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если один из <var>tokens</var> является пустой строкой,
 <a href="#dfn-throw" title="concept-throw">выдать</a> "<code><a href="#syntaxerror">SyntaxError</a></code>"
 исключение.

 <li><p>Если один из <var>tokens</var> содержит любые
 <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>, то
 <a href="#dfn-throw" title="concept-throw">выдать</a>
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>" исключение.

 <li><p>Для каждого <var>token</var> в <var>tokens</var>, в заданном порядке,
 который не в <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, добавить
 <var>token</var> в <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.

 <li><p>Выполнить <a href="#concept-dtl-update" title="concept-DTL-update">шаги обновления</a>.
</ol>

<p>Метод
<dfn id="dom-domtokenlist-remove" title="dom-DOMTokenList-remove"><code>remove(<var>tokens</var>…)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если один из <var>tokens</var> является пустой строкой,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#syntaxerror">SyntaxError</a></code>".

 <li><p>Если один из <var>tokens</var> содержит любые
 <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>, то
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li><p>Для каждого <var>token</var> в <var>tokens</var>, удалить
 <var>token</var> из <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.

 <li><p>Выполнить <a href="#concept-dtl-update" title="concept-DTL-update">шаги обновления</a>.
</ol>

<p>Метод
<dfn id="dom-domtokenlist-toggle" title="dom-DOMTokenList-toggle"><code>toggle(<var>token</var>, <var>force</var>)</code></dfn>
должен выполнить следующие шаги:

<ol>
 <li><p>Если <var>token</var> является пустой строкой,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение "<code><a href="#syntaxerror">SyntaxError</a></code>".

 <li><p>Если <var>token</var> содержит любые
 <a class="external" data-anolis-spec="encoding" href="http://www.w3.org/TR/encoding/#ascii-whitespace">ASCII пробелы</a>,
 <a href="#dfn-throw" title="concept-throw">выдать</a> исключение
 "<code><a href="#invalidcharactererror">InvalidCharacterError</a></code>".

 <li>
  <p>Если <var>token</var> в <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, выполнить следующие подшаги:

  <ol>
   <li><p>Если <var>force</var> не передан либо false, то удалить
   <var>token</var> из <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, выполнить
   <a href="#concept-dtl-update" title="concept-DTL-update">шаги обновления</a>, и возвратить false.

   <li><p>В другом случае, возвратить true.
  </ol>

 <li>
  <p>В другом случае, выполнить следующие подшаги:

  <ol>
   <li><p>Если <var>force</var> передан и равен false, возвратить false.

   <li><p>В другом случае, добавить <var>token</var> в
   <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>, выполнить
   <a href="#concept-dtl-update" title="concept-DTL-update">шаги обновления</a> и возвратить true.
  </ol>
</ol>

<p><dfn id="dom-domtokenlist-stringifier" title="dom-DOMTokenList-stringifier">stringifier</dfn> должен
возвратить результат
<a href="#concept-ordered-set-serializer" title="concept-ordered-set-serializer">сериализатора упорядоченного списка</a> для
<a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.

</div>


<h3 id="interface-domsettabletokenlist"><span class="secno">7.2 </span>Интерфейс <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code></h3>

<pre class="idl">interface <dfn id="domsettabletokenlist">DOMSettableTokenList</dfn> : <a href="#domtokenlist">DOMTokenList</a> {
            attribute DOMString <a href="#dom-domsettabletokenlist-value" title="dom-DOMSettableTokenList-value">value</a>;
};</pre>

<p>Объект <code><a href="#domsettabletokenlist">DOMSettableTokenList</a></code> эквивалентен объекту
<code><a href="#domtokenlist">DOMTokenList</a></code> без соответствующего
<a href="#concept-attribute" title="concept-attribute">атрибута</a>.

<dl class="domintro">
 <dt><code><var>tokenlist</var> . <a href="#dom-domsettabletokenlist-value" title="dom-DOMSettableTokenList-value">value</a></code>
 <dd>
  <p>Возвращает соответствующее множество как строку.
  <p>Может быть установлен, чтобы изменить соответствующее множество с помощью строки.
</dl>

<div class="impl">

<p>Атрибут <dfn id="dom-domsettabletokenlist-value" title="dom-DOMSettableTokenList-value"><code>value</code></dfn>
должен возвратить результат
<a href="#concept-ordered-set-serializer" title="concept-ordered-set-serializer">сериализатора упорядоченных множеств</a> для
<a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a>.

<p>Установка атрибута <code title="dom-DOMSettableTokenList-value"><a href="#dom-domsettabletokenlist-value">value</a></code>
должна выполнить <a href="#concept-ordered-set-parser" title="concept-ordered-set-parser">парсер упорядоченных множеств</a>
для заданного значения и установить <a href="#concept-dtl-tokens" title="concept-DTL-tokens">tokens</a> в качестве результата.

</div>



<h2 id="historical"><span class="secno">8 </span>История</h2>

<p>Как объяснялось в <a href="#goals">целях</a>, эта спецификация является значительным пересмотром различных DOM спецификаций. Этот раздел пытается перечислить изменения.


<h3 id="dom-events"><span class="secno">8.1 </span>DOM События</h3>

<p>Таковы изменения внесенные в функции описанные в главах
"DOM Event Architecture", "Basic Event Interfaces", "Mutation Events" и
"Mutation Name Event Types" <cite>UI Events Specification (ранее DOM Level 3 Events)</cite>.
<a class="informative" href="#biblio-UIEVENTS">[UIEVENTS]</a>

<ul class="brief">
 <li>Теперь события имеют конструкторы.
 <li>Удаляет <dfn id="mutationevent"><code>MutationEvent</code></dfn> и
 <dfn id="mutationnameevent"><code>MutationNameEvent</code></dfn>.
 <li>Вызов (fire) больше не синоним отправки, но включает инициализацию
 события.</li>
 <li>Флаги распространения и отмены сняты при вызове
 <code title="dom-Event-initEvent"><a href="#dom-event-initevent">initEvent()</a></code>, а не после отправки.
</ul>


<h3 id="dom-core"><span class="secno">8.2 </span>DOM Ядро</h3>

<p>Таковы изменения, внесенные в функции описанные в
<cite>DOM Level 3 Core</cite>.

<p><dfn id="domstring"><code>DOMString</code></dfn> и
<dfn id="domtimestamp"><code>DOMTimeStamp</code></dfn> теперь определены в Web IDL.

<p><code><a href="#node">Узел</a></code> теперь наследует <code><a href="#eventtarget">EventTarget</a></code>.</p>

<p><a href="#concept-node" title="concept-node">Узлы</a> неявно
<a href="#concept-node-adopt" title="concept-node-adopt">приняты</a> через границы
<a href="#concept-document" title="concept-document">документа</a>.

<p><a href="#concept-doctype" title="concept-doctype">Doctypes</a> не всегда имеют
<a href="#concept-node-document" title="concept-node-document">node document</a> и могут быть перемещены
через границы <a href="#concept-document" title="concept-document">документа</a>.

<p><code><a href="#processinginstruction">ProcessingInstruction</a></code> теперь наследует
<code><a href="#characterdata">CharacterData</a></code>.

<p><code>attributes</code> перемещены с <code><a href="#node">Node</a></code> в
<code><a href="#element">Element</a></code>.</p>

<p><code>namespaceURI</code>, <code>prefix</code> и <code>localName</code> перемещены с <code><a href="#node">Node</a></code> в
<code><a href="#element">Element</a></code> и <code><a href="#attr">Attr</a></code>.</p>

<p>Оставшаяся часть интерфейсов и членов интерфейса перечисленная в этом разделе была
удалена, чтобы упростить DOM платформу. Реализации, соответствующие данной спецификации, не будут поддерживать их.

<p class="warning">Пока что не ясно будет ли веб-совместимым
удаление всех следующих функций. Редакторы приветствуют любые данные, показывающие что
какие-либо из этих функций должны быть заново представлены.

<p>Интерфейсы:
<ul class="brief">
 <li><dfn id="cdatasection"><code>CDATASection</code></dfn>
 <li><dfn id="domconfiguration"><code>DOMConfiguration</code></dfn>
 <li><dfn id="domerrorhandler"><code>DOMErrorHandler</code></dfn>
 <li><dfn id="domimplementationlist"><code>DOMImplementationList</code></dfn>
 <li><dfn id="domimplementationsource"><code>DOMImplementationSource</code></dfn>
 <li><dfn id="domlocator"><code>DOMLocator</code></dfn>
 <li><dfn id="domobject"><code>DOMObject</code></dfn>
 <li><dfn id="domstringlist"><code>DOMStringList</code></dfn>
 <li><dfn id="domuserdata"><code>DOMUserData</code></dfn>
 <li><dfn id="entity"><code>Entity</code></dfn>
 <li><dfn id="entityreference"><code>EntityReference</code></dfn>
 <li><dfn id="namelist"><code>NameList</code></dfn>
 <li><dfn id="notation"><code>Notation</code></dfn>
 <li><dfn id="typeinfo"><code>TypeInfo</code></dfn>
 <li><dfn id="userdatahandler"><code>UserDataHandler</code></dfn>
</ul>

<p>Члены интерфейса:
<dl>
 <dt><code><a href="#node">Node</a></code>
 <dd>
  <ul class="brief">
   <!--AttrExodus-->
   <li><dfn id="dom-node-hasattributes" title="dom-Node-hasAttributes"><code>hasAttributes()</code></dfn>
   <li><dfn id="dom-node-attributes" title="dom-Node-attributes"><code>attributes</code></dfn>

   <!--NodeExodus-->
   <li><dfn id="dom-node-namespaceuri" title="dom-Node-namespaceURI"><code>namespaceURI</code></dfn>
   <li><dfn id="dom-node-prefix" title="dom-Node-prefix"><code>prefix</code></dfn>
   <li><dfn id="dom-node-localname" title="dom-Node-localName"><code>localName</code></dfn>

   <li><dfn id="dom-node-issupported" title="dom-Node-isSupported"><code>isSupported</code></dfn>
   <li><dfn id="dom-node-getfeature" title="dom-Node-getFeature"><code>getFeature()</code></dfn>
   <li><dfn id="dom-node-getuserdata" title="dom-Node-getUserData"><code>getUserData()</code></dfn>
   <li><dfn id="dom-node-setuserdata" title="dom-Node-setUserData"><code>setUserData()</code></dfn>

   <li><dfn id="dom-node-issamenode" title="dom-Node-isSameNode"><code>isSameNode()</code></dfn>
  </ul>

 <dt><code><a href="#document">Document</a></code>
 <dd>
  <ul class="brief">
   <li><dfn id="dom-document-createcdatasection" title="dom-Document-createCDATASection"><code>createCDATASection()</code></dfn>
   <li><dfn id="dom-document-createattribute" title="dom-Document-createAttribute"><code>createAttribute()</code></dfn>
   <li><dfn id="dom-document-createattributens" title="dom-Document-createAttributeNS"><code>createAttributeNS()</code></dfn>
   <li><dfn id="dom-document-createentityreference" title="dom-Document-createEntityReference"><code>createEntityReference()</code></dfn>
   <li><dfn id="dom-document-inputencoding-brief" title="dom-Document-inputEncoding"><code>inputEncoding</code></dfn>
   <li><dfn id="dom-document-xmlencoding" title="dom-Document-xmlEncoding"><code>xmlEncoding</code></dfn>
   <li><dfn id="dom-document-xmlstandalone" title="dom-Document-xmlStandalone"><code>xmlStandalone</code></dfn>
   <li><dfn id="dom-document-xmlversion" title="dom-Document-xmlVersion"><code>xmlVersion</code></dfn>
   <li><dfn id="dom-document-stricterrorchecking" title="dom-Document-strictErrorChecking"><code>strictErrorChecking</code></dfn>
   <li><dfn id="dom-document-domconfig" title="dom-Document-domConfig"><code>domConfig</code></dfn>
   <li><dfn id="dom-document-normalizedocument" title="dom-Document-normalizeDocument"><code>normalizeDocument()</code></dfn>
   <li><dfn id="dom-document-renamenode" title="dom-Document-renameNode"><code>renameNode()</code></dfn>
  </ul>

 <dt><code><a href="#domimplementation">DOMImplementation</a></code>
 <dd>
  <ul class="brief">
   <li><dfn id="dom-domimplementation-getfeature" title="dom-DOMImplementation-getFeature"><code>getFeature()</code></dfn>
  </ul>

 <dt><code><a href="#attr">Attr</a></code>
 <dd>
  <p>Больше не наследует <code><a href="#node">Node</a></code> и, следовательно, полностью изменился.
  <!--AttrExodus
  <p><dfn title=dom-Attr-schemaTypeInfo><code>schemaTypeInfo</code></dfn>
  <p><dfn title=dom-Attr-isId><code>isId</code></dfn>
  -->

 <dt><code><a href="#element">Element</a></code>
 <dd>
  <ul class="brief">
   <li><dfn id="dom-element-getattributenode" title="dom-Element-getAttributeNode"><code>getAttributeNode()</code></dfn>
   <li><dfn id="dom-element-getattributenodens" title="dom-Element-getAttributeNodeNS"><code>getAttributeNodeNS()</code></dfn>
   <li><dfn id="dom-element-setattributenode" title="dom-Element-setAttributeNode"><code>setAttributeNode()</code></dfn>
   <li><dfn id="dom-element-removeattributenode" title="dom-Element-removeAttributeNode"><code>removeAttributeNode()</code></dfn>
   <li><dfn id="dom-element-schematypeinfo" title="dom-Element-schemaTypeInfo"><code>schemaTypeInfo</code></dfn>
   <li><dfn id="dom-element-setidattribute" title="dom-Element-setIdAttribute"><code>setIdAttribute()</code></dfn>
   <li><dfn id="dom-element-setidattributens" title="dom-Element-setIdAttributeNS"><code>setIdAttributeNS()</code></dfn>
   <li><dfn id="dom-element-setidattributenode" title="dom-Element-setIdAttributeNode"><code>setIdAttributeNode()</code></dfn>
  </ul>

 <dt><code><a href="#documenttype">DocumentType</a></code>
 <dd>
  <ul class="brief">
   <li><dfn id="dom-documenttype-entities" title="dom-DocumentType-entities"><code>entities</code></dfn>
   <li><dfn id="dom-documenttype-notations" title="dom-DocumentType-notations"><code>notations</code></dfn>
   <li><dfn id="dom-documenttype-internalsubset" title="dom-DocumentType-internalSubset"><code>internalSubset</code></dfn>
  </ul>

 <dt><code><a href="#text">Text</a></code>
 <dd>
  <ul class="brief">
   <li><dfn id="dom-text-iselementcontentwhitespace" title="dom-Text-isElementContentWhitespace"><code>isElementContentWhitespace</code></dfn>
   <li><dfn id="dom-text-replacewholetext" title="dom-Text-replaceWholeText"><code>replaceWholeText()</code></dfn>
  </ul>
</dl>

<h3 id="dom-ranges"><span class="secno">8.3 </span>DOM Диапазоны</h3>

<p>Таковы изменения, внесенные в функции описанные в главе
"Document Object Model Range"
<cite>DOM Level 2 Traversal and Range</cite>.

<ul>
 <li><p><dfn id="rangeexception"><code>RangeException</code></dfn> был удален.

 <li><p><code><a href="#range">Range</a></code> могут перемещаться между
 <a href="#concept-document" title="concept-document">документами</a> и использоваться на
 <a href="#concept-node" title="concept-node">узлах</a> которые не <a href="#in-a-document">в документе</a>.

 <li><p>Появился естественный <code title="dom-Range"><a href="#dom-range">Range()</a></code> конструктор.

 <li><p>Новые методы <code title="dom-Range-comparePoint"><a href="#dom-range-comparepoint">comparePoint()</a></code>,
 <code title="dom-Range-intersectsNode"><a href="#dom-range-intersectsnode">intersectsNode()</a></code> и
 <code title="dom-Range-isPointInRange"><a href="#dom-range-ispointinrange">isPointInRange()</a></code> были добавлены.

 <li><p><code title="dom-Range-detach"><a href="#dom-range-detach">detach()</a></code> теперь не-op.

 <li><p><dfn id="dom-range-tostring" title="dom-Range-toString"><code>toString()</code></dfn> теперь определен через IDL.
</ul>


<h3 id="dom-traversal"><span class="secno">8.4 </span>DOM Обход</h3>

<p>Таковы изменения, внесенные в функции описанные в главе
"Document Object Model Traversal" <cite>DOM Level 2 Traversal and Range</cite>.

<ul>
 <li><p><code title="dom-Document-createNodeIterator"><a href="#dom-document-createnodeiterator">createNodeIterator()</a></code> и
 <code title="dom-Document-createTreeWalker"><a href="#dom-document-createtreewalker">createTreeWalker()</a></code> теперь имеют опциональные
 аргументы и не имеют четвертого аргумента, который более не актуален.

 <li><p>Атрибут <code>expandEntityReferences</code> был удален из интерфейсов
 <code><a href="#nodeiterator">NodeIterator</a></code> и <code><a href="#treewalker">TreeWalker</a></code> по вышеупомянутой причине.

 <li><p>Атрибуты <code title="dom-NodeIterator-referenceNode"><a href="#dom-nodeiterator-referencenode">referenceNode</a></code> и
 <code title="dom-NodeIterator-pointerBeforeReferenceNode"><a href="#dom-nodeiterator-pointerbeforereferencenode">pointerBeforeReferenceNode</a></code>
 были добавлены к объектам <code><a href="#nodeiterator">NodeIterator</a></code> для согласования с пропиетарными расширениями реализаций.

 <li><p><code title="dom-NodeIterator-nextNode"><a href="#dom-nodeiterator-nextnode">nextNode()</a></code> и
 <code title="dom-NodeIterator-previousNode"><a href="#dom-nodeiterator-previousnode">previousNode()</a></code> теперь выдаются
 когда вызваны с <code><a href="#nodefilter">NodeFilter</a></code> для согласования с агентами пользователей.

 <li><p><code title="dom-NodeIterator-detach"><a href="#dom-nodeiterator-detach">detach()</a></code> теперь не-op.
</ul>



<h2 id="errors"><span class="secno">А. </span>Исключения и ошибки</h2>

<h3 id="exceptions"><span class="secno">А.1 </span>Исключения</h3>

<p class='warning'>Весь этот раздел был перенесен в <a href="http://www.w3.org/TR/WebIDL-1/#idl-DOMException">IDL</a>. Обратитесь к [<a href='#biblio-WEBIDL'>Web IDL</a>] для последних определений.

 <p>
            <dfn id="dfn-exception">Исключение</dfn> это тип объекта, который
            представляет ошибку и который может быть выдан или обработан как значение
            первого типа в реализациях.  Web IDL не позволяет исключениям
            быть определяемыми, но вместо этого имеет ряд предопределенных исключений,
            на которые можно ссылаться и выдавать в собственных определениях
            операций, атрибутов и так далее.  Исключения имеют
            <dfn id="dfn-exception-error-name">имя ошибки</dfn>,
            <code>DOMString</code>,
            которое является типом ошибки которую исключение представляет, и
            <dfn id="dfn-exception-message">сообщение</dfn>, которое является опциональным,
            определенное пользовательским агентом значение, которое предоставляет читабельные людьми подробности ошибки.
          </p>
          <p>
            Один вид исключений это <dfn id="dfn-DOMException">DOMException</dfn>,
            которое является исключением содержащим имя и <dfn id="dom-domexception-code">опциональный целочисленный код</dfn>,
            для совместимости с исторически определенными исключениями в DOM.
          </p>
          <p>
            Для <a class="dfnref" href="#dfn-DOMException">DOMException</a>,
            <a class="dfnref" href="#dfn-exception-error-name">имя ошибки</a> должно
            быть одним из имен перечисленных в <a class="dfnref" href="#dfn-error-names-table">таблице имен ошибок</a>
            ниже. В таблице также указаны целочисленные коды <a class="dfnref" href="#dfn-DOMException">DOMException</a>
            для этого имени ошибки, если оно имеет его.
          </p>
          <p>
            Исключения могут быть <dfn id="dfn-create-exception">созданы</dfn> предоставлением их
            <a class="dfnref" href="#dfn-exception-error-name">имени ошибки</a>.
            Исключения также могут быть <dfn id="dfn-throw">выданы</dfn>, с помощью предоставления
            некоторых деталей обязательных для ее <a class="dfnref" href="#dfn-create-exception">создания</a>.
          </p>

<h3 id="sec-domerror"><span class="secno">А.2 </span>Интерфейс <code>DOMError</code></h3>

<pre class="idl">[<a href="#dom-domerror" title="dom-DOMError">Constructor</a>(DOMString <var>name</var>, optional DOMString <var>message</var> = "")]
interface <dfn id="domerror">DOMError</dfn> {
  readonly attribute DOMString <a href="#dom-domerror-name" title="dom-DOMError-name">name</a>;
  readonly attribute DOMString <a href="#dom-domerror-message" title="dom-DOMError-message">message</a>;
};</pre>

<p class="warning"><code><a href="#domerror">DOMError</a></code> является устаревшим и не должен использоваться. Смотрите <code><a href='http://www.w3.org/TR/WebIDL-1/#idl-Error'>Error</a></code> в WebIDL вместо него.</p>

<p class="note">Этот интерфейс используется исключительно по историческим причинам. Как и с исключениями, используется <a href="#error-names">таблица имен ошибок</a>.

</p><p>Конструктор <dfn id="dom-domerror" title="dom-DOMError"><code>DOMError(<var>name</var>, <var>message</var>)</code></dfn>
должен возвратить новый объект <code><a href="#domerror">DOMError</a></code>, чей атрибут
<code title="dom-DOMError-name"><a href="#dom-domerror-name">name</a></code> инициализирован к
<var>name</var> и чей атрибут <code title="dom-DOMError-message"><a href="#dom-domerror-message">message</a></code> инициализирован к <var>message</var>.

</p><p>Атрибут <dfn id="dom-domerror-name" title="dom-DOMError-name"><code>name</code></dfn> должен возвратить значение к которому был инициализирован.

</p><p>Атрибут <dfn id="dom-domerror-message" title="dom-DOMError-message"><code>message</code></dfn> должен возвратить значение к которому был инициализирован.

</p><p class="note">Значение <code title="dom-DOMError-message"><a href="#dom-domerror-message">message</a></code> обычно будет зависеть от реализации и используется только для информативной цели.

</p><p>
<dfn id="concept-domerror" title="concept-DOMError"><var>Имя</var> <code>DOMError</code></dfn>
означает объект <code><a href="#domerror">DOMError</a></code>, чей атрибут
<code title="dom-DOMError-name"><a href="#dom-domerror-name">name</a></code> инициализирован к
<var>name</var> и чей атрибут <code title="dom-DOMError-message"><a href="#dom-domerror-message">message</a></code> инициализирован к полезному зависящему от реализации сообщению, описывающему ошибку.


<h3 id="error-names-0"><span class="secno">А.3 </span>Имена ошибок</h3>

<p><dfn id="dfn-error-names-table">Таблица имен ошибок</dfn> ниже содержит все разрешенные имена ошибок,
описание и унаследованный <code title="dom-DOMException-code"><a href="#dom-domexception-code">code</a></code> ошибок (когда имя ошибки используется для
<a href="#dfn-throw" title="concept-throw">выдачи</a> исключения).

<p class='warning'>Весь этот раздел был перенесен в <a href="http://www.w3.org/TR/WebIDL-1/#h-idl-domexception-error-names">WebIDL</a>. Обратитесь к [<a href='#biblio-WEBIDL'>Web IDL</a>] за последними определениями.

<table id="error-names">
 <thead>
 <tr><th>Имя<th>Описание<th>Унаследованный <code title="dom-DOMException-code"><a href="#dom-domexception-code">code</a></code> исключения (если есть)
 <tbody>
 <tr>
  <td>"<dfn id="indexsizeerror"><code>IndexSizeError</code></dfn>"
  <td>Index вне дозволенного диапазона.
  <td><dfn id="dom-domexception-index_size_err" title="dom-DOMException-INDEX_SIZE_ERR"><code>INDEX_SIZE_ERR</code></dfn> (1)
 <tr>
  <td>"<dfn id="hierarchyrequesterror"><code>HierarchyRequestError</code></dfn>"
  <td>Операция привела бы к некорректному <a href="#concept-node-tree" title="concept-node-tree">дереву узлов</a>.
  <td><dfn id="dom-domexception-hierarchy_request_err" title="dom-DOMException-HIERARCHY_REQUEST_ERR"><code>HIERARCHY_REQUEST_ERR</code></dfn> (3)
 <tr>
  <td>"<dfn id="wrongdocumenterror"><code>WrongDocumentError</code></dfn>"
  <td>Объект находится в неправильном <a href="#concept-document" title="concept-document">документе</a>.
  <td><dfn id="dom-domexception-wrong_document_err" title="dom-DOMException-WRONG_DOCUMENT_ERR"><code>WRONG_DOCUMENT_ERR</code></dfn> (4)
 <tr>
  <td>"<dfn id="invalidcharactererror"><code>InvalidCharacterError</code></dfn>"
  <td>Строка содержит невалидные символы.
  <td><dfn id="dom-domexception-invalid_character_err" title="dom-DOMException-INVALID_CHARACTER_ERR"><code>INVALID_CHARACTER_ERR</code></dfn> (5)
 <tr>
  <td>"<dfn id="nomodificationallowederror"><code>NoModificationAllowedError</code></dfn>"
  <td>Объект не может быть изменен.
  <td><dfn id="dom-domexception-no_modification_allowed_err" title="dom-DOMException-NO_MODIFICATION_ALLOWED_ERR"><code>NO_MODIFICATION_ALLOWED_ERR</code></dfn> (7)
 <tr>
  <td>"<dfn id="notfounderror"><code>NotFoundError</code></dfn>"
  <td>Объект не может быть найден здесь.
  <td><dfn id="dom-domexception-not_found_err" title="dom-DOMException-NOT_FOUND_ERR"><code>NOT_FOUND_ERR</code></dfn> (8)
 <tr>
  <td>"<dfn id="notsupportederror"><code>NotSupportedError</code></dfn>"
  <td>Операция не поддерживается.
  <td><dfn id="dom-domexception-not_supported_err" title="dom-DOMException-NOT_SUPPORTED_ERR"><code>NOT_SUPPORTED_ERR</code></dfn> (9)
 <tr>
  <td>"<dfn id="invalidstateerror"><code>InvalidStateError</code></dfn>"
  <td>Объект находится в недопустимом состоянии.
  <td><dfn id="dom-domexception-invalid_state_err" title="dom-DOMException-INVALID_STATE_ERR"><code>INVALID_STATE_ERR</code></dfn> (11)
 <tr>
  <td>"<dfn id="syntaxerror"><code>SyntaxError</code></dfn>"
  <td>Строка не подходит к ожидаемому паттерну.
  <td><dfn id="dom-domexception-syntax_err" title="dom-DOMException-SYNTAX_ERR"><code>SYNTAX_ERR</code></dfn> (12)
 <tr>
  <td>"<dfn id="invalidmodificationerror"><code>InvalidModificationError</code></dfn>"
  <td>Объект не может быть изменен данным образом.
  <td><dfn id="dom-domexception-invalid_modification_err" title="dom-DOMException-INVALID_MODIFICATION_ERR"><code>INVALID_MODIFICATION_ERR</code></dfn> (13)
 <tr>
  <td>"<dfn id="namespaceerror"><code>NamespaceError</code></dfn>"
  <td>Операция не разрешена в <cite>Пространствах имен XML</cite>. <a href="#biblio-XMLNS">[XMLNS]</a>
  <td><dfn id="dom-domexception-namespace_err" title="dom-DOMException-NAMESPACE_ERR"><code>NAMESPACE_ERR</code></dfn> (14)
 <tr>
  <td>"<dfn id="invalidaccesserror"><code>InvalidAccessError</code></dfn>"
  <td>Объект не поддерживает операцию или аргумент.
  <td><dfn id="dom-domexception-invalid_access_err" title="dom-DOMException-INVALID_ACCESS_ERR"><code>INVALID_ACCESS_ERR</code></dfn> (15)
 <tr>
  <!-- XHR -->
  <td>"<dfn id="securityerror"><code>SecurityError</code></dfn>"
  <td>Операция небезопасна.
  <td><dfn id="dom-domexception-security_err" title="dom-DOMException-SECURITY_ERR"><code>SECURITY_ERR</code></dfn> (18)
 <tr>
  <!-- XHR -->
  <td>"<dfn id="networkerror"><code>NetworkError</code></dfn>"
  <td>Произошла ошибка сети.
  <td><dfn id="dom-domexception-network_err" title="dom-DOMException-NETWORK_ERR"><code>NETWORK_ERR</code></dfn> (19)
 <tr>
  <!-- XHR -->
  <td>"<dfn id="aborterror"><code>AbortError</code></dfn>"
  <td>Операция была прервана.
  <td><dfn id="dom-domexception-abort_err" title="dom-DOMException-ABORT_ERR"><code>ABORT_ERR</code></dfn> (20)
 <tr>
  <!-- Workers -->
  <td>"<dfn id="urlmismatcherror"><code>URLMismatchError</code></dfn>"
  <td>Заданный URL не соответствует другому URL.
  <td><dfn id="dom-domexception-url_mismatch_err" title="dom-DOMException-URL_MISMATCH_ERR"><code>URL_MISMATCH_ERR</code></dfn> (21)
 <tr>
  <!-- HTML -->
  <td>"<dfn id="quotaexceedederror"><code>QuotaExceededError</code></dfn>"
  <td>Квота превышена.
  <td><dfn id="dom-domexception-quota_exceeded_err" title="dom-DOMException-QUOTA_EXCEEDED_ERR"><code>QUOTA_EXCEEDED_ERR</code></dfn> (22)
 <tr>
  <!-- XHR -->
  <td>"<dfn id="timeouterror"><code>TimeoutError</code></dfn>"
  <td>Время операции вышло.
  <td><dfn id="dom-domexception-timeout_err" title="dom-DOMException-TIMEOUT_ERR"><code>TIMEOUT_ERR</code></dfn> (23)
 <tr>
  <td>"<dfn id="invalidnodetypeerror"><code>InvalidNodeTypeError</code></dfn>"
  <td>Соответствующий узел неправилен или имеет неправильного предка для этой операции.
  <td><dfn id="dom-domexception-invalid_node_type_err" title="dom-DOMException-INVALID_NODE_TYPE_ERR"><code>INVALID_NODE_TYPE_ERR</code></dfn> (24)
 <tr>
  <!-- HTML -->
  <td>"<dfn id="datacloneerror"><code>DataCloneError</code></dfn>"
  <td>Объект не может быть клонирован.
  <td><dfn id="dom-domexception-data_clone_err" title="dom-DOMException-DATA_CLONE_ERR"><code>DATA_CLONE_ERR</code></dfn> (25)
 <tr>
  <!-- Encoding -->
  <td>"<dfn id="encodingerror"><code>EncodingError</code></dfn>"
  <td>Операция кодирования (или декодирования) не удалась.
  <td>—
 <tr>
  <!-- File API -->
  <td>"<dfn id="notreadableerror"><code>NotReadableError</code></dfn>"
  <td>Операция чтения I/O не удалась.
  <td>
</table>

<h2 id="css-concepts"><span class="secno">Б. </span>Концепты CSS</h2>

<p class="note">Заметка: Этот раздел содержит концепты представленные в Selectors Level 4 и будет удален в будущем, как только спецификация Selectors Level 4 будет обновлена. Обратитесь к <a href="#biblio-SELECTORS">[SELECTORS]</a> для актуальных определений.</p>

<dl>
<dt id="css4-scoping-root">scoping root</dt>
<dd>Некоторые приложения могут выбрать область использования селекторов в конкретном поддереве или фрагменте документа. Корень области использования поддерева называется scoping root.</dd>
<dt id="css4-scope-element">:scope elements</dt>
<dd> Корень поддерева области использования, scoping root, может быть true элементом (элементом области использования) или виртуальным (таким как DocumentFragment).</dd>
<dt id="css4-scope_filtered">scope-filtered</dt>
<dd>Когда применяется scope, селектор соответствует элементу только если элемент внутри scope, даже если другие компоненты селектора находятся за пределами scope. (Элемент области использования рассматривается как находящийся в scope.)</dd>
<dt id="css4-parse-a-relative-selector">parse a relative selector</dt>
<dd>Метод для парсинга относящегося селектора
из исходной строки, против :scope elements refs. Он возвращает комплексный список селекторов, либо ошибку.</dd>
<dt id="css4-evaluate-a-selector">evaluate a selector</dt>
<dd>Метод оценки селектор против набора элементов.</dd>
<dt id="css4-parse-a-selector">parse a selector</dt>
<dd>Метод для парсинга селектора
из исходной строки. Он возвращает комплексный список селекторов, либо ошибку.</dd>
</dl>

<h2 class="no-num" id="references">Ссылки</h2>
<div id="anolis-references"><dl><dt id="biblio-CSSOMVIEW">[CSSOMVIEW]
<dd>(Не-нормативные) <ul><li><cite><a href="http://www.w3.org/TR/DOM-Level-2-Style/">Document Object Model (DOM) Level 2 Style</a></cite>, C. Wilson, P. Le Hégaret, V. Apparao. W3C.</li>
  <li><cite><a href="http://www.w3.org/TR/cssom-view/">CSSOM View Module</a></cite>, S. Pieters, G. Adams. W3C.</li>
</ul></dd>

<dt id="biblio-DOM2TR">[DOM2TR]
<dd>(Не-нормативная) <cite><a href="http://www.w3.org/TR/DOM-Level-2-Traversal-Range/">Document Object Model (DOM) Level 2 Traversal and Range Specification</a></cite>, Joe Kesselman, Jonathan Robie, Mike Champion и другие. W3C.

<dt id="biblio-DOM3CORE">[DOM3CORE]
<dd>(Не-нормативная) <cite><a href="http://www.w3.org/TR/DOM-Level-3-Core/">Document Object Model (DOM) Level 3 Core Specification</a></cite>, Arnaud Le Hors, Philippe Le Hégaret, Lauren Wood и другие. W3C.

<dt id="biblio-DOMPS">[DOMPS]
<dd>(Не-нормативная) <cite><a href="http://www.w3.org/TR/DOM-Parsing/">DOM Parsing and Serialization</a></cite>, T. Leithead. Работа в процессе. W3C.</dd>

<dt id="biblio-ELEMENTTRAVERSAL">[ELEMENTTRAVERSAL]
<dd>(Не-нормативная) <cite><a href="http://www.w3.org/TR/ElementTraversal/">Element Traversal Specification</a></cite>, Doug Schepers. W3C.

<dt id="biblio-ENCODING">[ENCODING]
<dd><cite><a href="http://www.w3.org/TR/encoding/">Encoding</a></cite>, A. van Kesteren, J. Bell, A. Phillips. W3C.</dd>

<dt id="biblio-HTML">[HTML]
<dd>
   <cite><a href="http://www.w3.org/TR/html5/">HTML5</a></cite>,
   R. Berjon, T. Leithead, E. Doyle Navara, E. O'Connor, S. Pfeiffer. W3C.</dd>

<dt id="biblio-RFC2119">[RFC2119]
<dd><cite><a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a></cite>, Scott Bradner. IETF.

<dt id="biblio-SELECTORS">[SELECTORS]
<dd><cite><a href="http://www.w3.org/TR/selectors4/">Selectors Level 4</a></cite>, E. Etemad, T. Atkins. W3C.</dd>

<dt id="biblio-SELECTORSAPI">[SELECTORSAPI]
<dd>(Не-нормативная) <cite><a href="http://www.w3.org/TR/selectors-api2/">Selectors API Level 2</a></cite>, Lachlan Hunt. W3C.

<dt id="biblio-TOUCHEVENTS">[TOUCHEVENTS]
<dd><cite><a href="http://www.w3.org/TR/touch-events/">Touch Events</a></cite>, Doug Schepers, Sangwhan Moon, Matt Brubeck и Arthur Barstow. W3C.</dd>

<dt id="biblio-UIEVENTS">[UIEVENTS]
<dd><cite><a href="http://www.w3.org/TR/uievents/">UI Events (formerly DOM Level 3 Events)</a></cite>, Gary Kacmarcik и Travis Leithead. W3C.</dd>

<dt id="biblio-URL">[URL]
<dd>
  (Не-нормативная)
  <div class="note">
       <p>
         <b>Заметка:</b>
         URL-адреса могут использоваться множеством различных способов, во многих различных контекстах. Для получения строгих URL вы можете рассмотреть <a href="#biblio-RFC3986">[RFC3986]</a> <a href="#biblio-RFC3987">[RFC3987]</a>. Спецификация W3C URL определяет термин URL, различные алгоритмы для работы с URL-адресами и API для построения, парсинга и разрешения URL-адресов.
         Разработчикам веб-браузеров советуется быть в курсе последних разработок URL путем отслеживания прогресса на <a href="https://url.spec.whatwg.org/">https://url.spec.whatwg.org/</a>. Мы ожидаем, что черновик
         W3C URL будет развиваться по пути Рекомендации как сообщество сходится в определении обработки URL.
       </p>
     </div>
  <ul>
    <li><cite><a href="https://url.spec.whatwg.org/">URL</a></cite>, Anne van Kesteren. WHATWG.</li>
    <li><cite><a id="biblio-RFC3986" href="http://www.ietf.org/rfc/rfc3986.txt">RFC3986</a></cite>, T. Berners-Lee; R. Fielding; L. Masinter. IETF.</li>
    <li><cite><a id="biblio-RFC3987" href="http://www.ietf.org/rfc/rfc3987.txt">RFC3987</a></cite>, M. Duerst, M. Suignard. IETF.</li>
  </ul>
</dd>

<dt id="biblio-WEBIDL">[WEBIDL]
<dd><cite><a href="http://www.w3.org/TR/WebIDL-1/">Web IDL Level 1</a></cite>, Cameron McCormack, Boris Zbarsky, Yves Lafon, Travis Leithead. W3C.</dd>

<dt id="biblio-XML">[XML]
<dd><cite><a href="http://www.w3.org/TR/xml/">Extensible Markup Language</a></cite>, Tim Bray, Jean Paoli, C. M. Sperberg-McQueen и другие. W3C.

<dt id="biblio-XMLNS">[XMLNS]
<dd><cite><a href="http://www.w3.org/TR/xml-names/">Namespaces in XML</a></cite>, Tim Bray, Dave Hollander, Andrew Layman и другие. W3C.

</dl></div>



<h2 class="no-num" id="acknowledgments">Благодарности</h2>

<p>Было много людей, которые помогали сделать DOM более совместимым на протяжении лет
и тем самым способствовали достижению целей этого стандарта. Также много людей помогли сделать этот стандарт тем чем он является сегодня.

<p>Так что, большое спасибо
Adam Klein,
Adrian Bateman,
Alex Russell,
Arkadiusz Michalski,
Arnaud Le Hors,
Arun Ranganathan,
Björn Höhrmann,
Boris Zbarsky,
Brandon Slade,
Brandon Wallace,
Brian Kardell,
Cameron McCormack,
Christophe Dumez,
Daniel Glazman,
David Bruant,
David Flanagan,
David Håsäther,
Dethe Elza,
Dimitri Glazkov,
Domenic Denicola,
Dominic Cooney,
Dominique Hazaël-Massieux,
Don Jordan,
Doug Schepers,
Erik Arvidsson,
Gavin Nicol,
Geoffrey Sneddon,
Glenn Maynard,
Harald Alvestrand,
Henri Sivonen,
Ian Hickson,
Igor Bukanov,
Jacob Rossi,
Jake Archibald<!-- technically B.J. Archibald -->,
Jake Verbaten,
James Graham,
James Robinson,
Jens Lindström,
João Eiras,
Joe Kesselman,
Jonas Sicking,
Jonathan Robie,
Joshua Bell,
Justin Summerlin,
呂康豪 (Kang-Hao Lu),
Kevin Sweeney,
Lachlan Hunt,
Lauren Wood,
Manish Goregaokar,
Manish Tripathi,
Marcos Caceres,
Mark Miller,
Mats Palmgren,
Mounir Lamouri,
Michael™ Smith,
Mike Champion,
Ojan Vafai,
Olli Pettay,
Ondřej Žára,
Peter Sharpe,
Philip Jägenstedt,
Philippe Le Hégaret,
Rafael Weinstein,
Rick Waldron,
Robbert Broersma,
Robin Berjon,
Rune <span title="Fabulous">F.</span> Halvorsen,
Ryosuke Niwa,
Seo Sanghyeon,
Shiki Okasaka,
Simon Pieters,
Steve Byrne,
Stig Halvorsen,
Tab Atkins,
Timo Tijhof,
Tom Pixley,
Travis Leithead,
Vidur Apparao,
Warren He,
Yehuda Katz,
Yoichi Osato и
Zack Weinberg
за то что они такие молодцы!

<p>Этот стандарт написан
<a href="https://annevankesteren.nl/" rel="nofollow" lang="nl">Anne van Kesteren</a>
(<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>) с существенным вкладом
Aryeh Gregor (<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:ayg@aryeh.name">ayg@aryeh.name</a>)
и Ms2ger (<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:ms2ger@gmail.com">ms2ger@gmail.com</a>).

<p>Под лицензией <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0</a>, насколько это возможно по закону, редакторы WHATWG отказались от копирайта и связанных или смежных прав на <a href='https://dom.spec.whatwg.org/'>WHATWG работу</a>.
